globalThis.global = globalThis;
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key3, value) => key3 in obj ? __defProp(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name3 in all)
    __defProp(target, name3, { get: all[name3], enumerable: true });
};
var __copyProps = (to, from2, except, desc2) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key3 of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key3) && key3 !== except)
        __defProp(to, key3, { get: () => from2[key3], enumerable: !(desc2 = __getOwnPropDesc(from2, key3)) || desc2.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key3, value) => {
  __defNormalProp(obj, typeof key3 !== "symbol" ? key3 + "" : key3, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// .svelte-kit/output/server/chunks/ssr.js
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b) {
  return a2 != a2 ? b == b : a2 !== b || a2 && typeof a2 === "object" || typeof a2 === "function";
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function compute_rest_props(props, keys2) {
  const rest = {};
  keys2 = new Set(keys2);
  for (const k in props)
    if (!keys2.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function split_css_unit(value) {
  const split2 = typeof value === "string" && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return split2 ? [parseFloat(split2[1]), split2[2] || "px"] : [
    /** @type {number} */
    value,
    "px"
  ];
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function set_current_component(component8) {
  current_component = component8;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component8 = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component8.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component8, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key3, context) {
  get_current_component().$$.context.set(key3, context);
  return context;
}
function getContext(key3) {
  return get_current_component().$$.context.get(key3);
}
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function spread(args, attrs_to_add) {
  const attributes = Object.assign({}, ...args);
  if (attrs_to_add) {
    const classes_to_add = attrs_to_add.classes;
    const styles_to_add = attrs_to_add.styles;
    if (classes_to_add) {
      if (attributes.class == null) {
        attributes.class = classes_to_add;
      } else {
        attributes.class += " " + classes_to_add;
      }
    }
    if (styles_to_add) {
      if (attributes.style == null) {
        attributes.style = style_object_to_string(styles_to_add);
      } else {
        attributes.style = style_object_to_string(
          merge_ssr_styles(attributes.style, styles_to_add)
        );
      }
    }
  }
  let str = "";
  Object.keys(attributes).forEach((name3) => {
    if (invalid_attribute_name_character.test(name3))
      return;
    const value = attributes[name3];
    if (value === true)
      str += " " + name3;
    else if (boolean_attributes.has(name3.toLowerCase())) {
      if (value)
        str += " " + name3;
    } else if (value != null) {
      str += ` ${name3}="${value}"`;
    }
  });
  return str;
}
function merge_ssr_styles(style_attribute, style_directive) {
  const style_object = {};
  for (const individual_style of style_attribute.split(";")) {
    const colon_index = individual_style.indexOf(":");
    const name3 = individual_style.slice(0, colon_index).trim();
    const value = individual_style.slice(colon_index + 1).trim();
    if (!name3)
      continue;
    style_object[name3] = value;
  }
  for (const name3 in style_directive) {
    const value = style_directive[name3];
    if (value) {
      style_object[name3] = value;
    } else {
      delete style_object[name3];
    }
  }
  return style_object;
}
function escape(value, is_attr = false) {
  const str = String(value);
  const pattern2 = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern2.lastIndex = 0;
  let escaped2 = "";
  let last2 = 0;
  while (pattern2.test(str)) {
    const i2 = pattern2.lastIndex - 1;
    const ch = str[i2];
    escaped2 += str.substring(last2, i2) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last2 = i2 + 1;
  }
  return escaped2 + str.substring(last2);
}
function escape_attribute_value(value) {
  const should_escape = typeof value === "string" || value && typeof value === "object";
  return should_escape ? escape(value, true) : value;
}
function escape_object(obj) {
  const result = {};
  for (const key3 in obj) {
    result[key3] = escape_attribute_value(obj[key3]);
  }
  return result;
}
function each(items, fn) {
  items = ensure_array_like(items);
  let str = "";
  for (let i2 = 0; i2 < items.length; i2 += 1) {
    str += fn(items[i2], i2);
  }
  return str;
}
function validate_component(component8, name3) {
  if (!component8 || !component8.$$render) {
    if (name3 === "svelte:component")
      name3 += " this={...}";
    throw new Error(
      `<${name3}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name3}>.`
    );
  }
  return component8;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      // these will be immediately discarded
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = /* @__PURE__ */ new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: /* @__PURE__ */ new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css3) => css3.code).join("\n"),
          map: null
          // TODO
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name3, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  const assignment = boolean && value === true ? "" : `="${escape(value, true)}"`;
  return ` ${name3}${assignment}`;
}
function style_object_to_string(style_object) {
  return Object.keys(style_object).filter((key3) => style_object[key3]).map((key3) => `${key3}: ${escape_attribute_value(style_object[key3])};`).join(" ");
}
function add_styles(style_object) {
  const styles = style_object_to_string(style_object);
  return styles ? ` style="${styles}"` : "";
}
var identity, current_component, _boolean_attributes, boolean_attributes, invalid_attribute_name_character, ATTR_REGEX, CONTENT_REGEX, missing_component, on_destroy;
var init_ssr = __esm({
  ".svelte-kit/output/server/chunks/ssr.js"() {
    identity = (x2) => x2;
    _boolean_attributes = /** @type {const} */
    [
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ];
    boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
    invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    ATTR_REGEX = /[&"]/g;
    CONTENT_REGEX = /[&<]/g;
    missing_component = {
      $$render: () => ""
    };
  }
});

// .svelte-kit/output/server/chunks/shared-server.js
function set_private_env(environment) {
  private_env = environment;
}
function set_public_env(environment) {
  public_env = environment;
}
var private_env, public_env;
var init_shared_server = __esm({
  ".svelte-kit/output/server/chunks/shared-server.js"() {
    private_env = {};
    public_env = {};
  }
});

// node_modules/.pnpm/@planetscale+database@1.11.0/node_modules/@planetscale/database/dist/sanitization.js
function format(query, values) {
  return Array.isArray(values) ? replacePosition(query, values) : replaceNamed(query, values);
}
function replacePosition(query, values) {
  let index8 = 0;
  return query.replace(/\?/g, (match) => {
    return index8 < values.length ? sanitize(values[index8++]) : match;
  });
}
function replaceNamed(query, values) {
  return query.replace(/:(\w+)/g, (match, name3) => {
    return hasOwn(values, name3) ? sanitize(values[name3]) : match;
  });
}
function hasOwn(obj, name3) {
  return Object.prototype.hasOwnProperty.call(obj, name3);
}
function sanitize(value) {
  if (value == null) {
    return "null";
  }
  if (typeof value === "number") {
    return String(value);
  }
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  if (typeof value === "string") {
    return quote(value);
  }
  if (Array.isArray(value)) {
    return value.map(sanitize).join(", ");
  }
  if (value instanceof Date) {
    return quote(value.toISOString().replace("Z", ""));
  }
  return quote(value.toString());
}
function quote(text3) {
  return `'${escape2(text3)}'`;
}
function escape2(text3) {
  return text3.replace(re, replacement);
}
function replacement(text3) {
  switch (text3) {
    case '"':
      return '\\"';
    case "'":
      return "\\'";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\\":
      return "\\\\";
    case "\0":
      return "\\0";
    case "\b":
      return "\\b";
    case "":
      return "\\Z";
    default:
      return "";
  }
}
var re;
var init_sanitization = __esm({
  "node_modules/.pnpm/@planetscale+database@1.11.0/node_modules/@planetscale/database/dist/sanitization.js"() {
    re = /[\0\b\n\r\t\x1a\\"']/g;
  }
});

// node_modules/.pnpm/@planetscale+database@1.11.0/node_modules/@planetscale/database/dist/text.js
function decode(text3) {
  return text3 ? decoder.decode(Uint8Array.from(bytes(text3))) : "";
}
function bytes(text3) {
  return text3.split("").map((c) => c.charCodeAt(0));
}
var decoder;
var init_text = __esm({
  "node_modules/.pnpm/@planetscale+database@1.11.0/node_modules/@planetscale/database/dist/text.js"() {
    decoder = new TextDecoder("utf-8");
  }
});

// node_modules/.pnpm/@planetscale+database@1.11.0/node_modules/@planetscale/database/dist/version.js
var Version;
var init_version = __esm({
  "node_modules/.pnpm/@planetscale+database@1.11.0/node_modules/@planetscale/database/dist/version.js"() {
    Version = "1.11.0";
  }
});

// node_modules/.pnpm/@planetscale+database@1.11.0/node_modules/@planetscale/database/dist/index.js
function protocol(protocol2) {
  return protocol2 === "http:" ? protocol2 : "https:";
}
function buildURL(url) {
  const scheme2 = `${protocol(url.protocol)}//`;
  return new URL(url.pathname, `${scheme2}${url.host}`).toString();
}
async function postJSON(config, url, body = {}) {
  const auth2 = btoa(`${config.username}:${config.password}`);
  const { fetch: fetch2 } = config;
  const response = await fetch2(url.toString(), {
    method: "POST",
    body: JSON.stringify(body),
    headers: {
      "Content-Type": "application/json",
      "User-Agent": `database-js/${Version}`,
      Authorization: `Basic ${auth2}`
    },
    cache: "no-store"
  });
  if (response.ok) {
    return await response.json();
  } else {
    let error3 = null;
    try {
      const e = (await response.json()).error;
      error3 = new DatabaseError(e.message, response.status, e);
    } catch {
      error3 = new DatabaseError(response.statusText, response.status, {
        code: "internal",
        message: response.statusText
      });
    }
    throw error3;
  }
}
function connect(config) {
  return new Connection(config);
}
function parseArrayRow(fields, rawRow, cast2) {
  const row = decodeRow(rawRow);
  return fields.map((field, ix) => {
    return cast2(field, row[ix]);
  });
}
function parseObjectRow(fields, rawRow, cast2) {
  const row = decodeRow(rawRow);
  return fields.reduce((acc, field, ix) => {
    acc[field.name] = cast2(field, row[ix]);
    return acc;
  }, {});
}
function parse(result, cast2, returnAs) {
  const fields = result.fields;
  const rows = result.rows ?? [];
  return rows.map((row) => returnAs === "array" ? parseArrayRow(fields, row, cast2) : parseObjectRow(fields, row, cast2));
}
function decodeRow(row) {
  const values = row.values ? atob(row.values) : "";
  let offset2 = 0;
  return row.lengths.map((size2) => {
    const width = parseInt(size2, 10);
    if (width < 0)
      return null;
    const splice = values.substring(offset2, offset2 + width);
    offset2 += width;
    return splice;
  });
}
function cast(field, value) {
  if (value === "" || value == null) {
    return value;
  }
  switch (field.type) {
    case "INT8":
    case "INT16":
    case "INT24":
    case "INT32":
    case "UINT8":
    case "UINT16":
    case "UINT24":
    case "UINT32":
    case "YEAR":
      return parseInt(value, 10);
    case "FLOAT32":
    case "FLOAT64":
      return parseFloat(value);
    case "DECIMAL":
    case "INT64":
    case "UINT64":
    case "DATE":
    case "TIME":
    case "DATETIME":
    case "TIMESTAMP":
    case "BLOB":
    case "BIT":
    case "VARBINARY":
    case "BINARY":
    case "GEOMETRY":
      return value;
    case "JSON":
      return JSON.parse(decode(value));
    default:
      return decode(value);
  }
}
var DatabaseError, defaultExecuteOptions, Tx, Connection;
var init_dist = __esm({
  "node_modules/.pnpm/@planetscale+database@1.11.0/node_modules/@planetscale/database/dist/index.js"() {
    init_sanitization();
    init_sanitization();
    init_text();
    init_text();
    init_version();
    DatabaseError = class extends Error {
      constructor(message, status, body) {
        super(message);
        this.status = status;
        this.name = "DatabaseError";
        this.body = body;
      }
    };
    defaultExecuteOptions = {
      as: "object"
    };
    Tx = class {
      constructor(conn) {
        this.conn = conn;
      }
      async execute(query, args = null, options2 = defaultExecuteOptions) {
        return this.conn.execute(query, args, options2);
      }
    };
    Connection = class _Connection {
      constructor(config) {
        var _a178;
        this.session = null;
        this.config = { ...config };
        if (typeof fetch !== "undefined") {
          (_a178 = this.config).fetch || (_a178.fetch = fetch);
        }
        if (config.url) {
          const url = new URL(config.url);
          this.config.username = url.username;
          this.config.password = url.password;
          this.config.host = url.hostname;
          this.url = buildURL(url);
        } else {
          this.url = new URL(`https://${this.config.host}`).toString();
        }
      }
      async transaction(fn) {
        const conn = new _Connection(this.config);
        const tx = new Tx(conn);
        try {
          await tx.execute("BEGIN");
          const res = await fn(tx);
          await tx.execute("COMMIT");
          return res;
        } catch (err) {
          await tx.execute("ROLLBACK");
          throw err;
        }
      }
      async refresh() {
        await this.createSession();
      }
      async execute(query, args = null, options2 = defaultExecuteOptions) {
        const url = new URL("/psdb.v1alpha1.Database/Execute", this.url);
        const formatter = this.config.format || format;
        const sql2 = args ? formatter(query, args) : query;
        const saved = await postJSON(this.config, url, { query: sql2, session: this.session });
        const { result, session: session2, error: error3, timing } = saved;
        if (session2) {
          this.session = session2;
        }
        if (error3) {
          throw new DatabaseError(error3.message, 400, error3);
        }
        const rowsAffected = result?.rowsAffected ? parseInt(result.rowsAffected, 10) : 0;
        const insertId = result?.insertId ?? "0";
        const fields = result?.fields ?? [];
        for (const field of fields) {
          field.type || (field.type = "NULL");
        }
        const castFn = options2.cast || this.config.cast || cast;
        const rows = result ? parse(result, castFn, options2.as || "object") : [];
        const headers = fields.map((f) => f.name);
        const typeByName = (acc, { name: name3, type }) => ({ ...acc, [name3]: type });
        const types = fields.reduce(typeByName, {});
        const timingSeconds = timing ?? 0;
        return {
          headers,
          types,
          fields,
          rows,
          rowsAffected,
          insertId,
          size: rows.length,
          statement: sql2,
          time: timingSeconds * 1e3
        };
      }
      async createSession() {
        const url = new URL("/psdb.v1alpha1.Database/CreateSession", this.url);
        const { session: session2 } = await postJSON(this.config, url);
        this.session = session2;
        return session2;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.28.6_@planetscale+database@1.11.0/node_modules/drizzle-orm/alias-cf8e03cd.mjs
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder2;
    if (is(field, Column)) {
      decoder2 = field;
    } else if (is(field, SQL)) {
      decoder2 = field.decoder;
    } else {
      decoder2 = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder2.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name3, field]) => {
    if (typeof name3 !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name3] : [name3];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key3, value]) => {
    if (is(value, SQL)) {
      return [key3, value];
    } else {
      return [key3, new Param(value, table[Table.Symbol.Columns][key3])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name3 of Object.getOwnPropertyNames(extendedClass.prototype)) {
      Object.defineProperty(baseClass.prototype, name3, Object.getOwnPropertyDescriptor(extendedClass.prototype, name3) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table[SubqueryConfig].alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function iife(fn, ...args) {
  return fn(...args);
}
function isTable(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
  return table[TableName];
}
function pgTableWithSchema(name3, columns, extraConfig, schema3, baseName = name3) {
  const rawTable = new PgTable(name3, schema3, baseName);
  const builtColumns = Object.fromEntries(Object.entries(columns).map(([name4, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name4, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
function uniqueKeyName(table, columns) {
  return `${table[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i2 = startFrom; i2 < arrayString.length; i2++) {
    const char = arrayString[i2];
    if (char === "\\") {
      i2++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i2 = startFrom;
  let lastCharIsComma = false;
  while (i2 < arrayString.length) {
    const char = arrayString[i2];
    if (char === ",") {
      if (lastCharIsComma || i2 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i2++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i2 += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i2 + 1, true);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i2 + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i2 + 1);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i2, false);
    result.push(value);
    i2 = newStartFrom;
  }
  return [result, i2];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array2) {
  return `{${array2.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string" && item.includes(",")) {
      return `"${item.replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema3, configHelpers) {
  if (Object.keys(schema3).length === 1 && "default" in schema3 && !is(schema3["default"], Table)) {
    schema3 = schema3["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key3, value] of Object.entries(schema3)) {
    if (isTable(value)) {
      const dbName = value[Table.Symbol.Name];
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key3;
      tablesConfig[key3] = {
        tsName: key3,
        dbName: value[Table.Symbol.Name],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key3].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key3].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = value.table[Table.Symbol.Name];
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table, relations2) {
  return new Relations(table, (helpers) => Object.fromEntries(Object.entries(relations2(helpers)).map(([key3, value]) => [
    key3,
    value.withFieldName(key3)
  ])));
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(sourceTable, table, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema3, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema3[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [selectionItemIndex, selectionItem] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder2;
      if (is(field, Column)) {
        decoder2 = field;
      } else if (is(field, SQL)) {
        decoder2 = field.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder2.mapFromDriverValue(value);
    }
  }
  return result;
}
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== void 0);
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== void 0);
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("inArray requires at least one value");
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("notInArray requires at least one value");
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists (${subquery})`;
}
function notExists(subquery) {
  return sql`not exists (${subquery})`;
}
function between(column, min2, max2) {
  return sql`${column} between ${bindIfParam(min2, column)} and ${bindIfParam(max2, column)}`;
}
function notBetween(column, min2, max2) {
  return sql`${column} not between ${bindIfParam(min2, column)} and ${bindIfParam(max2, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}
function isSQLWrapper(value) {
  return typeof value === "object" && value !== null && "getSQL" in value && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
function fillPlaceholders(params, values) {
  return params.map((p2) => {
    if (is(p2, Placeholder)) {
      if (!(p2.name in values)) {
        throw new Error(`No value for placeholder "${p2.name}" was provided`);
      }
      return values[p2.name];
    }
    return p2;
  });
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}
var entityKind, hasOwnEntityKind, _a, Column, ViewBaseConfig, _a2, _b, View, SubqueryConfig, _a3, _b2, Subquery, _a4, WithSubquery, _a5, _SelectionProxyHandler, SelectionProxyHandler, TableName, Schema, Columns, OriginalName, BaseName, IsAlias, ExtraConfigBuilder, IsDrizzleTable, _a6, _b3, _c, _d, _e, _f, _g, _h, _i, Table, _a7, _b4, QueryPromise, tracer, _a8, _DrizzleError, DrizzleError, _a9, TransactionRollbackError, InlineForeignKeys, _a10, _b5, _c2, PgTable, pgTable, _a11, CheckBuilder, _a12, Check, _a13, ForeignKeyBuilder, _a14, ForeignKey, _a15, IndexBuilderOn, _a16, IndexBuilder, _a17, Index, _a18, PrimaryKeyBuilder, _a19, PrimaryKey, _a20, UniqueConstraintBuilder, _a21, UniqueOnConstraintBuilder, _a22, UniqueConstraint, _a23, ColumnBuilder, _a24, PgColumnBuilder, _a25, PgColumn, _a26, PgArrayBuilder, _a27, _PgArray, PgArray, _a28, PgDateColumnBaseBuilder, _a29, PgDateBuilder, _a30, PgDate, _a31, PgDateStringBuilder, _a32, PgDateString, _a33, PgJsonBuilder, _a34, PgJson, _a35, PgJsonbBuilder, _a36, PgJsonb, _a37, PgNumericBuilder, _a38, PgNumeric, _a39, PgTimeBuilder, _a40, PgTime, _a41, PgTimestampBuilder, _a42, PgTimestamp, _a43, PgTimestampStringBuilder, _a44, PgTimestampString, _a45, PgUUIDBuilder, _a46, PgUUID, _a47, PgDialect, _a48, TypedQueryBuilder, _a49, PgSelectBuilder, _a50, PgSelectQueryBuilder, _a51, PgSelect, _a52, QueryBuilder, _a53, DefaultViewBuilderCore, _a54, ViewBuilder, _a55, ManualViewBuilder, _a56, MaterializedViewBuilderCore, _a57, MaterializedViewBuilder, _a58, ManualMaterializedViewBuilder, _a59, PgViewBase, PgViewConfig, _a60, _b6, PgView, PgMaterializedViewConfig, _a61, _b7, PgMaterializedView, _a62, Relation, _a63, Relations, _a64, _One, One, _a65, _Many, Many, eq, ne, gt, gte, lt, lte, _a66, FakePrimitiveParam, _a67, StringChunk, _a68, _SQL, SQL, _a69, Name, noopDecoder, noopEncoder, noopMapper, _a70, Param, _a71, Placeholder, _a72, ColumnAliasProxyHandler, _a73, TableAliasProxyHandler, _a74, RelationTableAliasProxyHandler;
var init_alias_cf8e03cd = __esm({
  "node_modules/.pnpm/drizzle-orm@0.28.6_@planetscale+database@1.11.0/node_modules/drizzle-orm/alias-cf8e03cd.mjs"() {
    entityKind = Symbol.for("drizzle:entityKind");
    hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
    Column = class {
      constructor(table, config) {
        __publicField(this, "table");
        __publicField(this, "name");
        __publicField(this, "primary");
        __publicField(this, "notNull");
        __publicField(this, "default");
        __publicField(this, "defaultFn");
        __publicField(this, "hasDefault");
        __publicField(this, "isUnique");
        __publicField(this, "uniqueName");
        __publicField(this, "uniqueType");
        __publicField(this, "dataType");
        __publicField(this, "columnType");
        __publicField(this, "enumValues");
        __publicField(this, "config");
        this.table = table;
        this.config = config;
        this.name = config.name;
        this.notNull = config.notNull;
        this.default = config.default;
        this.defaultFn = config.defaultFn;
        this.hasDefault = config.hasDefault;
        this.primary = config.primaryKey;
        this.isUnique = config.isUnique;
        this.uniqueName = config.uniqueName;
        this.uniqueType = config.uniqueType;
        this.dataType = config.dataType;
        this.columnType = config.columnType;
      }
      mapFromDriverValue(value) {
        return value;
      }
      mapToDriverValue(value) {
        return value;
      }
    };
    _a = entityKind;
    __publicField(Column, _a, "Column");
    ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");
    View = class {
      constructor({ name: name3, schema: schema3, selectedFields, query }) {
        /** @internal */
        __publicField(this, _b);
        this[ViewBaseConfig] = {
          name: name3,
          originalName: name3,
          schema: schema3,
          selectedFields,
          query,
          isExisting: !query,
          isAlias: false
        };
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    _a2 = entityKind, _b = ViewBaseConfig;
    __publicField(View, _a2, "View");
    SubqueryConfig = Symbol.for("drizzle:SubqueryConfig");
    Subquery = class {
      constructor(sql2, selection, alias, isWith = false) {
        /** @internal */
        __publicField(this, _b2);
        this[SubqueryConfig] = {
          sql: sql2,
          selection,
          alias,
          isWith
        };
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    _a3 = entityKind, _b2 = SubqueryConfig;
    __publicField(Subquery, _a3, "Subquery");
    WithSubquery = class extends Subquery {
    };
    _a4 = entityKind;
    __publicField(WithSubquery, _a4, "WithSubquery");
    _SelectionProxyHandler = class _SelectionProxyHandler {
      constructor(config) {
        __publicField(this, "config");
        this.config = { ...config };
      }
      get(subquery, prop) {
        if (prop === SubqueryConfig) {
          return {
            ...subquery[SubqueryConfig],
            selection: new Proxy(subquery[SubqueryConfig].selection, this)
          };
        }
        if (prop === ViewBaseConfig) {
          return {
            ...subquery[ViewBaseConfig],
            selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
          };
        }
        if (typeof prop === "symbol") {
          return subquery[prop];
        }
        const columns = is(subquery, Subquery) ? subquery[SubqueryConfig].selection : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
        const value = columns[prop];
        if (is(value, SQL.Aliased)) {
          if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
            return value.sql;
          }
          const newValue = value.clone();
          newValue.isSelectionField = true;
          return newValue;
        }
        if (is(value, SQL)) {
          if (this.config.sqlBehavior === "sql") {
            return value;
          }
          throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
        }
        if (is(value, Column)) {
          if (this.config.alias) {
            return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
          }
          return value;
        }
        if (typeof value !== "object" || value === null) {
          return value;
        }
        return new Proxy(value, new _SelectionProxyHandler(this.config));
      }
    };
    _a5 = entityKind;
    __publicField(_SelectionProxyHandler, _a5, "SelectionProxyHandler");
    SelectionProxyHandler = _SelectionProxyHandler;
    TableName = Symbol.for("drizzle:Name");
    Schema = Symbol.for("drizzle:Schema");
    Columns = Symbol.for("drizzle:Columns");
    OriginalName = Symbol.for("drizzle:OriginalName");
    BaseName = Symbol.for("drizzle:BaseName");
    IsAlias = Symbol.for("drizzle:IsAlias");
    ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
    IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
    Table = class {
      constructor(name3, schema3, baseName) {
        /**
         * @internal
         * Can be changed if the table is aliased.
         */
        __publicField(this, _b3);
        /**
         * @internal
         * Used to store the original name of the table, before any aliasing.
         */
        __publicField(this, _c);
        /** @internal */
        __publicField(this, _d);
        /** @internal */
        __publicField(this, _e);
        /**
         *  @internal
         * Used to store the table name before the transformation via the `tableCreator` functions.
         */
        __publicField(this, _f);
        /** @internal */
        __publicField(this, _g, false);
        /** @internal */
        __publicField(this, _h);
        __publicField(this, _i, true);
        this[TableName] = this[OriginalName] = name3;
        this[Schema] = schema3;
        this[BaseName] = baseName;
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    _a6 = entityKind, _b3 = TableName, _c = OriginalName, _d = Schema, _e = Columns, _f = BaseName, _g = IsAlias, _h = ExtraConfigBuilder, _i = IsDrizzleTable;
    __publicField(Table, _a6, "Table");
    /** @internal */
    __publicField(Table, "Symbol", {
      Name: TableName,
      Schema,
      OriginalName,
      Columns,
      BaseName,
      IsAlias,
      ExtraConfigBuilder
    });
    QueryPromise = class {
      constructor() {
        __publicField(this, _b4, "QueryPromise");
      }
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then((value) => {
          onFinally?.();
          return value;
        }, (reason) => {
          onFinally?.();
          throw reason;
        });
      }
      then(onFulfilled, onRejected) {
        return this.execute().then(onFulfilled, onRejected);
      }
    };
    _a7 = entityKind, _b4 = Symbol.toStringTag;
    __publicField(QueryPromise, _a7, "QueryPromise");
    tracer = {
      startActiveSpan(name3, fn) {
        {
          return fn();
        }
      }
    };
    _DrizzleError = class _DrizzleError extends Error {
      constructor(message) {
        super(message);
        this.name = "DrizzleError";
      }
      static wrap(error3, message) {
        return error3 instanceof Error ? new _DrizzleError(message ? `${message}: ${error3.message}` : error3.message) : new _DrizzleError(message ?? String(error3));
      }
    };
    _a8 = entityKind;
    __publicField(_DrizzleError, _a8, "DrizzleError");
    DrizzleError = _DrizzleError;
    TransactionRollbackError = class extends DrizzleError {
      constructor() {
        super("Rollback");
      }
    };
    _a9 = entityKind;
    __publicField(TransactionRollbackError, _a9, "TransactionRollbackError");
    InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
    PgTable = class extends Table {
      constructor() {
        super(...arguments);
        /**@internal */
        __publicField(this, _b5, []);
        /** @internal */
        __publicField(this, _c2);
      }
    };
    _a10 = entityKind, _b5 = InlineForeignKeys, _c2 = Table.Symbol.ExtraConfigBuilder;
    __publicField(PgTable, _a10, "PgTable");
    /** @internal */
    __publicField(PgTable, "Symbol", Object.assign({}, Table.Symbol, {
      InlineForeignKeys
    }));
    pgTable = (name3, columns, extraConfig) => {
      return pgTableWithSchema(name3, columns, extraConfig, void 0);
    };
    CheckBuilder = class {
      constructor(name3, value) {
        __publicField(this, "name");
        __publicField(this, "value");
        __publicField(this, "brand");
        this.name = name3;
        this.value = value;
      }
      /** @internal */
      build(table) {
        return new Check(table, this);
      }
    };
    _a11 = entityKind;
    __publicField(CheckBuilder, _a11, "PgCheckBuilder");
    Check = class {
      constructor(table, builder2) {
        __publicField(this, "table");
        __publicField(this, "name");
        __publicField(this, "value");
        this.table = table;
        this.name = builder2.name;
        this.value = builder2.value;
      }
    };
    _a12 = entityKind;
    __publicField(Check, _a12, "PgCheck");
    ForeignKeyBuilder = class {
      constructor(config, actions4) {
        /** @internal */
        __publicField(this, "reference");
        /** @internal */
        __publicField(this, "_onUpdate", "no action");
        /** @internal */
        __publicField(this, "_onDelete", "no action");
        this.reference = () => {
          const { columns, foreignColumns } = config();
          return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions4) {
          this._onUpdate = actions4.onUpdate;
          this._onDelete = actions4.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action === void 0 ? "no action" : action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action === void 0 ? "no action" : action;
        return this;
      }
      /** @internal */
      build(table) {
        return new ForeignKey(table, this);
      }
    };
    _a13 = entityKind;
    __publicField(ForeignKeyBuilder, _a13, "PgForeignKeyBuilder");
    ForeignKey = class {
      constructor(table, builder2) {
        __publicField(this, "table");
        __publicField(this, "reference");
        __publicField(this, "onUpdate");
        __publicField(this, "onDelete");
        this.table = table;
        this.reference = builder2.reference;
        this.onUpdate = builder2._onUpdate;
        this.onDelete = builder2._onDelete;
      }
      getName() {
        const { columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[PgTable.Symbol.Name],
          ...columnNames,
          foreignColumns[0].table[PgTable.Symbol.Name],
          ...foreignColumnNames
        ];
        return `${chunks.join("_")}_fk`;
      }
    };
    _a14 = entityKind;
    __publicField(ForeignKey, _a14, "PgForeignKey");
    IndexBuilderOn = class {
      constructor(unique2, name3) {
        __publicField(this, "unique");
        __publicField(this, "name");
        this.unique = unique2;
        this.name = name3;
      }
      on(...columns) {
        return new IndexBuilder(columns, this.unique, false, this.name);
      }
      onOnly(...columns) {
        return new IndexBuilder(columns, this.unique, true, this.name);
      }
    };
    _a15 = entityKind;
    __publicField(IndexBuilderOn, _a15, "PgIndexBuilderOn");
    IndexBuilder = class {
      constructor(columns, unique2, only, name3) {
        /** @internal */
        __publicField(this, "config");
        this.config = {
          name: name3,
          columns,
          unique: unique2,
          only
        };
      }
      concurrently() {
        this.config.concurrently = true;
        return this;
      }
      using(method) {
        this.config.using = method;
        return this;
      }
      asc() {
        this.config.order = "asc";
        return this;
      }
      desc() {
        this.config.order = "desc";
        return this;
      }
      nullsFirst() {
        this.config.nulls = "first";
        return this;
      }
      nullsLast() {
        this.config.nulls = "last";
        return this;
      }
      where(condition) {
        this.config.where = condition;
        return this;
      }
      /** @internal */
      build(table) {
        return new Index(this.config, table);
      }
    };
    _a16 = entityKind;
    __publicField(IndexBuilder, _a16, "PgIndexBuilder");
    Index = class {
      constructor(config, table) {
        __publicField(this, "config");
        this.config = { ...config, table };
      }
    };
    _a17 = entityKind;
    __publicField(Index, _a17, "PgIndex");
    PrimaryKeyBuilder = class {
      constructor(columns) {
        /** @internal */
        __publicField(this, "columns");
        this.columns = columns;
      }
      /** @internal */
      build(table) {
        return new PrimaryKey(table, this.columns);
      }
    };
    _a18 = entityKind;
    __publicField(PrimaryKeyBuilder, _a18, "PgPrimaryKeyBuilder");
    PrimaryKey = class {
      constructor(table, columns) {
        __publicField(this, "table");
        __publicField(this, "columns");
        this.table = table;
        this.columns = columns;
      }
      getName() {
        return `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    };
    _a19 = entityKind;
    __publicField(PrimaryKey, _a19, "PgPrimaryKey");
    UniqueConstraintBuilder = class {
      constructor(columns, name3) {
        __publicField(this, "name");
        /** @internal */
        __publicField(this, "columns");
        /** @internal */
        __publicField(this, "nullsNotDistinctConfig", false);
        this.name = name3;
        this.columns = columns;
      }
      nullsNotDistinct() {
        this.nullsNotDistinctConfig = true;
        return this;
      }
      /** @internal */
      build(table) {
        return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
      }
    };
    _a20 = entityKind;
    __publicField(UniqueConstraintBuilder, _a20, "PgUniqueConstraintBuilder");
    UniqueOnConstraintBuilder = class {
      constructor(name3) {
        /** @internal */
        __publicField(this, "name");
        this.name = name3;
      }
      on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
      }
    };
    _a21 = entityKind;
    __publicField(UniqueOnConstraintBuilder, _a21, "PgUniqueOnConstraintBuilder");
    UniqueConstraint = class {
      constructor(table, columns, nullsNotDistinct, name3) {
        __publicField(this, "table");
        __publicField(this, "columns");
        __publicField(this, "name");
        __publicField(this, "nullsNotDistinct", false);
        this.table = table;
        this.columns = columns;
        this.name = name3 ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
        this.nullsNotDistinct = nullsNotDistinct;
      }
      getName() {
        return this.name;
      }
    };
    _a22 = entityKind;
    __publicField(UniqueConstraint, _a22, "PgUniqueConstraint");
    ColumnBuilder = class {
      constructor(name3, dataType, columnType) {
        __publicField(this, "config");
        /**
         * Alias for {@link $defaultFn}.
         */
        __publicField(this, "$default", this.$defaultFn);
        this.config = {
          name: name3,
          notNull: false,
          default: void 0,
          hasDefault: false,
          primaryKey: false,
          isUnique: false,
          uniqueName: void 0,
          uniqueType: void 0,
          dataType,
          columnType
        };
      }
      /**
       * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
       *
       * @example
       * ```ts
       * const users = pgTable('users', {
       * 	id: integer('id').$type<UserId>().primaryKey(),
       * 	details: json('details').$type<UserDetails>().notNull(),
       * });
       * ```
       */
      $type() {
        return this;
      }
      /**
       * Adds a `not null` clause to the column definition.
       *
       * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
       */
      notNull() {
        this.config.notNull = true;
        return this;
      }
      /**
       * Adds a `default <value>` clause to the column definition.
       *
       * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
       *
       * If you need to set a dynamic default value, use {@link $defaultFn} instead.
       */
      default(value) {
        this.config.default = value;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Adds a dynamic default value to the column.
       * The function will be called when the row is inserted, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $defaultFn(fn) {
        this.config.defaultFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
       *
       * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
       */
      primaryKey() {
        this.config.primaryKey = true;
        this.config.notNull = true;
        return this;
      }
    };
    _a23 = entityKind;
    __publicField(ColumnBuilder, _a23, "ColumnBuilder");
    PgColumnBuilder = class extends ColumnBuilder {
      constructor() {
        super(...arguments);
        __publicField(this, "foreignKeyConfigs", []);
      }
      array(size2) {
        return new PgArrayBuilder(this.config.name, this, size2);
      }
      references(ref, actions4 = {}) {
        this.foreignKeyConfigs.push({ ref, actions: actions4 });
        return this;
      }
      unique(name3, config) {
        this.config.isUnique = true;
        this.config.uniqueName = name3;
        this.config.uniqueType = config?.nulls;
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions: actions4 }) => {
          return iife((ref2, actions5) => {
            const builder2 = new ForeignKeyBuilder(() => {
              const foreignColumn = ref2();
              return { columns: [column], foreignColumns: [foreignColumn] };
            });
            if (actions5.onUpdate) {
              builder2.onUpdate(actions5.onUpdate);
            }
            if (actions5.onDelete) {
              builder2.onDelete(actions5.onDelete);
            }
            return builder2.build(table);
          }, ref, actions4);
        });
      }
    };
    _a24 = entityKind;
    __publicField(PgColumnBuilder, _a24, "PgColumnBuilder");
    PgColumn = class extends Column {
      constructor(table, config) {
        if (!config.uniqueName) {
          config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        __publicField(this, "table");
        this.table = table;
      }
    };
    _a25 = entityKind;
    __publicField(PgColumn, _a25, "PgColumn");
    PgArrayBuilder = class extends PgColumnBuilder {
      constructor(name3, baseBuilder, size2) {
        super(name3, "array", "PgArray");
        this.config.baseBuilder = baseBuilder;
        this.config.size = size2;
      }
      /** @internal */
      build(table) {
        const baseColumn = this.config.baseBuilder.build(table);
        return new PgArray(table, this.config, baseColumn);
      }
    };
    _a26 = entityKind;
    __publicField(PgArrayBuilder, _a26, "PgArrayBuilder");
    _PgArray = class _PgArray extends PgColumn {
      constructor(table, config, baseColumn, range) {
        super(table, config);
        __publicField(this, "baseColumn");
        __publicField(this, "range");
        __publicField(this, "size");
        this.baseColumn = baseColumn;
        this.range = range;
        this.size = config.size;
      }
      getSQLType() {
        return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          value = parsePgArray(value);
        }
        return value.map((v) => this.baseColumn.mapFromDriverValue(v));
      }
      mapToDriverValue(value, isNestedArray = false) {
        const a2 = value.map((v) => v === null ? null : is(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v));
        if (isNestedArray)
          return a2;
        return makePgArray(a2);
      }
    };
    _a27 = entityKind;
    __publicField(_PgArray, _a27, "PgArray");
    PgArray = _PgArray;
    PgDateColumnBaseBuilder = class extends PgColumnBuilder {
      defaultNow() {
        return this.default(sql`now()`);
      }
    };
    _a28 = entityKind;
    __publicField(PgDateColumnBaseBuilder, _a28, "PgDateColumnBaseBuilder");
    PgDateBuilder = class extends PgDateColumnBaseBuilder {
      constructor(name3) {
        super(name3, "date", "PgDate");
      }
      /** @internal */
      build(table) {
        return new PgDate(table, this.config);
      }
    };
    _a29 = entityKind;
    __publicField(PgDateBuilder, _a29, "PgDateBuilder");
    PgDate = class extends PgColumn {
      getSQLType() {
        return "date";
      }
      mapFromDriverValue(value) {
        return new Date(value);
      }
      mapToDriverValue(value) {
        return value.toISOString();
      }
    };
    _a30 = entityKind;
    __publicField(PgDate, _a30, "PgDate");
    PgDateStringBuilder = class extends PgDateColumnBaseBuilder {
      constructor(name3) {
        super(name3, "string", "PgDateString");
      }
      /** @internal */
      build(table) {
        return new PgDateString(table, this.config);
      }
    };
    _a31 = entityKind;
    __publicField(PgDateStringBuilder, _a31, "PgDateStringBuilder");
    PgDateString = class extends PgColumn {
      getSQLType() {
        return "date";
      }
    };
    _a32 = entityKind;
    __publicField(PgDateString, _a32, "PgDateString");
    PgJsonBuilder = class extends PgColumnBuilder {
      constructor(name3) {
        super(name3, "json", "PgJson");
      }
      /** @internal */
      build(table) {
        return new PgJson(table, this.config);
      }
    };
    _a33 = entityKind;
    __publicField(PgJsonBuilder, _a33, "PgJsonBuilder");
    PgJson = class extends PgColumn {
      constructor(table, config) {
        super(table, config);
      }
      getSQLType() {
        return "json";
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          try {
            return JSON.parse(value);
          } catch {
            return value;
          }
        }
        return value;
      }
    };
    _a34 = entityKind;
    __publicField(PgJson, _a34, "PgJson");
    PgJsonbBuilder = class extends PgColumnBuilder {
      constructor(name3) {
        super(name3, "json", "PgJsonb");
      }
      /** @internal */
      build(table) {
        return new PgJsonb(table, this.config);
      }
    };
    _a35 = entityKind;
    __publicField(PgJsonbBuilder, _a35, "PgJsonbBuilder");
    PgJsonb = class extends PgColumn {
      constructor(table, config) {
        super(table, config);
      }
      getSQLType() {
        return "jsonb";
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          try {
            return JSON.parse(value);
          } catch {
            return value;
          }
        }
        return value;
      }
    };
    _a36 = entityKind;
    __publicField(PgJsonb, _a36, "PgJsonb");
    PgNumericBuilder = class extends PgColumnBuilder {
      constructor(name3, precision, scale) {
        super(name3, "string", "PgNumeric");
        this.config.precision = precision;
        this.config.scale = scale;
      }
      /** @internal */
      build(table) {
        return new PgNumeric(table, this.config);
      }
    };
    _a37 = entityKind;
    __publicField(PgNumericBuilder, _a37, "PgNumericBuilder");
    PgNumeric = class extends PgColumn {
      constructor(table, config) {
        super(table, config);
        __publicField(this, "precision");
        __publicField(this, "scale");
        this.precision = config.precision;
        this.scale = config.scale;
      }
      getSQLType() {
        if (this.precision !== void 0 && this.scale !== void 0) {
          return `numeric(${this.precision}, ${this.scale})`;
        } else if (this.precision === void 0) {
          return "numeric";
        } else {
          return `numeric(${this.precision})`;
        }
      }
    };
    _a38 = entityKind;
    __publicField(PgNumeric, _a38, "PgNumeric");
    PgTimeBuilder = class extends PgDateColumnBaseBuilder {
      constructor(name3, withTimezone, precision) {
        super(name3, "string", "PgTime");
        __publicField(this, "withTimezone");
        __publicField(this, "precision");
        this.withTimezone = withTimezone;
        this.precision = precision;
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
      }
      /** @internal */
      build(table) {
        return new PgTime(table, this.config);
      }
    };
    _a39 = entityKind;
    __publicField(PgTimeBuilder, _a39, "PgTimeBuilder");
    PgTime = class extends PgColumn {
      constructor(table, config) {
        super(table, config);
        __publicField(this, "withTimezone");
        __publicField(this, "precision");
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
      }
      getSQLType() {
        const precision = this.precision === void 0 ? "" : `(${this.precision})`;
        return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
      }
    };
    _a40 = entityKind;
    __publicField(PgTime, _a40, "PgTime");
    PgTimestampBuilder = class extends PgDateColumnBaseBuilder {
      constructor(name3, withTimezone, precision) {
        super(name3, "date", "PgTimestamp");
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
      }
      /** @internal */
      build(table) {
        return new PgTimestamp(table, this.config);
      }
    };
    _a41 = entityKind;
    __publicField(PgTimestampBuilder, _a41, "PgTimestampBuilder");
    PgTimestamp = class extends PgColumn {
      constructor(table, config) {
        super(table, config);
        __publicField(this, "withTimezone");
        __publicField(this, "precision");
        __publicField(this, "mapFromDriverValue", (value) => {
          return new Date(this.withTimezone ? value : value + "+0000");
        });
        __publicField(this, "mapToDriverValue", (value) => {
          return this.withTimezone ? value.toUTCString() : value.toISOString();
        });
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
      }
      getSQLType() {
        const precision = this.precision === void 0 ? "" : ` (${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
      }
    };
    _a42 = entityKind;
    __publicField(PgTimestamp, _a42, "PgTimestamp");
    PgTimestampStringBuilder = class extends PgDateColumnBaseBuilder {
      constructor(name3, withTimezone, precision) {
        super(name3, "string", "PgTimestampString");
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
      }
      /** @internal */
      build(table) {
        return new PgTimestampString(table, this.config);
      }
    };
    _a43 = entityKind;
    __publicField(PgTimestampStringBuilder, _a43, "PgTimestampStringBuilder");
    PgTimestampString = class extends PgColumn {
      constructor(table, config) {
        super(table, config);
        __publicField(this, "withTimezone");
        __publicField(this, "precision");
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
      }
      getSQLType() {
        const precision = this.precision === void 0 ? "" : `(${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
      }
    };
    _a44 = entityKind;
    __publicField(PgTimestampString, _a44, "PgTimestampString");
    PgUUIDBuilder = class extends PgColumnBuilder {
      constructor(name3) {
        super(name3, "string", "PgUUID");
      }
      /**
       * Adds `default gen_random_uuid()` to the column definition.
       */
      defaultRandom() {
        return this.default(sql`gen_random_uuid()`);
      }
      /** @internal */
      build(table) {
        return new PgUUID(table, this.config);
      }
    };
    _a45 = entityKind;
    __publicField(PgUUIDBuilder, _a45, "PgUUIDBuilder");
    PgUUID = class extends PgColumn {
      getSQLType() {
        return "uuid";
      }
    };
    _a46 = entityKind;
    __publicField(PgUUID, _a46, "PgUUID");
    PgDialect = class {
      async migrate(migrations, session2) {
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
        await session2.execute(sql`CREATE SCHEMA IF NOT EXISTS "drizzle"`);
        await session2.execute(migrationTableCreate);
        const dbMigrations = await session2.all(sql`select id, hash, created_at from "drizzle"."__drizzle_migrations" order by created_at desc limit 1`);
        const lastDbMigration = dbMigrations[0];
        await session2.transaction(async (tx) => {
          for await (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                await tx.execute(sql.raw(stmt));
              }
              await tx.execute(sql`insert into "drizzle"."__drizzle_migrations" ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
            }
          }
        });
      }
      escapeName(name3) {
        return `"${name3}"`;
      }
      escapeParam(num) {
        return `$${num + 1}`;
      }
      escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
      }
      buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`delete from ${table}${whereSql}${returningSql}`;
      }
      buildUpdateSet(table, set2) {
        const setEntries = Object.entries(set2);
        const setSize = setEntries.length;
        return sql.join(setEntries.flatMap(([colName, value], i2) => {
          const col = table[Table.Symbol.Columns][colName];
          const res = sql`${sql.identifier(col.name)} = ${value}`;
          if (i2 < setSize - 1) {
            return [res, sql.raw(", ")];
          }
          return [res];
        }));
      }
      buildUpdateQuery({ table, set: set2, where, returning }) {
        const setSql = this.buildUpdateSet(table, set2);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`update ${table} set ${setSql}${whereSql}${returningSql}`;
      }
      /**
       * Builds selection SQL with provided fields/expressions
       *
       * Examples:
       *
       * `select <selection> from`
       *
       * `insert ... returning <selection>`
       *
       * If `isSingleTable` is true, then columns won't be prefixed with table name
       */
      buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields.flatMap(({ field }, i2) => {
          const chunk = [];
          if (is(field, SQL.Aliased) && field.isSelectionField) {
            chunk.push(sql.identifier(field.fieldAlias));
          } else if (is(field, SQL.Aliased) || is(field, SQL)) {
            const query = is(field, SQL.Aliased) ? field.sql : field;
            if (isSingleTable) {
              chunk.push(new SQL(query.queryChunks.map((c) => {
                if (is(c, PgColumn)) {
                  return sql.identifier(c.name);
                }
                return c;
              })));
            } else {
              chunk.push(query);
            }
            if (is(field, SQL.Aliased)) {
              chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
            }
          } else if (is(field, Column)) {
            if (isSingleTable) {
              chunk.push(sql.identifier(field.name));
            } else {
              chunk.push(field);
            }
          }
          if (i2 < columnsLen - 1) {
            chunk.push(sql`, `);
          }
          return chunk;
        });
        return sql.join(chunks);
      }
      buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset: offset2, lockingClauses, distinct }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
          if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table[SubqueryConfig].alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
            const tableName = getTableName(f.field.table);
            throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
          }
        }
        const isSingleTable = !joins || joins.length === 0;
        let withSql;
        if (withList?.length) {
          const withSqlChunks = [sql`with `];
          for (const [i2, w] of withList.entries()) {
            withSqlChunks.push(sql`${sql.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
            if (i2 < withList.length - 1) {
              withSqlChunks.push(sql`, `);
            }
          }
          withSqlChunks.push(sql` `);
          withSql = sql.join(withSqlChunks);
        }
        let distinctSql;
        if (distinct) {
          distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, ", ")})`;
        }
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
          if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
            let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
            if (table[Table.Symbol.Schema]) {
              fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
            }
            return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
          }
          return table;
        })();
        const joinsArray = [];
        if (joins) {
          for (const [index8, joinMeta] of joins.entries()) {
            if (index8 === 0) {
              joinsArray.push(sql` `);
            }
            const table2 = joinMeta.table;
            const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
            if (is(table2, PgTable)) {
              const tableName = table2[PgTable.Symbol.Name];
              const tableSchema = table2[PgTable.Symbol.Schema];
              const origTableName = table2[PgTable.Symbol.OriginalName];
              const alias = tableName === origTableName ? void 0 : joinMeta.alias;
              joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
            } else if (is(table2, View)) {
              const viewName = table2[ViewBaseConfig].name;
              const viewSchema = table2[ViewBaseConfig].schema;
              const origViewName = table2[ViewBaseConfig].originalName;
              const alias = viewName === origViewName ? void 0 : joinMeta.alias;
              joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
            } else {
              joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table2} on ${joinMeta.on}`);
            }
            if (index8 < joins.length - 1) {
              joinsArray.push(sql` `);
            }
          }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql` where ${where}` : void 0;
        const havingSql = having ? sql` having ${having}` : void 0;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
        }
        let groupBySql;
        if (groupBy && groupBy.length > 0) {
          groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
        }
        const limitSql = limit ? sql` limit ${limit}` : void 0;
        const offsetSql = offset2 ? sql` offset ${offset2}` : void 0;
        const lockingClausesSql = sql.empty();
        if (lockingClauses) {
          for (const { strength, config } of lockingClauses) {
            const clauseSql = sql` for ${sql.raw(strength)}`;
            if (config.of) {
              clauseSql.append(sql` of ${config.of}`);
            }
            if (config.noWait) {
              clauseSql.append(sql` no wait`);
            } else if (config.skipLocked) {
              clauseSql.append(sql` skip locked`);
            }
            lockingClausesSql.append(clauseSql);
          }
        }
        return sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClausesSql}`;
      }
      buildInsertQuery({ table, values, onConflict, returning }) {
        const valuesSqlList = [];
        const columns = table[Table.Symbol.Columns];
        const colEntries = Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
          const valueList = [];
          for (const [fieldName, col] of colEntries) {
            const colValue = value[fieldName];
            if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
              if (col.defaultFn !== void 0) {
                const defaultFnResult = col.defaultFn();
                const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                valueList.push(defaultValue);
              } else {
                valueList.push(sql`default`);
              }
            } else {
              valueList.push(colValue);
            }
          }
          valuesSqlList.push(valueList);
          if (valueIndex < values.length - 1) {
            valuesSqlList.push(sql`, `);
          }
        }
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
        return sql`insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
      }
      buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
        const concurrentlySql = concurrently ? sql` concurrently` : void 0;
        const withNoDataSql = withNoData ? sql` with no data` : void 0;
        return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
      }
      prepareTyping(encoder3) {
        if (is(encoder3, PgJsonb) || is(encoder3, PgJson)) {
          return "json";
        } else if (is(encoder3, PgNumeric)) {
          return "decimal";
        } else if (is(encoder3, PgTime)) {
          return "time";
        } else if (is(encoder3, PgTimestamp)) {
          return "timestamp";
        } else if (is(encoder3, PgDate)) {
          return "date";
        } else if (is(encoder3, PgUUID)) {
          return "uuid";
        } else {
          return "none";
        }
      }
      sqlToQuery(sql2) {
        return sql2.toQuery({
          escapeName: this.escapeName,
          escapeParam: this.escapeParam,
          escapeString: this.escapeString,
          prepareTyping: this.prepareTyping
        });
      }
      // buildRelationalQueryWithPK({
      // 	fullSchema,
      // 	schema,
      // 	tableNamesMap,
      // 	table,
      // 	tableConfig,
      // 	queryConfig: config,
      // 	tableAlias,
      // 	isRoot = false,
      // 	joinOn,
      // }: {
      // 	fullSchema: Record<string, unknown>;
      // 	schema: TablesRelationalConfig;
      // 	tableNamesMap: Record<string, string>;
      // 	table: PgTable;
      // 	tableConfig: TableRelationalConfig;
      // 	queryConfig: true | DBQueryConfig<'many', true>;
      // 	tableAlias: string;
      // 	isRoot?: boolean;
      // 	joinOn?: SQL;
      // }): BuildRelationalQueryResult<PgTable, PgColumn> {
      // 	// For { "<relation>": true }, return a table with selection of all columns
      // 	if (config === true) {
      // 		const selectionEntries = Object.entries(tableConfig.columns);
      // 		const selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((
      // 			[key, value],
      // 		) => ({
      // 			dbKey: value.name,
      // 			tsKey: key,
      // 			field: value as PgColumn,
      // 			relationTableTsKey: undefined,
      // 			isJson: false,
      // 			selection: [],
      // 		}));
      // 		return {
      // 			tableTsKey: tableConfig.tsName,
      // 			sql: table,
      // 			selection,
      // 		};
      // 	}
      // 	// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
      // 	// let selectionForBuild = selection;
      // 	const aliasedColumns = Object.fromEntries(
      // 		Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),
      // 	);
      // 	const aliasedRelations = Object.fromEntries(
      // 		Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),
      // 	);
      // 	const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
      // 	let where, hasUserDefinedWhere;
      // 	if (config.where) {
      // 		const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
      // 		where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      // 		hasUserDefinedWhere = !!where;
      // 	}
      // 	where = and(joinOn, where);
      // 	// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];
      // 	let joins: Join[] = [];
      // 	let selectedColumns: string[] = [];
      // 	// Figure out which columns to select
      // 	if (config.columns) {
      // 		let isIncludeMode = false;
      // 		for (const [field, value] of Object.entries(config.columns)) {
      // 			if (value === undefined) {
      // 				continue;
      // 			}
      // 			if (field in tableConfig.columns) {
      // 				if (!isIncludeMode && value === true) {
      // 					isIncludeMode = true;
      // 				}
      // 				selectedColumns.push(field);
      // 			}
      // 		}
      // 		if (selectedColumns.length > 0) {
      // 			selectedColumns = isIncludeMode
      // 				? selectedColumns.filter((c) => config.columns?.[c] === true)
      // 				: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
      // 		}
      // 	} else {
      // 		// Select all columns if selection is not specified
      // 		selectedColumns = Object.keys(tableConfig.columns);
      // 	}
      // 	// for (const field of selectedColumns) {
      // 	// 	const column = tableConfig.columns[field]! as PgColumn;
      // 	// 	fieldsSelection.push({ tsKey: field, value: column });
      // 	// }
      // 	let initiallySelectedRelations: {
      // 		tsKey: string;
      // 		queryConfig: true | DBQueryConfig<'many', false>;
      // 		relation: Relation;
      // 	}[] = [];
      // 	// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
      // 	// Figure out which relations to select
      // 	if (config.with) {
      // 		initiallySelectedRelations = Object.entries(config.with)
      // 			.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])
      // 			.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));
      // 	}
      // 	const manyRelations = initiallySelectedRelations.filter((r) =>
      // 		is(r.relation, Many)
      // 		&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0
      // 	);
      // 	// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level
      // 	const isInnermostQuery = manyRelations.length < 2;
      // 	const selectedExtras: {
      // 		tsKey: string;
      // 		value: SQL.Aliased;
      // 	}[] = [];
      // 	// Figure out which extras to select
      // 	if (isInnermostQuery && config.extras) {
      // 		const extras = typeof config.extras === 'function'
      // 			? config.extras(aliasedFields, { sql })
      // 			: config.extras;
      // 		for (const [tsKey, value] of Object.entries(extras)) {
      // 			selectedExtras.push({
      // 				tsKey,
      // 				value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
      // 			});
      // 		}
      // 	}
      // 	// Transform `fieldsSelection` into `selection`
      // 	// `fieldsSelection` shouldn't be used after this point
      // 	// for (const { tsKey, value, isExtra } of fieldsSelection) {
      // 	// 	selection.push({
      // 	// 		dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,
      // 	// 		tsKey,
      // 	// 		field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
      // 	// 		relationTableTsKey: undefined,
      // 	// 		isJson: false,
      // 	// 		isExtra,
      // 	// 		selection: [],
      // 	// 	});
      // 	// }
      // 	let orderByOrig = typeof config.orderBy === 'function'
      // 		? config.orderBy(aliasedFields, orderByOperators)
      // 		: config.orderBy ?? [];
      // 	if (!Array.isArray(orderByOrig)) {
      // 		orderByOrig = [orderByOrig];
      // 	}
      // 	const orderBy = orderByOrig.map((orderByValue) => {
      // 		if (is(orderByValue, Column)) {
      // 			return aliasedTableColumn(orderByValue, tableAlias) as PgColumn;
      // 		}
      // 		return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      // 	});
      // 	const limit = isInnermostQuery ? config.limit : undefined;
      // 	const offset = isInnermostQuery ? config.offset : undefined;
      // 	// For non-root queries without additional config except columns, return a table with selection
      // 	if (
      // 		!isRoot
      // 		&& initiallySelectedRelations.length === 0
      // 		&& selectedExtras.length === 0
      // 		&& !where
      // 		&& orderBy.length === 0
      // 		&& limit === undefined
      // 		&& offset === undefined
      // 	) {
      // 		return {
      // 			tableTsKey: tableConfig.tsName,
      // 			sql: table,
      // 			selection: selectedColumns.map((key) => ({
      // 				dbKey: tableConfig.columns[key]!.name,
      // 				tsKey: key,
      // 				field: tableConfig.columns[key] as PgColumn,
      // 				relationTableTsKey: undefined,
      // 				isJson: false,
      // 				selection: [],
      // 			})),
      // 		};
      // 	}
      // 	const selectedRelationsWithoutPK:
      // 	// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level
      // 	for (
      // 		const {
      // 			tsKey: selectedRelationTsKey,
      // 			queryConfig: selectedRelationConfigValue,
      // 			relation,
      // 		} of initiallySelectedRelations
      // 	) {
      // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
      // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
      // 		const relationTableTsName = tableNamesMap[relationTableName]!;
      // 		const relationTable = schema[relationTableTsName]!;
      // 		if (relationTable.primaryKey.length > 0) {
      // 			continue;
      // 		}
      // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
      // 		const joinOn = and(
      // 			...normalizedRelation.fields.map((field, i) =>
      // 				eq(
      // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
      // 					aliasedTableColumn(field, tableAlias),
      // 				)
      // 			),
      // 		);
      // 		const builtRelation = this.buildRelationalQueryWithoutPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table: fullSchema[relationTableTsName] as PgTable,
      // 			tableConfig: schema[relationTableTsName]!,
      // 			queryConfig: selectedRelationConfigValue,
      // 			tableAlias: relationTableAlias,
      // 			joinOn,
      // 			nestedQueryRelation: relation,
      // 		});
      // 		const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
      // 		joins.push({
      // 			on: sql`true`,
      // 			table: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),
      // 			alias: relationTableAlias,
      // 			joinType: 'left',
      // 			lateral: true,
      // 		});
      // 		selectedRelations.push({
      // 			dbKey: selectedRelationTsKey,
      // 			tsKey: selectedRelationTsKey,
      // 			field,
      // 			relationTableTsKey: relationTableTsName,
      // 			isJson: true,
      // 			selection: builtRelation.selection,
      // 		});
      // 	}
      // 	const oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>
      // 		is(r.relation, One)
      // 	);
      // 	// Process all One relations with PKs, because they can all be joined on the same level
      // 	for (
      // 		const {
      // 			tsKey: selectedRelationTsKey,
      // 			queryConfig: selectedRelationConfigValue,
      // 			relation,
      // 		} of oneRelations
      // 	) {
      // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
      // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
      // 		const relationTableTsName = tableNamesMap[relationTableName]!;
      // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
      // 		const relationTable = schema[relationTableTsName]!;
      // 		if (relationTable.primaryKey.length === 0) {
      // 			continue;
      // 		}
      // 		const joinOn = and(
      // 			...normalizedRelation.fields.map((field, i) =>
      // 				eq(
      // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
      // 					aliasedTableColumn(field, tableAlias),
      // 				)
      // 			),
      // 		);
      // 		const builtRelation = this.buildRelationalQueryWithPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table: fullSchema[relationTableTsName] as PgTable,
      // 			tableConfig: schema[relationTableTsName]!,
      // 			queryConfig: selectedRelationConfigValue,
      // 			tableAlias: relationTableAlias,
      // 			joinOn,
      // 		});
      // 		const field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${
      // 			sql.join(
      // 				builtRelation.selection.map(({ field }) =>
      // 					is(field, SQL.Aliased)
      // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
      // 						: is(field, Column)
      // 						? aliasedTableColumn(field, relationTableAlias)
      // 						: field
      // 				),
      // 				sql`, `,
      // 			)
      // 		}) end`.as(selectedRelationTsKey);
      // 		const isLateralJoin = is(builtRelation.sql, SQL);
      // 		joins.push({
      // 			on: isLateralJoin ? sql`true` : joinOn,
      // 			table: is(builtRelation.sql, SQL)
      // 				? new Subquery(builtRelation.sql, {}, relationTableAlias)
      // 				: aliasedTable(builtRelation.sql, relationTableAlias),
      // 			alias: relationTableAlias,
      // 			joinType: 'left',
      // 			lateral: is(builtRelation.sql, SQL),
      // 		});
      // 		selectedRelations.push({
      // 			dbKey: selectedRelationTsKey,
      // 			tsKey: selectedRelationTsKey,
      // 			field,
      // 			relationTableTsKey: relationTableTsName,
      // 			isJson: true,
      // 			selection: builtRelation.selection,
      // 		});
      // 	}
      // 	let distinct: PgSelectConfig['distinct'];
      // 	let tableFrom: PgTable | Subquery = table;
      // 	// Process first Many relation - each one requires a nested subquery
      // 	const manyRelation = manyRelations[0];
      // 	if (manyRelation) {
      // 		const {
      // 			tsKey: selectedRelationTsKey,
      // 			queryConfig: selectedRelationQueryConfig,
      // 			relation,
      // 		} = manyRelation;
      // 		distinct = {
      // 			on: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),
      // 		};
      // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
      // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
      // 		const relationTableTsName = tableNamesMap[relationTableName]!;
      // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
      // 		const joinOn = and(
      // 			...normalizedRelation.fields.map((field, i) =>
      // 				eq(
      // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
      // 					aliasedTableColumn(field, tableAlias),
      // 				)
      // 			),
      // 		);
      // 		const builtRelationJoin = this.buildRelationalQueryWithPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table: fullSchema[relationTableTsName] as PgTable,
      // 			tableConfig: schema[relationTableTsName]!,
      // 			queryConfig: selectedRelationQueryConfig,
      // 			tableAlias: relationTableAlias,
      // 			joinOn,
      // 		});
      // 		const builtRelationSelectionField = sql`case when ${
      // 			sql.identifier(relationTableAlias)
      // 		} is null then '[]' else json_agg(json_build_array(${
      // 			sql.join(
      // 				builtRelationJoin.selection.map(({ field }) =>
      // 					is(field, SQL.Aliased)
      // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
      // 						: is(field, Column)
      // 						? aliasedTableColumn(field, relationTableAlias)
      // 						: field
      // 				),
      // 				sql`, `,
      // 			)
      // 		})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);
      // 		const isLateralJoin = is(builtRelationJoin.sql, SQL);
      // 		joins.push({
      // 			on: isLateralJoin ? sql`true` : joinOn,
      // 			table: isLateralJoin
      // 				? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)
      // 				: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),
      // 			alias: relationTableAlias,
      // 			joinType: 'left',
      // 			lateral: isLateralJoin,
      // 		});
      // 		// Build the "from" subquery with the remaining Many relations
      // 		const builtTableFrom = this.buildRelationalQueryWithPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table,
      // 			tableConfig,
      // 			queryConfig: {
      // 				...config,
      // 				where: undefined,
      // 				orderBy: undefined,
      // 				limit: undefined,
      // 				offset: undefined,
      // 				with: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(
      // 					(result, { tsKey, queryConfig: configValue }) => {
      // 						result[tsKey] = configValue;
      // 						return result;
      // 					},
      // 					{},
      // 				),
      // 			},
      // 			tableAlias,
      // 		});
      // 		selectedRelations.push({
      // 			dbKey: selectedRelationTsKey,
      // 			tsKey: selectedRelationTsKey,
      // 			field: builtRelationSelectionField,
      // 			relationTableTsKey: relationTableTsName,
      // 			isJson: true,
      // 			selection: builtRelationJoin.selection,
      // 		});
      // 		// selection = builtTableFrom.selection.map((item) =>
      // 		// 	is(item.field, SQL.Aliased)
      // 		// 		? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
      // 		// 		: item
      // 		// );
      // 		// selectionForBuild = [{
      // 		// 	dbKey: '*',
      // 		// 	tsKey: '*',
      // 		// 	field: sql`${sql.identifier(tableAlias)}.*`,
      // 		// 	selection: [],
      // 		// 	isJson: false,
      // 		// 	relationTableTsKey: undefined,
      // 		// }];
      // 		// const newSelectionItem: (typeof selection)[number] = {
      // 		// 	dbKey: selectedRelationTsKey,
      // 		// 	tsKey: selectedRelationTsKey,
      // 		// 	field,
      // 		// 	relationTableTsKey: relationTableTsName,
      // 		// 	isJson: true,
      // 		// 	selection: builtRelationJoin.selection,
      // 		// };
      // 		// selection.push(newSelectionItem);
      // 		// selectionForBuild.push(newSelectionItem);
      // 		tableFrom = is(builtTableFrom.sql, PgTable)
      // 			? builtTableFrom.sql
      // 			: new Subquery(builtTableFrom.sql, {}, tableAlias);
      // 	}
      // 	if (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {
      // 		throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
      // 	}
      // 	let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];
      // 	function prepareSelectedColumns() {
      // 		return selectedColumns.map((key) => ({
      // 			dbKey: tableConfig.columns[key]!.name,
      // 			tsKey: key,
      // 			field: tableConfig.columns[key] as PgColumn,
      // 			relationTableTsKey: undefined,
      // 			isJson: false,
      // 			selection: [],
      // 		}));
      // 	}
      // 	function prepareSelectedExtras() {
      // 		return selectedExtras.map((item) => ({
      // 			dbKey: item.value.fieldAlias,
      // 			tsKey: item.tsKey,
      // 			field: item.value,
      // 			relationTableTsKey: undefined,
      // 			isJson: false,
      // 			selection: [],
      // 		}));
      // 	}
      // 	if (isRoot) {
      // 		selection = [
      // 			...prepareSelectedColumns(),
      // 			...prepareSelectedExtras(),
      // 		];
      // 	}
      // 	if (hasUserDefinedWhere || orderBy.length > 0) {
      // 		tableFrom = new Subquery(
      // 			this.buildSelectQuery({
      // 				table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
      // 				fields: {},
      // 				fieldsFlat: selectionForBuild.map(({ field }) => ({
      // 					path: [],
      // 					field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
      // 				})),
      // 				joins,
      // 				distinct,
      // 			}),
      // 			{},
      // 			tableAlias,
      // 		);
      // 		selectionForBuild = selection.map((item) =>
      // 			is(item.field, SQL.Aliased)
      // 				? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
      // 				: item
      // 		);
      // 		joins = [];
      // 		distinct = undefined;
      // 	}
      // 	const result = this.buildSelectQuery({
      // 		table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
      // 		fields: {},
      // 		fieldsFlat: selectionForBuild.map(({ field }) => ({
      // 			path: [],
      // 			field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
      // 		})),
      // 		where,
      // 		limit,
      // 		offset,
      // 		joins,
      // 		orderBy,
      // 		distinct,
      // 	});
      // 	return {
      // 		tableTsKey: tableConfig.tsName,
      // 		sql: result,
      // 		selection,
      // 	};
      // }
      buildRelationalQueryWithoutPK({ fullSchema, schema: schema3, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn }) {
        let selection = [];
        let limit, offset2, orderBy = [], where;
        const joins = [];
        if (config === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key3, value]) => ({
            dbKey: value.name,
            tsKey: key3,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key3, value]) => [key3, aliasedTableColumn(value, tableAlias)]));
          if (config.where) {
            const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key3) => !selectedColumns.includes(key3));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config.with) {
            selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config.extras) {
            extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config.limit;
          offset2 = config.offset;
          for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema3, tableNamesMap, relation);
            const relationTableName = relation.referencedTable[Table.Symbol.Name];
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(...normalizedRelation.fields.map((field2, i2) => eq(aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
            const builtRelation = this.buildRelationalQueryWithoutPK({
              fullSchema,
              schema: schema3,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema3[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
            joins.push({
              on: sql`true`,
              table: new Subquery(builtRelation.sql, {}, relationTableAlias),
              alias: relationTableAlias,
              joinType: "left",
              lateral: true
            });
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : void 0}), '[]'::json)`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field: field.as("data"),
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset2 !== void 0 || orderBy.length > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table, tableAlias),
              fields: {},
              fieldsFlat: [{
                path: [],
                field: sql.raw("*")
              }],
              where,
              limit,
              offset: offset2,
              orderBy
            });
            where = void 0;
            limit = void 0;
            offset2 = void 0;
            orderBy = [];
          } else {
            result = aliasedTable(table, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            joins,
            where,
            limit,
            offset: offset2,
            orderBy
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            joins,
            where,
            limit,
            offset: offset2,
            orderBy
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
    };
    _a47 = entityKind;
    __publicField(PgDialect, _a47, "PgDialect");
    TypedQueryBuilder = class {
      /** @internal */
      getSelectedFields() {
        return this._.selectedFields;
      }
    };
    _a48 = entityKind;
    __publicField(TypedQueryBuilder, _a48, "TypedQueryBuilder");
    PgSelectBuilder = class {
      constructor(config) {
        __publicField(this, "fields");
        __publicField(this, "session");
        __publicField(this, "dialect");
        __publicField(this, "withList", []);
        __publicField(this, "distinct");
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        if (config.withList) {
          this.withList = config.withList;
        }
        this.distinct = config.distinct;
      }
      /**
       * Specify the table, subquery, or other target that you're
       * building a select query against.
       *
       * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM|Postgres from documentation}
       */
      from(source2) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
          fields = this.fields;
        } else if (is(source2, Subquery)) {
          fields = Object.fromEntries(Object.keys(source2[SubqueryConfig].selection).map((key3) => [key3, source2[key3]]));
        } else if (is(source2, PgViewBase)) {
          fields = source2[ViewBaseConfig].selectedFields;
        } else if (is(source2, SQL)) {
          fields = {};
        } else {
          fields = getTableColumns(source2);
        }
        return new PgSelect({
          table: source2,
          fields,
          isPartialSelect,
          session: this.session,
          dialect: this.dialect,
          withList: this.withList,
          distinct: this.distinct
        });
      }
    };
    _a49 = entityKind;
    __publicField(PgSelectBuilder, _a49, "PgSelectBuilder");
    PgSelectQueryBuilder = class extends TypedQueryBuilder {
      constructor({ table, fields, isPartialSelect, session: session2, dialect, withList, distinct }) {
        super();
        __publicField(this, "_");
        __publicField(this, "config");
        __publicField(this, "joinsNotNullableMap");
        __publicField(this, "tableName");
        __publicField(this, "isPartialSelect");
        __publicField(this, "session");
        __publicField(this, "dialect");
        /**
         * For each row of the table, include
         * values from a matching row of the joined
         * table, if there is a matching row. If not,
         * all of the columns of the joined table
         * will be set to null.
         */
        __publicField(this, "leftJoin", this.createJoin("left"));
        /**
         * Includes all of the rows of the joined table.
         * If there is no matching row in the main table,
         * all the columns of the main table will be
         * set to null.
         */
        __publicField(this, "rightJoin", this.createJoin("right"));
        /**
         * This is the default type of join.
         *
         * For each row of the table, the joined table
         * needs to have a matching row, or it will
         * be excluded from results.
         */
        __publicField(this, "innerJoin", this.createJoin("inner"));
        /**
         * Rows from both the main & joined are included,
         * regardless of whether or not they have matching
         * rows in the other table.
         */
        __publicField(this, "fullJoin", this.createJoin("full"));
        this.config = {
          withList,
          table,
          fields: { ...fields },
          distinct
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session2;
        this.dialect = dialect;
        this._ = {
          selectedFields: fields
        };
        this.tableName = getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      }
      createJoin(joinType) {
        return (table, on) => {
          const baseTableName = this.tableName;
          const tableName = getTableLikeName(table);
          if (typeof tableName === "string" && this.config.joins?.some((join2) => join2.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (!this.isPartialSelect) {
            if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
              this.config.fields = {
                [baseTableName]: this.config.fields
              };
            }
            if (typeof tableName === "string" && !is(table, SQL)) {
              const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
              this.config.fields[tableName] = selection;
            }
          }
          if (typeof on === "function") {
            on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
          }
          if (!this.config.joins) {
            this.config.joins = [];
          }
          this.config.joins.push({ on, table, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key3]) => [key3, false]));
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key3]) => [key3, false]));
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      /**
       * Specify a condition to narrow the result set. Multiple
       * conditions can be combined with the `and` and `or`
       * functions.
       *
       * ## Examples
       *
       * ```ts
       * // Find cars made in the year 2000
       * db.select().from(cars).where(eq(cars.year, 2000));
       * ```
       */
      where(where) {
        if (typeof where === "function") {
          where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
        }
        this.config.where = where;
        return this;
      }
      /**
       * Sets the HAVING clause of this query, which often
       * used with GROUP BY and filters rows after they've been
       * grouped together and combined.
       *
       * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-HAVING|Postgres having clause documentation}
       */
      having(having) {
        if (typeof having === "function") {
          having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
        }
        this.config.having = having;
        return this;
      }
      groupBy(...columns) {
        if (typeof columns[0] === "function") {
          const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
          this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        } else {
          this.config.groupBy = columns;
        }
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
          this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
        } else {
          this.config.orderBy = columns;
        }
        return this;
      }
      /**
       * Set the maximum number of rows that will be
       * returned by this query.
       *
       * ## Examples
       *
       * ```ts
       * // Get the first 10 people from this query.
       * db.select().from(people).limit(10);
       * ```
       *
       * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-LIMIT|Postgres LIMIT documentation}
       */
      limit(limit) {
        this.config.limit = limit;
        return this;
      }
      /**
       * Skip a number of rows when returning results
       * from this query.
       *
       * ## Examples
       *
       * ```ts
       * // Get the 10th-20th people from this query.
       * db.select().from(people).offset(10).limit(10);
       * ```
       */
      offset(offset2) {
        this.config.offset = offset2;
        return this;
      }
      /**
       * The FOR clause specifies a lock strength for this query
       * that controls how strictly it acquires exclusive access to
       * the rows being queried.
       *
       * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE|Postgres locking clause documentation}
       */
      for(strength, config = {}) {
        if (!this.config.lockingClauses) {
          this.config.lockingClauses = [];
        }
        this.config.lockingClauses.push({ strength, config });
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildSelectQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      as(alias) {
        return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
    _a50 = entityKind;
    __publicField(PgSelectQueryBuilder, _a50, "PgSelectQueryBuilder");
    PgSelect = class extends PgSelectQueryBuilder {
      constructor() {
        super(...arguments);
        __publicField(this, "execute", (placeholderValues) => {
          return tracer.startActiveSpan("drizzle.operation", () => {
            return this._prepare().execute(placeholderValues);
          });
        });
      }
      _prepare(name3) {
        const { session: session2, config, dialect, joinsNotNullableMap } = this;
        if (!session2) {
          throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
        }
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          const fieldsList = orderSelectedFields(config.fields);
          const query = session2.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name3);
          query.joinsNotNullableMap = joinsNotNullableMap;
          return query;
        });
      }
      /**
       * Create a prepared statement for this query. This allows
       * the database to remember this query for the given session
       * and call it by name, rather than specifying the full query.
       *
       * {@link https://www.postgresql.org/docs/current/sql-prepare.html|Postgres prepare documentation}
       */
      prepare(name3) {
        return this._prepare(name3);
      }
    };
    _a51 = entityKind;
    __publicField(PgSelect, _a51, "PgSelect");
    applyMixins(PgSelect, [QueryPromise]);
    QueryBuilder = class {
      constructor() {
        __publicField(this, "dialect");
      }
      $with(alias) {
        const queryBuilder = this;
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(queryBuilder);
            }
            return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
          }
        };
      }
      with(...queries) {
        const self = this;
        function select(fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries
          });
        }
        function selectDistinct(fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            distinct: true
          });
        }
        function selectDistinctOn(on, fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            distinct: { on }
          });
        }
        return { select, selectDistinct, selectDistinctOn };
      }
      select(fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect()
        });
      }
      selectDistinct(fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: true
        });
      }
      selectDistinctOn(on, fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: { on }
        });
      }
      // Lazy load dialect to avoid circular dependency
      getDialect() {
        if (!this.dialect) {
          this.dialect = new PgDialect();
        }
        return this.dialect;
      }
    };
    _a52 = entityKind;
    __publicField(QueryBuilder, _a52, "PgQueryBuilder");
    DefaultViewBuilderCore = class {
      constructor(name3, schema3) {
        __publicField(this, "name");
        __publicField(this, "schema");
        __publicField(this, "config", {});
        this.name = name3;
        this.schema = schema3;
      }
      with(config) {
        this.config.with = config;
        return this;
      }
    };
    _a53 = entityKind;
    __publicField(DefaultViewBuilderCore, _a53, "PgDefaultViewBuilderCore");
    ViewBuilder = class extends DefaultViewBuilderCore {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new PgView({
          pgConfig: this.config,
          config: {
            name: this.name,
            schema: this.schema,
            selectedFields: aliasedSelection,
            query: qb.getSQL().inlineParams()
          }
        }), selectionProxy);
      }
    };
    _a54 = entityKind;
    __publicField(ViewBuilder, _a54, "PgViewBuilder");
    ManualViewBuilder = class extends DefaultViewBuilderCore {
      constructor(name3, columns, schema3) {
        super(name3, schema3);
        __publicField(this, "columns");
        this.columns = getTableColumns(pgTable(name3, columns));
      }
      existing() {
        return new Proxy(new PgView({
          pgConfig: void 0,
          config: {
            name: this.name,
            schema: this.schema,
            selectedFields: this.columns,
            query: void 0
          }
        }), new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        }));
      }
      as(query) {
        return new Proxy(new PgView({
          pgConfig: this.config,
          config: {
            name: this.name,
            schema: this.schema,
            selectedFields: this.columns,
            query: query.inlineParams()
          }
        }), new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        }));
      }
    };
    _a55 = entityKind;
    __publicField(ManualViewBuilder, _a55, "PgManualViewBuilder");
    MaterializedViewBuilderCore = class {
      constructor(name3, schema3) {
        __publicField(this, "name");
        __publicField(this, "schema");
        __publicField(this, "config", {});
        this.name = name3;
        this.schema = schema3;
      }
      using(using) {
        this.config.using = using;
        return this;
      }
      with(config) {
        this.config.with = config;
        return this;
      }
      tablespace(tablespace) {
        this.config.tablespace = tablespace;
        return this;
      }
      withNoData() {
        this.config.withNoData = true;
        return this;
      }
    };
    _a56 = entityKind;
    __publicField(MaterializedViewBuilderCore, _a56, "PgMaterializedViewBuilderCore");
    MaterializedViewBuilder = class extends MaterializedViewBuilderCore {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new PgMaterializedView({
          pgConfig: {
            with: this.config.with,
            using: this.config.using,
            tablespace: this.config.tablespace,
            withNoData: this.config.withNoData
          },
          config: {
            name: this.name,
            schema: this.schema,
            selectedFields: aliasedSelection,
            query: qb.getSQL().inlineParams()
          }
        }), selectionProxy);
      }
    };
    _a57 = entityKind;
    __publicField(MaterializedViewBuilder, _a57, "PgMaterializedViewBuilder");
    ManualMaterializedViewBuilder = class extends MaterializedViewBuilderCore {
      constructor(name3, columns, schema3) {
        super(name3, schema3);
        __publicField(this, "columns");
        this.columns = getTableColumns(pgTable(name3, columns));
      }
      existing() {
        return new Proxy(new PgMaterializedView({
          pgConfig: void 0,
          config: {
            name: this.name,
            schema: this.schema,
            selectedFields: this.columns,
            query: void 0
          }
        }), new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        }));
      }
      as(query) {
        return new Proxy(new PgMaterializedView({
          pgConfig: void 0,
          config: {
            name: this.name,
            schema: this.schema,
            selectedFields: this.columns,
            query: query.inlineParams()
          }
        }), new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        }));
      }
    };
    _a58 = entityKind;
    __publicField(ManualMaterializedViewBuilder, _a58, "PgManualMaterializedViewBuilder");
    PgViewBase = class extends View {
    };
    _a59 = entityKind;
    __publicField(PgViewBase, _a59, "PgViewBase");
    PgViewConfig = Symbol.for("drizzle:PgViewConfig");
    PgView = class extends PgViewBase {
      constructor({ pgConfig, config }) {
        super(config);
        __publicField(this, _b6);
        if (pgConfig) {
          this[PgViewConfig] = {
            with: pgConfig.with
          };
        }
      }
    };
    _a60 = entityKind, _b6 = PgViewConfig;
    __publicField(PgView, _a60, "PgView");
    PgMaterializedViewConfig = Symbol.for("drizzle:PgMaterializedViewConfig");
    PgMaterializedView = class extends PgViewBase {
      constructor({ pgConfig, config }) {
        super(config);
        __publicField(this, _b7);
        this[PgMaterializedViewConfig] = {
          with: pgConfig?.with,
          using: pgConfig?.using,
          tablespace: pgConfig?.tablespace,
          withNoData: pgConfig?.withNoData
        };
      }
    };
    _a61 = entityKind, _b7 = PgMaterializedViewConfig;
    __publicField(PgMaterializedView, _a61, "PgMaterializedView");
    Relation = class {
      constructor(sourceTable, referencedTable, relationName) {
        __publicField(this, "sourceTable");
        __publicField(this, "referencedTable");
        __publicField(this, "relationName");
        __publicField(this, "referencedTableName");
        __publicField(this, "fieldName");
        this.sourceTable = sourceTable;
        this.referencedTable = referencedTable;
        this.relationName = relationName;
        this.referencedTableName = referencedTable[Table.Symbol.Name];
      }
    };
    _a62 = entityKind;
    __publicField(Relation, _a62, "Relation");
    Relations = class {
      constructor(table, config) {
        __publicField(this, "table");
        __publicField(this, "config");
        this.table = table;
        this.config = config;
      }
    };
    _a63 = entityKind;
    __publicField(Relations, _a63, "Relations");
    _One = class _One extends Relation {
      constructor(sourceTable, referencedTable, config, isNullable) {
        super(sourceTable, referencedTable, config?.relationName);
        __publicField(this, "config");
        __publicField(this, "isNullable");
        this.config = config;
        this.isNullable = isNullable;
      }
      withFieldName(fieldName) {
        const relation = new _One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
        relation.fieldName = fieldName;
        return relation;
      }
    };
    _a64 = entityKind;
    __publicField(_One, _a64, "One");
    One = _One;
    _Many = class _Many extends Relation {
      constructor(sourceTable, referencedTable, config) {
        super(sourceTable, referencedTable, config?.relationName);
        __publicField(this, "config");
        this.config = config;
      }
      withFieldName(fieldName) {
        const relation = new _Many(this.sourceTable, this.referencedTable, this.config);
        relation.fieldName = fieldName;
        return relation;
      }
    };
    _a65 = entityKind;
    __publicField(_Many, _a65, "Many");
    Many = _Many;
    eq = (left, right) => {
      return sql`${left} = ${bindIfParam(right, left)}`;
    };
    ne = (left, right) => {
      return sql`${left} <> ${bindIfParam(right, left)}`;
    };
    gt = (left, right) => {
      return sql`${left} > ${bindIfParam(right, left)}`;
    };
    gte = (left, right) => {
      return sql`${left} >= ${bindIfParam(right, left)}`;
    };
    lt = (left, right) => {
      return sql`${left} < ${bindIfParam(right, left)}`;
    };
    lte = (left, right) => {
      return sql`${left} <= ${bindIfParam(right, left)}`;
    };
    FakePrimitiveParam = class {
    };
    _a66 = entityKind;
    __publicField(FakePrimitiveParam, _a66, "FakePrimitiveParam");
    StringChunk = class {
      constructor(value) {
        __publicField(this, "value");
        this.value = Array.isArray(value) ? value : [value];
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    _a67 = entityKind;
    __publicField(StringChunk, _a67, "StringChunk");
    _SQL = class _SQL {
      constructor(queryChunks) {
        __publicField(this, "queryChunks");
        /** @internal */
        __publicField(this, "decoder", noopDecoder);
        __publicField(this, "shouldInlineParams", false);
        this.queryChunks = queryChunks;
      }
      append(query) {
        this.queryChunks.push(...query.queryChunks);
        return this;
      }
      toQuery(config) {
        return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
          const query = this.buildQueryFromSourceParams(this.queryChunks, config);
          span?.setAttributes({
            "drizzle.query.text": query.sql,
            "drizzle.query.params": JSON.stringify(query.params)
          });
          return query;
        });
      }
      buildQueryFromSourceParams(chunks, _config) {
        const config = Object.assign({}, _config, {
          inlineParams: _config.inlineParams || this.shouldInlineParams,
          paramStartIndex: _config.paramStartIndex || { value: 0 }
        });
        const { escapeName: escapeName2, escapeParam, prepareTyping, inlineParams, paramStartIndex } = config;
        return mergeQueries(chunks.map((chunk) => {
          if (is(chunk, StringChunk)) {
            return { sql: chunk.value.join(""), params: [] };
          }
          if (is(chunk, Name)) {
            return { sql: escapeName2(chunk.value), params: [] };
          }
          if (chunk === void 0) {
            return { sql: "", params: [] };
          }
          if (Array.isArray(chunk)) {
            const result = [new StringChunk("(")];
            for (const [i2, p2] of chunk.entries()) {
              result.push(p2);
              if (i2 < chunk.length - 1) {
                result.push(new StringChunk(", "));
              }
            }
            result.push(new StringChunk(")"));
            return this.buildQueryFromSourceParams(result, config);
          }
          if (is(chunk, _SQL)) {
            return this.buildQueryFromSourceParams(chunk.queryChunks, {
              ...config,
              inlineParams: inlineParams || chunk.shouldInlineParams
            });
          }
          if (is(chunk, Table)) {
            const schemaName = chunk[Table.Symbol.Schema];
            const tableName = chunk[Table.Symbol.Name];
            return {
              sql: schemaName === void 0 ? escapeName2(tableName) : escapeName2(schemaName) + "." + escapeName2(tableName),
              params: []
            };
          }
          if (is(chunk, Column)) {
            return { sql: escapeName2(chunk.table[Table.Symbol.Name]) + "." + escapeName2(chunk.name), params: [] };
          }
          if (is(chunk, View)) {
            const schemaName = chunk[ViewBaseConfig].schema;
            const viewName = chunk[ViewBaseConfig].name;
            return {
              sql: schemaName === void 0 ? escapeName2(viewName) : escapeName2(schemaName) + "." + escapeName2(viewName),
              params: []
            };
          }
          if (is(chunk, Param)) {
            const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
            if (is(mappedValue, _SQL)) {
              return this.buildQueryFromSourceParams([mappedValue], config);
            }
            if (inlineParams) {
              return { sql: this.mapInlineParam(mappedValue, config), params: [] };
            }
            let typings;
            if (prepareTyping !== void 0) {
              typings = [prepareTyping(chunk.encoder)];
            }
            return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
          }
          if (is(chunk, Placeholder)) {
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
          }
          if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
            return { sql: escapeName2(chunk.fieldAlias), params: [] };
          }
          if (is(chunk, Subquery)) {
            if (chunk[SubqueryConfig].isWith) {
              return { sql: escapeName2(chunk[SubqueryConfig].alias), params: [] };
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk[SubqueryConfig].sql,
              new StringChunk(") "),
              new Name(chunk[SubqueryConfig].alias)
            ], config);
          }
          if (isSQLWrapper(chunk)) {
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk.getSQL(),
              new StringChunk(")")
            ], config);
          }
          if (is(chunk, Relation)) {
            return this.buildQueryFromSourceParams([
              chunk.sourceTable,
              new StringChunk("."),
              sql.identifier(chunk.fieldName)
            ], config);
          }
          if (inlineParams) {
            return { sql: this.mapInlineParam(chunk, config), params: [] };
          }
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
        }));
      }
      mapInlineParam(chunk, { escapeString }) {
        if (chunk === null) {
          return "null";
        }
        if (typeof chunk === "number" || typeof chunk === "boolean") {
          return chunk.toString();
        }
        if (typeof chunk === "string") {
          return escapeString(chunk);
        }
        if (typeof chunk === "object") {
          const mappedValueAsString = chunk.toString();
          if (mappedValueAsString === "[object Object]") {
            return escapeString(JSON.stringify(chunk));
          }
          return escapeString(mappedValueAsString);
        }
        throw new Error("Unexpected param value: " + chunk);
      }
      getSQL() {
        return this;
      }
      as(alias) {
        if (alias === void 0) {
          return this;
        }
        return new _SQL.Aliased(this, alias);
      }
      mapWith(decoder2) {
        this.decoder = typeof decoder2 === "function" ? { mapFromDriverValue: decoder2 } : decoder2;
        return this;
      }
      inlineParams() {
        this.shouldInlineParams = true;
        return this;
      }
    };
    _a68 = entityKind;
    __publicField(_SQL, _a68, "SQL");
    SQL = _SQL;
    Name = class {
      constructor(value) {
        __publicField(this, "value");
        __publicField(this, "brand");
        this.value = value;
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    _a69 = entityKind;
    __publicField(Name, _a69, "Name");
    noopDecoder = {
      mapFromDriverValue: (value) => value
    };
    noopEncoder = {
      mapToDriverValue: (value) => value
    };
    noopMapper = {
      ...noopDecoder,
      ...noopEncoder
    };
    Param = class {
      /**
       * @param value - Parameter value
       * @param encoder - Encoder to convert the value to a driver parameter
       */
      constructor(value, encoder3 = noopEncoder) {
        __publicField(this, "value");
        __publicField(this, "encoder");
        __publicField(this, "brand");
        this.value = value;
        this.encoder = encoder3;
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    _a70 = entityKind;
    __publicField(Param, _a70, "Param");
    (function(sql2) {
      function empty2() {
        return new SQL([]);
      }
      sql2.empty = empty2;
      function fromList(list) {
        return new SQL(list);
      }
      sql2.fromList = fromList;
      function raw(str) {
        return new SQL([new StringChunk(str)]);
      }
      sql2.raw = raw;
      function join2(chunks, separator) {
        const result = [];
        for (const [i2, chunk] of chunks.entries()) {
          if (i2 > 0 && separator !== void 0) {
            result.push(separator);
          }
          result.push(chunk);
        }
        return new SQL(result);
      }
      sql2.join = join2;
      function identifier(value) {
        return new Name(value);
      }
      sql2.identifier = identifier;
      function placeholder2(name3) {
        return new Placeholder(name3);
      }
      sql2.placeholder = placeholder2;
      function param2(value, encoder3) {
        return new Param(value, encoder3);
      }
      sql2.param = param2;
    })(sql || (sql = {}));
    (function(SQL2) {
      var _a178;
      const _Aliased = class _Aliased {
        constructor(sql2, fieldAlias) {
          __publicField(this, "sql");
          __publicField(this, "fieldAlias");
          /** @internal */
          __publicField(this, "isSelectionField", false);
          this.sql = sql2;
          this.fieldAlias = fieldAlias;
        }
        getSQL() {
          return this.sql;
        }
        /** @internal */
        clone() {
          return new _Aliased(this.sql, this.fieldAlias);
        }
      };
      _a178 = entityKind;
      __publicField(_Aliased, _a178, "SQL.Aliased");
      let Aliased = _Aliased;
      SQL2.Aliased = Aliased;
    })(SQL || (SQL = {}));
    Placeholder = class {
      constructor(name3) {
        __publicField(this, "name");
        this.name = name3;
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    _a71 = entityKind;
    __publicField(Placeholder, _a71, "Placeholder");
    Column.prototype.getSQL = function() {
      return new SQL([this]);
    };
    ColumnAliasProxyHandler = class {
      constructor(table) {
        __publicField(this, "table");
        this.table = table;
      }
      get(columnObj, prop) {
        if (prop === "table") {
          return this.table;
        }
        return columnObj[prop];
      }
    };
    _a72 = entityKind;
    __publicField(ColumnAliasProxyHandler, _a72, "ColumnAliasProxyHandler");
    TableAliasProxyHandler = class {
      constructor(alias, replaceOriginalName) {
        __publicField(this, "alias");
        __publicField(this, "replaceOriginalName");
        this.alias = alias;
        this.replaceOriginalName = replaceOriginalName;
      }
      get(target, prop) {
        if (prop === Table.Symbol.IsAlias) {
          return true;
        }
        if (prop === Table.Symbol.Name) {
          return this.alias;
        }
        if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
          return this.alias;
        }
        if (prop === ViewBaseConfig) {
          return {
            ...target[ViewBaseConfig],
            name: this.alias,
            isAlias: true
          };
        }
        if (prop === Table.Symbol.Columns) {
          const columns = target[Table.Symbol.Columns];
          if (!columns) {
            return columns;
          }
          const proxiedColumns = {};
          Object.keys(columns).map((key3) => {
            proxiedColumns[key3] = new Proxy(columns[key3], new ColumnAliasProxyHandler(new Proxy(target, this)));
          });
          return proxiedColumns;
        }
        const value = target[prop];
        if (is(value, Column)) {
          return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
        }
        return value;
      }
    };
    _a73 = entityKind;
    __publicField(TableAliasProxyHandler, _a73, "TableAliasProxyHandler");
    RelationTableAliasProxyHandler = class {
      constructor(alias) {
        __publicField(this, "alias");
        this.alias = alias;
      }
      get(target, prop) {
        if (prop === "sourceTable") {
          return aliasedTable(target.sourceTable, this.alias);
        }
        return target[prop];
      }
    };
    _a74 = entityKind;
    __publicField(RelationTableAliasProxyHandler, _a74, "RelationTableAliasProxyHandler");
  }
});

// node_modules/.pnpm/drizzle-orm@0.28.6_@planetscale+database@1.11.0/node_modules/drizzle-orm/index.mjs
var _a75, ConsoleLogWriter, _a76, DefaultLogger, _a77, NoopLogger;
var init_drizzle_orm = __esm({
  "node_modules/.pnpm/drizzle-orm@0.28.6_@planetscale+database@1.11.0/node_modules/drizzle-orm/index.mjs"() {
    init_alias_cf8e03cd();
    init_alias_cf8e03cd();
    ConsoleLogWriter = class {
      write(message) {
        console.log(message);
      }
    };
    _a75 = entityKind;
    __publicField(ConsoleLogWriter, _a75, "ConsoleLogWriter");
    DefaultLogger = class {
      constructor(config) {
        __publicField(this, "writer");
        this.writer = config?.writer ?? new ConsoleLogWriter();
      }
      logQuery(query, params) {
        const stringifiedParams = params.map((p2) => {
          try {
            return JSON.stringify(p2);
          } catch {
            return String(p2);
          }
        });
        const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
        this.writer.write(`Query: ${query}${paramsStr}`);
      }
    };
    _a76 = entityKind;
    __publicField(DefaultLogger, _a76, "DefaultLogger");
    NoopLogger = class {
      logQuery() {
      }
    };
    _a77 = entityKind;
    __publicField(NoopLogger, _a77, "NoopLogger");
  }
});

// node_modules/.pnpm/drizzle-orm@0.28.6_@planetscale+database@1.11.0/node_modules/drizzle-orm/view-23898f21.mjs
function mysqlTableWithSchema(name3, columns, extraConfig, schema3, baseName = name3) {
  const rawTable = new MySqlTable(name3, schema3, baseName);
  const builtColumns = Object.fromEntries(Object.entries(columns).map(([name4, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys2].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name4, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table[MySqlTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
function mysqlTableCreator(customizeTableName) {
  return (name3, columns, extraConfig) => {
    return mysqlTableWithSchema(customizeTableName(name3), columns, extraConfig, void 0, name3);
  };
}
function uniqueKeyName2(table, columns) {
  return `${table[MySqlTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
function mysqlViewWithSchema(name3, selection, schema3) {
  if (selection) {
    return new ManualViewBuilder2(name3, selection, schema3);
  }
  return new ViewBuilder2(name3, schema3);
}
var InlineForeignKeys2, _a78, _b8, _c3, _d2, MySqlTable, mysqlTable, _a79, ForeignKeyBuilder2, _a80, ForeignKey2, _a81, UniqueConstraintBuilder2, _a82, UniqueOnConstraintBuilder2, _a83, UniqueConstraint2, _a84, MySqlColumnBuilder, _a85, MySqlColumn, _a86, MySqlColumnBuilderWithAutoIncrement, _a87, MySqlColumnWithAutoIncrement, _a88, MySqlDelete, _a89, MySqlInsertBuilder, _a90, MySqlInsert, _a91, MySqlDialect, _a92, MySqlSelectBuilder, _a93, MySqlSelectQueryBuilder, _a94, MySqlSelect, _a95, QueryBuilder2, _a96, RelationalQueryBuilder, _a97, MySqlRelationalQuery, _a98, MySqlDatabase, _a99, PreparedQuery, _a100, MySqlSession, _a101, MySqlTransaction, _a102, MySqlUpdateBuilder, _a103, MySqlUpdate, _a104, ViewBuilderCore, _a105, ViewBuilder2, _a106, ManualViewBuilder2, _a107, MySqlViewBase, MySqlViewConfig, _a108, _b9, MySqlView;
var init_view_23898f21 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.28.6_@planetscale+database@1.11.0/node_modules/drizzle-orm/view-23898f21.mjs"() {
    init_alias_cf8e03cd();
    InlineForeignKeys2 = Symbol.for("drizzle:MySqlInlineForeignKeys");
    MySqlTable = class extends Table {
      constructor() {
        super(...arguments);
        /** @internal */
        __publicField(this, _b8);
        /** @internal */
        __publicField(this, _c3, []);
        /** @internal */
        __publicField(this, _d2);
      }
    };
    _a78 = entityKind, _b8 = Table.Symbol.Columns, _c3 = InlineForeignKeys2, _d2 = Table.Symbol.ExtraConfigBuilder;
    __publicField(MySqlTable, _a78, "MySqlTable");
    /** @internal */
    __publicField(MySqlTable, "Symbol", Object.assign({}, Table.Symbol, {
      InlineForeignKeys: InlineForeignKeys2
    }));
    mysqlTable = (name3, columns, extraConfig) => {
      return mysqlTableWithSchema(name3, columns, extraConfig, void 0, name3);
    };
    ForeignKeyBuilder2 = class {
      constructor(config, actions4) {
        /** @internal */
        __publicField(this, "reference");
        /** @internal */
        __publicField(this, "_onUpdate");
        /** @internal */
        __publicField(this, "_onDelete");
        this.reference = () => {
          const { columns, foreignColumns } = config();
          return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions4) {
          this._onUpdate = actions4.onUpdate;
          this._onDelete = actions4.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action;
        return this;
      }
      /** @internal */
      build(table) {
        return new ForeignKey2(table, this);
      }
    };
    _a79 = entityKind;
    __publicField(ForeignKeyBuilder2, _a79, "MySqlForeignKeyBuilder");
    ForeignKey2 = class {
      constructor(table, builder2) {
        __publicField(this, "table");
        __publicField(this, "reference");
        __publicField(this, "onUpdate");
        __publicField(this, "onDelete");
        this.table = table;
        this.reference = builder2.reference;
        this.onUpdate = builder2._onUpdate;
        this.onDelete = builder2._onDelete;
      }
      getName() {
        const { columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[MySqlTable.Symbol.Name],
          ...columnNames,
          foreignColumns[0].table[MySqlTable.Symbol.Name],
          ...foreignColumnNames
        ];
        return `${chunks.join("_")}_fk`;
      }
    };
    _a80 = entityKind;
    __publicField(ForeignKey2, _a80, "MySqlForeignKey");
    UniqueConstraintBuilder2 = class {
      constructor(columns, name3) {
        __publicField(this, "name");
        /** @internal */
        __publicField(this, "columns");
        this.name = name3;
        this.columns = columns;
      }
      /** @internal */
      build(table) {
        return new UniqueConstraint2(table, this.columns, this.name);
      }
    };
    _a81 = entityKind;
    __publicField(UniqueConstraintBuilder2, _a81, "MySqlUniqueConstraintBuilder");
    UniqueOnConstraintBuilder2 = class {
      constructor(name3) {
        /** @internal */
        __publicField(this, "name");
        this.name = name3;
      }
      on(...columns) {
        return new UniqueConstraintBuilder2(columns, this.name);
      }
    };
    _a82 = entityKind;
    __publicField(UniqueOnConstraintBuilder2, _a82, "MySqlUniqueOnConstraintBuilder");
    UniqueConstraint2 = class {
      constructor(table, columns, name3) {
        __publicField(this, "table");
        __publicField(this, "columns");
        __publicField(this, "name");
        __publicField(this, "nullsNotDistinct", false);
        this.table = table;
        this.columns = columns;
        this.name = name3 ?? uniqueKeyName2(this.table, this.columns.map((column) => column.name));
      }
      getName() {
        return this.name;
      }
    };
    _a83 = entityKind;
    __publicField(UniqueConstraint2, _a83, "MySqlUniqueConstraint");
    MySqlColumnBuilder = class extends ColumnBuilder {
      constructor() {
        super(...arguments);
        __publicField(this, "foreignKeyConfigs", []);
      }
      references(ref, actions4 = {}) {
        this.foreignKeyConfigs.push({ ref, actions: actions4 });
        return this;
      }
      unique(name3) {
        this.config.isUnique = true;
        this.config.uniqueName = name3;
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions: actions4 }) => {
          return ((ref2, actions5) => {
            const builder2 = new ForeignKeyBuilder2(() => {
              const foreignColumn = ref2();
              return { columns: [column], foreignColumns: [foreignColumn] };
            });
            if (actions5.onUpdate) {
              builder2.onUpdate(actions5.onUpdate);
            }
            if (actions5.onDelete) {
              builder2.onDelete(actions5.onDelete);
            }
            return builder2.build(table);
          })(ref, actions4);
        });
      }
    };
    _a84 = entityKind;
    __publicField(MySqlColumnBuilder, _a84, "MySqlColumnBuilder");
    MySqlColumn = class extends Column {
      constructor(table, config) {
        if (!config.uniqueName) {
          config.uniqueName = uniqueKeyName2(table, [config.name]);
        }
        super(table, config);
        __publicField(this, "table");
        this.table = table;
      }
    };
    _a85 = entityKind;
    __publicField(MySqlColumn, _a85, "MySqlColumn");
    MySqlColumnBuilderWithAutoIncrement = class extends MySqlColumnBuilder {
      constructor(name3, dataType, columnType) {
        super(name3, dataType, columnType);
        this.config.autoIncrement = false;
      }
      autoincrement() {
        this.config.autoIncrement = true;
        this.config.hasDefault = true;
        return this;
      }
    };
    _a86 = entityKind;
    __publicField(MySqlColumnBuilderWithAutoIncrement, _a86, "MySqlColumnBuilderWithAutoIncrement");
    MySqlColumnWithAutoIncrement = class extends MySqlColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "autoIncrement", this.config.autoIncrement);
      }
    };
    _a87 = entityKind;
    __publicField(MySqlColumnWithAutoIncrement, _a87, "MySqlColumnWithAutoIncrement");
    MySqlDelete = class extends QueryPromise {
      constructor(table, session2, dialect) {
        super();
        __publicField(this, "table");
        __publicField(this, "session");
        __publicField(this, "dialect");
        __publicField(this, "config");
        __publicField(this, "execute", (placeholderValues) => {
          return this.prepare().execute(placeholderValues);
        });
        __publicField(this, "createIterator", () => {
          const self = this;
          return async function* (placeholderValues) {
            yield* self.prepare().iterator(placeholderValues);
          };
        });
        __publicField(this, "iterator", this.createIterator());
        this.table = table;
        this.session = session2;
        this.dialect = dialect;
        this.config = { table };
      }
      where(where) {
        this.config.where = where;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      prepare() {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
      }
    };
    _a88 = entityKind;
    __publicField(MySqlDelete, _a88, "MySqlDelete");
    MySqlInsertBuilder = class {
      constructor(table, session2, dialect) {
        __publicField(this, "table");
        __publicField(this, "session");
        __publicField(this, "dialect");
        __publicField(this, "shouldIgnore", false);
        this.table = table;
        this.session = session2;
        this.dialect = dialect;
      }
      ignore() {
        this.shouldIgnore = true;
        return this;
      }
      values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
          throw new Error("values() must be called with at least one value");
        }
        const mappedValues = values.map((entry) => {
          const result = {};
          const cols = this.table[Table.Symbol.Columns];
          for (const colKey of Object.keys(entry)) {
            const colValue = entry[colKey];
            result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
          }
          return result;
        });
        return new MySqlInsert(this.table, mappedValues, this.shouldIgnore, this.session, this.dialect);
      }
    };
    _a89 = entityKind;
    __publicField(MySqlInsertBuilder, _a89, "MySqlInsertBuilder");
    MySqlInsert = class extends QueryPromise {
      constructor(table, values, ignore, session2, dialect) {
        super();
        __publicField(this, "session");
        __publicField(this, "dialect");
        __publicField(this, "config");
        __publicField(this, "execute", (placeholderValues) => {
          return this.prepare().execute(placeholderValues);
        });
        __publicField(this, "createIterator", () => {
          const self = this;
          return async function* (placeholderValues) {
            yield* self.prepare().iterator(placeholderValues);
          };
        });
        __publicField(this, "iterator", this.createIterator());
        this.session = session2;
        this.dialect = dialect;
        this.config = { table, values, ignore };
      }
      onDuplicateKeyUpdate(config) {
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
        this.config.onConflict = sql`update ${setSql}`;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildInsertQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      prepare() {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0);
      }
    };
    _a90 = entityKind;
    __publicField(MySqlInsert, _a90, "MySqlInsert");
    MySqlDialect = class {
      async migrate(migrations, session2, config) {
        const migrationsTable = config.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			create table if not exists ${sql.identifier(migrationsTable)} (
				id serial primary key,
				hash text not null,
				created_at bigint
			)
		`;
        await session2.execute(migrationTableCreate);
        const dbMigrations = await session2.all(sql`select id, hash, created_at from ${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
        const lastDbMigration = dbMigrations[0];
        await session2.transaction(async (tx) => {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                await tx.execute(sql.raw(stmt));
              }
              await tx.execute(sql`insert into ${sql.identifier(migrationsTable)} (\`hash\`, \`created_at\`) values(${migration.hash}, ${migration.folderMillis})`);
            }
          }
        });
      }
      escapeName(name3) {
        return `\`${name3}\``;
      }
      escapeParam(_num) {
        return `?`;
      }
      escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
      }
      buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`delete from ${table}${whereSql}${returningSql}`;
      }
      buildUpdateSet(table, set2) {
        const setEntries = Object.entries(set2);
        const setSize = setEntries.length;
        return sql.join(setEntries.flatMap(([colName, value], i2) => {
          const col = table[Table.Symbol.Columns][colName];
          const res = sql`${sql.identifier(col.name)} = ${value}`;
          if (i2 < setSize - 1) {
            return [res, sql.raw(", ")];
          }
          return [res];
        }));
      }
      buildUpdateQuery({ table, set: set2, where, returning }) {
        const setSql = this.buildUpdateSet(table, set2);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`update ${table} set ${setSql}${whereSql}${returningSql}`;
      }
      /**
       * Builds selection SQL with provided fields/expressions
       *
       * Examples:
       *
       * `select <selection> from`
       *
       * `insert ... returning <selection>`
       *
       * If `isSingleTable` is true, then columns won't be prefixed with table name
       */
      buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields.flatMap(({ field }, i2) => {
          const chunk = [];
          if (is(field, SQL.Aliased) && field.isSelectionField) {
            chunk.push(sql.identifier(field.fieldAlias));
          } else if (is(field, SQL.Aliased) || is(field, SQL)) {
            const query = is(field, SQL.Aliased) ? field.sql : field;
            if (isSingleTable) {
              chunk.push(new SQL(query.queryChunks.map((c) => {
                if (is(c, MySqlColumn)) {
                  return sql.identifier(c.name);
                }
                return c;
              })));
            } else {
              chunk.push(query);
            }
            if (is(field, SQL.Aliased)) {
              chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
            }
          } else if (is(field, Column)) {
            if (isSingleTable) {
              chunk.push(sql.identifier(field.name));
            } else {
              chunk.push(field);
            }
          }
          if (i2 < columnsLen - 1) {
            chunk.push(sql`, `);
          }
          return chunk;
        });
        return sql.join(chunks);
      }
      buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset: offset2, lockingClause, distinct }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
          if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table[SubqueryConfig].alias : is(table, MySqlViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
            const tableName = getTableName(f.field.table);
            throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
          }
        }
        const isSingleTable = !joins || joins.length === 0;
        let withSql;
        if (withList?.length) {
          const withSqlChunks = [sql`with `];
          for (const [i2, w] of withList.entries()) {
            withSqlChunks.push(sql`${sql.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
            if (i2 < withList.length - 1) {
              withSqlChunks.push(sql`, `);
            }
          }
          withSqlChunks.push(sql` `);
          withSql = sql.join(withSqlChunks);
        }
        const distinctSql = distinct ? sql` distinct` : void 0;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
          if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
            return sql`${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;
          }
          return table;
        })();
        const joinsArray = [];
        if (joins) {
          for (const [index8, joinMeta] of joins.entries()) {
            if (index8 === 0) {
              joinsArray.push(sql` `);
            }
            const table2 = joinMeta.table;
            const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
            if (is(table2, MySqlTable)) {
              const tableName = table2[MySqlTable.Symbol.Name];
              const tableSchema = table2[MySqlTable.Symbol.Schema];
              const origTableName = table2[MySqlTable.Symbol.OriginalName];
              const alias = tableName === origTableName ? void 0 : joinMeta.alias;
              joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
            } else if (is(table2, View)) {
              const viewName = table2[ViewBaseConfig].name;
              const viewSchema = table2[ViewBaseConfig].schema;
              const origViewName = table2[ViewBaseConfig].originalName;
              const alias = viewName === origViewName ? void 0 : joinMeta.alias;
              joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
            } else {
              joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table2} on ${joinMeta.on}`);
            }
            if (index8 < joins.length - 1) {
              joinsArray.push(sql` `);
            }
          }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql` where ${where}` : void 0;
        const havingSql = having ? sql` having ${having}` : void 0;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
        }
        let groupBySql;
        if (groupBy && groupBy.length > 0) {
          groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
        }
        const limitSql = limit ? sql` limit ${limit}` : void 0;
        const offsetSql = offset2 ? sql` offset ${offset2}` : void 0;
        let lockingClausesSql;
        if (lockingClause) {
          const { config, strength } = lockingClause;
          lockingClausesSql = sql` for ${sql.raw(strength)}`;
          if (config.noWait) {
            lockingClausesSql.append(sql` no wait`);
          } else if (config.skipLocked) {
            lockingClausesSql.append(sql` skip locked`);
          }
        }
        return sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClausesSql}`;
      }
      buildInsertQuery({ table, values, ignore, onConflict }) {
        const valuesSqlList = [];
        const columns = table[Table.Symbol.Columns];
        const colEntries = Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
          const valueList = [];
          for (const [fieldName, col] of colEntries) {
            const colValue = value[fieldName];
            if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
              if (col.defaultFn !== void 0) {
                const defaultFnResult = col.defaultFn();
                const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                valueList.push(defaultValue);
              } else {
                valueList.push(sql`default`);
              }
            } else {
              valueList.push(colValue);
            }
          }
          valuesSqlList.push(valueList);
          if (valueIndex < values.length - 1) {
            valuesSqlList.push(sql`, `);
          }
        }
        const valuesSql = sql.join(valuesSqlList);
        const ignoreSql = ignore ? sql` ignore` : void 0;
        const onConflictSql = onConflict ? sql` on duplicate key ${onConflict}` : void 0;
        return sql`insert${ignoreSql} into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}`;
      }
      sqlToQuery(sql2) {
        return sql2.toQuery({
          escapeName: this.escapeName,
          escapeParam: this.escapeParam,
          escapeString: this.escapeString
        });
      }
      buildRelationalQuery({ fullSchema, schema: schema3, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn }) {
        let selection = [];
        let limit, offset2, orderBy, where;
        const joins = [];
        if (config === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key3, value]) => ({
            dbKey: value.name,
            tsKey: key3,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key3, value]) => [key3, aliasedTableColumn(value, tableAlias)]));
          if (config.where) {
            const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key3) => !selectedColumns.includes(key3));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config.with) {
            selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config.extras) {
            extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config.limit;
          offset2 = config.offset;
          for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema3, tableNamesMap, relation);
            const relationTableName = relation.referencedTable[Table.Symbol.Name];
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(...normalizedRelation.fields.map((field2, i2) => eq(aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
            const builtRelation = this.buildRelationalQuery({
              fullSchema,
              schema: schema3,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema3[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
            joins.push({
              on: sql`true`,
              table: new Subquery(builtRelation.sql, {}, relationTableAlias),
              alias: relationTableAlias,
              joinType: "left",
              lateral: true
            });
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`coalesce(json_arrayagg(${field}), json_array())`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field: field.as("data"),
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset2 !== void 0 || (orderBy?.length ?? 0) > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table, tableAlias),
              fields: {},
              fieldsFlat: [
                {
                  path: [],
                  field: sql.raw("*")
                },
                ...(orderBy?.length ?? 0) > 0 ? [{
                  path: [],
                  field: sql`row_number() over (order by ${sql.join(orderBy, sql`, `)})`
                }] : []
              ],
              where,
              limit,
              offset: offset2
            });
            where = void 0;
            limit = void 0;
            offset2 = void 0;
            orderBy = void 0;
          } else {
            result = aliasedTable(table, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, MySqlTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            joins,
            where,
            limit,
            offset: offset2,
            orderBy
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            joins,
            where,
            limit,
            offset: offset2,
            orderBy
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
      buildRelationalQueryWithoutLateralSubqueries({ fullSchema, schema: schema3, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn }) {
        let selection = [];
        let limit, offset2, orderBy = [], where;
        if (config === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key3, value]) => ({
            dbKey: value.name,
            tsKey: key3,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key3, value]) => [key3, aliasedTableColumn(value, tableAlias)]));
          if (config.where) {
            const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key3) => !selectedColumns.includes(key3));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config.with) {
            selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config.extras) {
            extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config.limit;
          offset2 = config.offset;
          for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema3, tableNamesMap, relation);
            const relationTableName = relation.referencedTable[Table.Symbol.Name];
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(...normalizedRelation.fields.map((field2, i2) => eq(aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
            const builtRelation = this.buildRelationalQueryWithoutLateralSubqueries({
              fullSchema,
              schema: schema3,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema3[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            let fieldSql = sql`(${builtRelation.sql})`;
            if (is(relation, Many)) {
              fieldSql = sql`coalesce(${fieldSql}, json_array())`;
            }
            const field = fieldSql.as(selectedRelationTsKey);
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`);
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_array(${sql.join(selection.map(({ field: field2 }) => is(field2, MySqlColumn) ? sql.identifier(field2.name) : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`json_arrayagg(${field})`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field,
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset2 !== void 0 || orderBy.length > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table, tableAlias),
              fields: {},
              fieldsFlat: [
                {
                  path: [],
                  field: sql.raw("*")
                },
                ...orderBy.length > 0 ? [{
                  path: [],
                  field: sql`row_number() over (order by ${sql.join(orderBy, sql`, `)})`
                }] : []
              ],
              where,
              limit,
              offset: offset2
            });
            where = void 0;
            limit = void 0;
            offset2 = void 0;
            orderBy = void 0;
          } else {
            result = aliasedTable(table, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, MySqlTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            where,
            limit,
            offset: offset2,
            orderBy
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            where,
            limit,
            offset: offset2,
            orderBy
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
    };
    _a91 = entityKind;
    __publicField(MySqlDialect, _a91, "MySqlDialect");
    MySqlSelectBuilder = class {
      constructor(config) {
        __publicField(this, "fields");
        __publicField(this, "session");
        __publicField(this, "dialect");
        __publicField(this, "withList", []);
        __publicField(this, "distinct");
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        if (config.withList) {
          this.withList = config.withList;
        }
        this.distinct = config.distinct;
      }
      from(source2) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
          fields = this.fields;
        } else if (is(source2, Subquery)) {
          fields = Object.fromEntries(Object.keys(source2[SubqueryConfig].selection).map((key3) => [key3, source2[key3]]));
        } else if (is(source2, MySqlViewBase)) {
          fields = source2[ViewBaseConfig].selectedFields;
        } else if (is(source2, SQL)) {
          fields = {};
        } else {
          fields = getTableColumns(source2);
        }
        return new MySqlSelect({
          table: source2,
          fields,
          isPartialSelect,
          session: this.session,
          dialect: this.dialect,
          withList: this.withList,
          distinct: this.distinct
        });
      }
    };
    _a92 = entityKind;
    __publicField(MySqlSelectBuilder, _a92, "MySqlSelectBuilder");
    MySqlSelectQueryBuilder = class extends TypedQueryBuilder {
      constructor({ table, fields, isPartialSelect, session: session2, dialect, withList, distinct }) {
        super();
        __publicField(this, "_");
        __publicField(this, "config");
        __publicField(this, "joinsNotNullableMap");
        __publicField(this, "tableName");
        __publicField(this, "isPartialSelect");
        /** @internal */
        __publicField(this, "session");
        __publicField(this, "dialect");
        __publicField(this, "leftJoin", this.createJoin("left"));
        __publicField(this, "rightJoin", this.createJoin("right"));
        __publicField(this, "innerJoin", this.createJoin("inner"));
        __publicField(this, "fullJoin", this.createJoin("full"));
        this.config = {
          withList,
          table,
          fields: { ...fields },
          distinct
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session2;
        this.dialect = dialect;
        this._ = {
          selectedFields: fields
        };
        this.tableName = getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      }
      createJoin(joinType) {
        return (table, on) => {
          const baseTableName = this.tableName;
          const tableName = getTableLikeName(table);
          if (typeof tableName === "string" && this.config.joins?.some((join2) => join2.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (!this.isPartialSelect) {
            if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
              this.config.fields = {
                [baseTableName]: this.config.fields
              };
            }
            if (typeof tableName === "string" && !is(table, SQL)) {
              const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
              this.config.fields[tableName] = selection;
            }
          }
          if (typeof on === "function") {
            on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
          }
          if (!this.config.joins) {
            this.config.joins = [];
          }
          this.config.joins.push({ on, table, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key3]) => [key3, false]));
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key3]) => [key3, false]));
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      where(where) {
        if (typeof where === "function") {
          where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
        }
        this.config.where = where;
        return this;
      }
      having(having) {
        if (typeof having === "function") {
          having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
        }
        this.config.having = having;
        return this;
      }
      groupBy(...columns) {
        if (typeof columns[0] === "function") {
          const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
          this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        } else {
          this.config.groupBy = columns;
        }
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
          this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
        } else {
          this.config.orderBy = columns;
        }
        return this;
      }
      limit(limit) {
        this.config.limit = limit;
        return this;
      }
      offset(offset2) {
        this.config.offset = offset2;
        return this;
      }
      for(strength, config = {}) {
        this.config.lockingClause = { strength, config };
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildSelectQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      as(alias) {
        return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
    _a93 = entityKind;
    __publicField(MySqlSelectQueryBuilder, _a93, "MySqlSelectQueryBuilder");
    MySqlSelect = class extends MySqlSelectQueryBuilder {
      constructor() {
        super(...arguments);
        __publicField(this, "execute", (placeholderValues) => {
          return this.prepare().execute(placeholderValues);
        });
        __publicField(this, "createIterator", () => {
          const self = this;
          return async function* (placeholderValues) {
            yield* self.prepare().iterator(placeholderValues);
          };
        });
        __publicField(this, "iterator", this.createIterator());
      }
      prepare() {
        if (!this.session) {
          throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
        }
        const fieldsList = orderSelectedFields(this.config.fields);
        const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), fieldsList);
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
      }
    };
    _a94 = entityKind;
    __publicField(MySqlSelect, _a94, "MySqlSelect");
    applyMixins(MySqlSelect, [QueryPromise]);
    QueryBuilder2 = class {
      constructor() {
        __publicField(this, "dialect");
      }
      $with(alias) {
        const queryBuilder = this;
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(queryBuilder);
            }
            return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
          }
        };
      }
      with(...queries) {
        const self = this;
        function select(fields) {
          return new MySqlSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries
          });
        }
        function selectDistinct(fields) {
          return new MySqlSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries,
            distinct: true
          });
        }
        return { select, selectDistinct };
      }
      select(fields) {
        return new MySqlSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
      }
      selectDistinct(fields) {
        return new MySqlSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: true
        });
      }
      // Lazy load dialect to avoid circular dependency
      getDialect() {
        if (!this.dialect) {
          this.dialect = new MySqlDialect();
        }
        return this.dialect;
      }
    };
    _a95 = entityKind;
    __publicField(QueryBuilder2, _a95, "MySqlQueryBuilder");
    RelationalQueryBuilder = class {
      constructor(fullSchema, schema3, tableNamesMap, table, tableConfig, dialect, session2, mode) {
        __publicField(this, "fullSchema");
        __publicField(this, "schema");
        __publicField(this, "tableNamesMap");
        __publicField(this, "table");
        __publicField(this, "tableConfig");
        __publicField(this, "dialect");
        __publicField(this, "session");
        __publicField(this, "mode");
        this.fullSchema = fullSchema;
        this.schema = schema3;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session2;
        this.mode = mode;
      }
      findMany(config) {
        return new MySqlRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many", this.mode);
      }
      findFirst(config) {
        return new MySqlRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first", this.mode);
      }
    };
    _a96 = entityKind;
    __publicField(RelationalQueryBuilder, _a96, "MySqlRelationalQueryBuilder");
    MySqlRelationalQuery = class extends QueryPromise {
      constructor(fullSchema, schema3, tableNamesMap, table, tableConfig, dialect, session2, config, queryMode, mode) {
        super();
        __publicField(this, "fullSchema");
        __publicField(this, "schema");
        __publicField(this, "tableNamesMap");
        __publicField(this, "table");
        __publicField(this, "tableConfig");
        __publicField(this, "dialect");
        __publicField(this, "session");
        __publicField(this, "config");
        __publicField(this, "queryMode");
        __publicField(this, "mode");
        this.fullSchema = fullSchema;
        this.schema = schema3;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session2;
        this.config = config;
        this.queryMode = queryMode;
        this.mode = mode;
      }
      prepare() {
        const { query, builtQuery } = this._toSQL();
        return this.session.prepareQuery(builtQuery, void 0, (rawRows) => {
          const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection));
          if (this.queryMode === "first") {
            return rows[0];
          }
          return rows;
        });
      }
      _toSQL() {
        const query = this.mode === "planetscale" ? this.dialect.buildRelationalQueryWithoutLateralSubqueries({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        }) : this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { builtQuery, query };
      }
      toSQL() {
        return this._toSQL().builtQuery;
      }
      execute() {
        return this.prepare().execute();
      }
    };
    _a97 = entityKind;
    __publicField(MySqlRelationalQuery, _a97, "MySqlRelationalQuery");
    MySqlDatabase = class {
      constructor(dialect, session2, schema3, mode) {
        __publicField(this, "dialect");
        __publicField(this, "session");
        __publicField(this, "mode");
        __publicField(this, "query");
        this.dialect = dialect;
        this.session = session2;
        this.mode = mode;
        this._ = schema3 ? { schema: schema3.schema, tableNamesMap: schema3.tableNamesMap } : { schema: void 0, tableNamesMap: {} };
        this.query = {};
        if (this._.schema) {
          for (const [tableName, columns] of Object.entries(this._.schema)) {
            this.query[tableName] = new RelationalQueryBuilder(schema3.fullSchema, this._.schema, this._.tableNamesMap, schema3.fullSchema[tableName], columns, dialect, session2, this.mode);
          }
        }
      }
      $with(alias) {
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(new QueryBuilder2());
            }
            return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
          }
        };
      }
      with(...queries) {
        const self = this;
        function select(fields) {
          return new MySqlSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries
          });
        }
        function selectDistinct(fields) {
          return new MySqlSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: true
          });
        }
        return { select, selectDistinct };
      }
      select(fields) {
        return new MySqlSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
      }
      selectDistinct(fields) {
        return new MySqlSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: true
        });
      }
      update(table) {
        return new MySqlUpdateBuilder(table, this.session, this.dialect);
      }
      insert(table) {
        return new MySqlInsertBuilder(table, this.session, this.dialect);
      }
      delete(table) {
        return new MySqlDelete(table, this.session, this.dialect);
      }
      execute(query) {
        return this.session.execute(query.getSQL());
      }
      transaction(transaction, config) {
        return this.session.transaction(transaction, config);
      }
    };
    _a98 = entityKind;
    __publicField(MySqlDatabase, _a98, "MySqlDatabase");
    PreparedQuery = class {
      constructor() {
        /** @internal */
        __publicField(this, "joinsNotNullableMap");
      }
    };
    _a99 = entityKind;
    __publicField(PreparedQuery, _a99, "MySqlPreparedQuery");
    MySqlSession = class {
      constructor(dialect) {
        __publicField(this, "dialect");
        this.dialect = dialect;
      }
      execute(query) {
        return this.prepareQuery(this.dialect.sqlToQuery(query), void 0).execute();
      }
      getSetTransactionSQL(config) {
        const parts = [];
        if (config.isolationLevel) {
          parts.push(`isolation level ${config.isolationLevel}`);
        }
        return parts.length ? sql.join(["set transaction ", parts.join(" ")]) : void 0;
      }
      getStartTransactionSQL(config) {
        const parts = [];
        if (config.withConsistentSnapshot) {
          parts.push("with consistent snapshot");
        }
        if (config.accessMode) {
          parts.push(config.accessMode);
        }
        return parts.length ? sql.join(["start transaction ", parts.join(" ")]) : void 0;
      }
    };
    _a100 = entityKind;
    __publicField(MySqlSession, _a100, "MySqlSession");
    MySqlTransaction = class extends MySqlDatabase {
      constructor(dialect, session2, schema3, nestedIndex, mode) {
        super(dialect, session2, schema3, mode);
        __publicField(this, "schema");
        __publicField(this, "nestedIndex");
        this.schema = schema3;
        this.nestedIndex = nestedIndex;
      }
      rollback() {
        throw new TransactionRollbackError();
      }
    };
    _a101 = entityKind;
    __publicField(MySqlTransaction, _a101, "MySqlTransaction");
    MySqlUpdateBuilder = class {
      constructor(table, session2, dialect) {
        __publicField(this, "table");
        __publicField(this, "session");
        __publicField(this, "dialect");
        this.table = table;
        this.session = session2;
        this.dialect = dialect;
      }
      set(values) {
        return new MySqlUpdate(this.table, mapUpdateSet(this.table, values), this.session, this.dialect);
      }
    };
    _a102 = entityKind;
    __publicField(MySqlUpdateBuilder, _a102, "MySqlUpdateBuilder");
    MySqlUpdate = class extends QueryPromise {
      constructor(table, set2, session2, dialect) {
        super();
        __publicField(this, "session");
        __publicField(this, "dialect");
        __publicField(this, "config");
        __publicField(this, "execute", (placeholderValues) => {
          return this.prepare().execute(placeholderValues);
        });
        __publicField(this, "createIterator", () => {
          const self = this;
          return async function* (placeholderValues) {
            yield* self.prepare().iterator(placeholderValues);
          };
        });
        __publicField(this, "iterator", this.createIterator());
        this.session = session2;
        this.dialect = dialect;
        this.config = { set: set2, table };
      }
      where(where) {
        this.config.where = where;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      prepare() {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
      }
    };
    _a103 = entityKind;
    __publicField(MySqlUpdate, _a103, "MySqlUpdate");
    ViewBuilderCore = class {
      constructor(name3, schema3) {
        __publicField(this, "name");
        __publicField(this, "schema");
        __publicField(this, "config", {});
        this.name = name3;
        this.schema = schema3;
      }
      algorithm(algorithm) {
        this.config.algorithm = algorithm;
        return this;
      }
      definer(definer) {
        this.config.definer = definer;
        return this;
      }
      sqlSecurity(sqlSecurity) {
        this.config.sqlSecurity = sqlSecurity;
        return this;
      }
      withCheckOption(withCheckOption) {
        this.config.withCheckOption = withCheckOption ?? "cascaded";
        return this;
      }
    };
    _a104 = entityKind;
    __publicField(ViewBuilderCore, _a104, "MySqlViewBuilder");
    ViewBuilder2 = class extends ViewBuilderCore {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder2());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new MySqlView({
          mysqlConfig: this.config,
          config: {
            name: this.name,
            schema: this.schema,
            selectedFields: aliasedSelection,
            query: qb.getSQL().inlineParams()
          }
        }), selectionProxy);
      }
    };
    _a105 = entityKind;
    __publicField(ViewBuilder2, _a105, "MySqlViewBuilder");
    ManualViewBuilder2 = class extends ViewBuilderCore {
      constructor(name3, columns, schema3) {
        super(name3, schema3);
        __publicField(this, "columns");
        this.columns = getTableColumns(mysqlTable(name3, columns));
      }
      existing() {
        return new Proxy(new MySqlView({
          mysqlConfig: void 0,
          config: {
            name: this.name,
            schema: this.schema,
            selectedFields: this.columns,
            query: void 0
          }
        }), new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        }));
      }
      as(query) {
        return new Proxy(new MySqlView({
          mysqlConfig: this.config,
          config: {
            name: this.name,
            schema: this.schema,
            selectedFields: this.columns,
            query: query.inlineParams()
          }
        }), new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        }));
      }
    };
    _a106 = entityKind;
    __publicField(ManualViewBuilder2, _a106, "MySqlManualViewBuilder");
    MySqlViewBase = class extends View {
    };
    _a107 = entityKind;
    __publicField(MySqlViewBase, _a107, "MySqlViewBase");
    MySqlViewConfig = Symbol.for("drizzle:MySqlViewConfig");
    MySqlView = class extends MySqlViewBase {
      constructor({ mysqlConfig, config }) {
        super(config);
        __publicField(this, _b9);
        this[MySqlViewConfig] = mysqlConfig;
      }
    };
    _a108 = entityKind, _b9 = MySqlViewConfig;
    __publicField(MySqlView, _a108, "MySqlView");
  }
});

// node_modules/.pnpm/drizzle-orm@0.28.6_@planetscale+database@1.11.0/node_modules/drizzle-orm/planetscale-serverless/index.mjs
function drizzle(client, config = {}) {
  const dialect = new MySqlDialect();
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger();
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema3;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema3 = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session2 = new PlanetscaleSession(client, dialect, void 0, schema3, { logger });
  return new MySqlDatabase(dialect, session2, schema3, "planetscale");
}
var _a109, PlanetScalePreparedQuery, _a110, _PlanetscaleSession, PlanetscaleSession, _a111, _PlanetScaleTransaction, PlanetScaleTransaction;
var init_planetscale_serverless = __esm({
  "node_modules/.pnpm/drizzle-orm@0.28.6_@planetscale+database@1.11.0/node_modules/drizzle-orm/planetscale-serverless/index.mjs"() {
    init_drizzle_orm();
    init_view_23898f21();
    init_alias_cf8e03cd();
    PlanetScalePreparedQuery = class extends PreparedQuery {
      constructor(client, queryString, params, logger, fields, customResultMapper) {
        super();
        __publicField(this, "client");
        __publicField(this, "queryString");
        __publicField(this, "params");
        __publicField(this, "logger");
        __publicField(this, "fields");
        __publicField(this, "customResultMapper");
        __publicField(this, "rawQuery", { as: "object" });
        __publicField(this, "query", { as: "array" });
        this.client = client;
        this.queryString = queryString;
        this.params = params;
        this.logger = logger;
        this.fields = fields;
        this.customResultMapper = customResultMapper;
      }
      async execute(placeholderValues = {}) {
        const params = fillPlaceholders(this.params, placeholderValues);
        this.logger.logQuery(this.queryString, params);
        const { fields, client, queryString, rawQuery, query, joinsNotNullableMap, customResultMapper } = this;
        if (!fields && !customResultMapper) {
          return client.execute(queryString, params, rawQuery);
        }
        const { rows } = await client.execute(queryString, params, query);
        if (customResultMapper) {
          return customResultMapper(rows);
        }
        return rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      }
      iterator(_placeholderValues) {
        throw new Error("Streaming is not supported by the PlanetScale Serverless driver");
      }
    };
    _a109 = entityKind;
    __publicField(PlanetScalePreparedQuery, _a109, "PlanetScalePreparedQuery");
    _PlanetscaleSession = class _PlanetscaleSession extends MySqlSession {
      constructor(baseClient, dialect, tx, schema3, options2 = {}) {
        super(dialect);
        __publicField(this, "baseClient");
        __publicField(this, "schema");
        __publicField(this, "options");
        __publicField(this, "logger");
        __publicField(this, "client");
        this.baseClient = baseClient;
        this.schema = schema3;
        this.options = options2;
        this.client = tx ?? baseClient;
        this.logger = options2.logger ?? new NoopLogger();
      }
      prepareQuery(query, fields, customResultMapper) {
        return new PlanetScalePreparedQuery(this.client, query.sql, query.params, this.logger, fields, customResultMapper);
      }
      async query(query, params) {
        this.logger.logQuery(query, params);
        return await this.client.execute(query, params, { as: "array" });
      }
      async queryObjects(query, params) {
        return this.client.execute(query, params, { as: "object" });
      }
      all(query) {
        const querySql = this.dialect.sqlToQuery(query);
        this.logger.logQuery(querySql.sql, querySql.params);
        return this.client.execute(querySql.sql, querySql.params, { as: "object" }).then((eQuery) => eQuery.rows);
      }
      transaction(transaction) {
        return this.baseClient.transaction((pstx) => {
          const session2 = new _PlanetscaleSession(this.baseClient, this.dialect, pstx, this.schema, this.options);
          const tx = new PlanetScaleTransaction(this.dialect, session2, this.schema);
          return transaction(tx);
        });
      }
    };
    _a110 = entityKind;
    __publicField(_PlanetscaleSession, _a110, "PlanetscaleSession");
    PlanetscaleSession = _PlanetscaleSession;
    _PlanetScaleTransaction = class _PlanetScaleTransaction extends MySqlTransaction {
      constructor(dialect, session2, schema3, nestedIndex = 0) {
        super(dialect, session2, schema3, nestedIndex, "planetscale");
      }
      async transaction(transaction) {
        const savepointName = `sp${this.nestedIndex + 1}`;
        const tx = new _PlanetScaleTransaction(this.dialect, this.session, this.schema, this.nestedIndex + 1);
        await tx.execute(sql.raw(`savepoint ${savepointName}`));
        try {
          const result = await transaction(tx);
          await tx.execute(sql.raw(`release savepoint ${savepointName}`));
          return result;
        } catch (err) {
          await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));
          throw err;
        }
      }
    };
    _a111 = entityKind;
    __publicField(_PlanetScaleTransaction, _a111, "PlanetScaleTransaction");
    PlanetScaleTransaction = _PlanetScaleTransaction;
  }
});

// node_modules/.pnpm/drizzle-orm@0.28.6_@planetscale+database@1.11.0/node_modules/drizzle-orm/mysql-core/index.mjs
function bigint(name3, config) {
  if (config.mode === "number") {
    return new MySqlBigInt53Builder(name3);
  }
  return new MySqlBigInt64Builder(name3);
}
function mysqlEnum(name3, values) {
  if (values.length === 0) {
    throw new Error(`You have an empty array for "${name3}" enum values`);
  }
  return new MySqlEnumColumnBuilder(name3, values);
}
function text(name3, config = {}) {
  return new MySqlTextBuilder(name3, "text", config);
}
function timestamp(name3, config = {}) {
  if (config.mode === "string") {
    return new MySqlTimestampStringBuilder(name3, config);
  }
  return new MySqlTimestampBuilder(name3, config);
}
function varchar(name3, config) {
  return new MySqlVarCharBuilder(name3, config);
}
var _a112, MySqlBigInt53Builder, _a113, MySqlBigInt53, _a114, MySqlBigInt64Builder, _a115, MySqlBigInt64, _a116, MySqlBinaryBuilder, _a117, MySqlBinary, _a118, MySqlBooleanBuilder, _a119, MySqlBoolean, _a120, MySqlCharBuilder, _a121, MySqlChar, _a122, MySqlCustomColumnBuilder, _a123, MySqlCustomColumn, _a124, MySqlDateBuilder, _a125, MySqlDate, _a126, MySqlDateStringBuilder, _a127, MySqlDateString, _a128, MySqlDateTimeBuilder, _a129, MySqlDateTime, _a130, MySqlDateTimeStringBuilder, _a131, MySqlDateTimeString, _a132, MySqlDecimalBuilder, _a133, MySqlDecimal, _a134, MySqlDoubleBuilder, _a135, MySqlDouble, _a136, MySqlEnumColumnBuilder, _a137, MySqlEnumColumn, _a138, MySqlFloatBuilder, _a139, MySqlFloat, _a140, MySqlIntBuilder, _a141, MySqlInt, _a142, MySqlJsonBuilder, _a143, MySqlJson, _a144, MySqlMediumIntBuilder, _a145, MySqlMediumInt, _a146, MySqlRealBuilder, _a147, MySqlReal, _a148, MySqlSerialBuilder, _a149, MySqlSerial, _a150, MySqlSmallIntBuilder, _a151, MySqlSmallInt, _a152, MySqlTextBuilder, _a153, MySqlText, _a154, MySqlTimeBuilder, _a155, MySqlTime, _a156, MySqlDateColumnBaseBuilder, _a157, MySqlDateBaseColumn, _a158, MySqlTimestampBuilder, _a159, MySqlTimestamp, _a160, MySqlTimestampStringBuilder, _a161, MySqlTimestampString, _a162, MySqlTinyIntBuilder, _a163, MySqlTinyInt, _a164, MySqlVarBinaryBuilder, _a165, MySqlVarBinary, _a166, MySqlVarCharBuilder, _a167, MySqlVarChar, _a168, MySqlYearBuilder, _a169, MySqlYear, _a170, CheckBuilder2, _a171, Check2, _a172, IndexBuilderOn2, _a173, IndexBuilder2, _a174, Index2, _a175, PrimaryKeyBuilder2, _a176, PrimaryKey2, _a177, MySqlSchema;
var init_mysql_core = __esm({
  "node_modules/.pnpm/drizzle-orm@0.28.6_@planetscale+database@1.11.0/node_modules/drizzle-orm/mysql-core/index.mjs"() {
    init_alias_cf8e03cd();
    init_view_23898f21();
    init_view_23898f21();
    MySqlBigInt53Builder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3) {
        super(name3, "number", "MySqlBigInt53");
      }
      /** @internal */
      build(table) {
        return new MySqlBigInt53(table, this.config);
      }
    };
    _a112 = entityKind;
    __publicField(MySqlBigInt53Builder, _a112, "MySqlBigInt53Builder");
    MySqlBigInt53 = class extends MySqlColumnWithAutoIncrement {
      getSQLType() {
        return "bigint";
      }
      mapFromDriverValue(value) {
        if (typeof value === "number") {
          return value;
        }
        return Number(value);
      }
    };
    _a113 = entityKind;
    __publicField(MySqlBigInt53, _a113, "MySqlBigInt53");
    MySqlBigInt64Builder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3) {
        super(name3, "bigint", "MySqlBigInt64");
      }
      /** @internal */
      build(table) {
        return new MySqlBigInt64(table, this.config);
      }
    };
    _a114 = entityKind;
    __publicField(MySqlBigInt64Builder, _a114, "MySqlBigInt64Builder");
    MySqlBigInt64 = class extends MySqlColumnWithAutoIncrement {
      getSQLType() {
        return "bigint";
      }
      // eslint-disable-next-line unicorn/prefer-native-coercion-functions
      mapFromDriverValue(value) {
        return BigInt(value);
      }
    };
    _a115 = entityKind;
    __publicField(MySqlBigInt64, _a115, "MySqlBigInt64");
    MySqlBinaryBuilder = class extends MySqlColumnBuilder {
      constructor(name3, length) {
        super(name3, "string", "MySqlBinary");
        this.config.length = length;
      }
      /** @internal */
      build(table) {
        return new MySqlBinary(table, this.config);
      }
    };
    _a116 = entityKind;
    __publicField(MySqlBinaryBuilder, _a116, "MySqlBinaryBuilder");
    MySqlBinary = class extends MySqlColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "length", this.config.length);
      }
      getSQLType() {
        return this.length === void 0 ? `binary` : `binary(${this.length})`;
      }
    };
    _a117 = entityKind;
    __publicField(MySqlBinary, _a117, "MySqlBinary");
    MySqlBooleanBuilder = class extends MySqlColumnBuilder {
      constructor(name3) {
        super(name3, "boolean", "MySqlBoolean");
      }
      /** @internal */
      build(table) {
        return new MySqlBoolean(table, this.config);
      }
    };
    _a118 = entityKind;
    __publicField(MySqlBooleanBuilder, _a118, "MySqlBooleanBuilder");
    MySqlBoolean = class extends MySqlColumn {
      getSQLType() {
        return "boolean";
      }
      mapFromDriverValue(value) {
        if (typeof value === "boolean") {
          return value;
        }
        return value === 1;
      }
    };
    _a119 = entityKind;
    __publicField(MySqlBoolean, _a119, "MySqlBoolean");
    MySqlCharBuilder = class extends MySqlColumnBuilder {
      constructor(name3, config) {
        super(name3, "string", "MySqlChar");
        this.config.length = config.length;
        this.config.enum = config.enum;
      }
      /** @internal */
      build(table) {
        return new MySqlChar(table, this.config);
      }
    };
    _a120 = entityKind;
    __publicField(MySqlCharBuilder, _a120, "MySqlCharBuilder");
    MySqlChar = class extends MySqlColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "length", this.config.length);
        __publicField(this, "enumValues", this.config.enum);
      }
      getSQLType() {
        return this.length === void 0 ? `char` : `char(${this.length})`;
      }
    };
    _a121 = entityKind;
    __publicField(MySqlChar, _a121, "MySqlChar");
    MySqlCustomColumnBuilder = class extends MySqlColumnBuilder {
      constructor(name3, fieldConfig, customTypeParams) {
        super(name3, "custom", "MySqlCustomColumn");
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
      }
      /** @internal */
      build(table) {
        return new MySqlCustomColumn(table, this.config);
      }
    };
    _a122 = entityKind;
    __publicField(MySqlCustomColumnBuilder, _a122, "MySqlCustomColumnBuilder");
    MySqlCustomColumn = class extends MySqlColumn {
      constructor(table, config) {
        super(table, config);
        __publicField(this, "sqlName");
        __publicField(this, "mapTo");
        __publicField(this, "mapFrom");
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
      }
      getSQLType() {
        return this.sqlName;
      }
      mapFromDriverValue(value) {
        return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
      }
      mapToDriverValue(value) {
        return typeof this.mapTo === "function" ? this.mapTo(value) : value;
      }
    };
    _a123 = entityKind;
    __publicField(MySqlCustomColumn, _a123, "MySqlCustomColumn");
    MySqlDateBuilder = class extends MySqlColumnBuilder {
      constructor(name3) {
        super(name3, "date", "MySqlDate");
      }
      /** @internal */
      build(table) {
        return new MySqlDate(table, this.config);
      }
    };
    _a124 = entityKind;
    __publicField(MySqlDateBuilder, _a124, "MySqlDateBuilder");
    MySqlDate = class extends MySqlColumn {
      constructor(table, config) {
        super(table, config);
      }
      getSQLType() {
        return `date`;
      }
      mapFromDriverValue(value) {
        return new Date(value);
      }
    };
    _a125 = entityKind;
    __publicField(MySqlDate, _a125, "MySqlDate");
    MySqlDateStringBuilder = class extends MySqlColumnBuilder {
      constructor(name3) {
        super(name3, "string", "MySqlDateString");
      }
      /** @internal */
      build(table) {
        return new MySqlDateString(table, this.config);
      }
    };
    _a126 = entityKind;
    __publicField(MySqlDateStringBuilder, _a126, "MySqlDateStringBuilder");
    MySqlDateString = class extends MySqlColumn {
      constructor(table, config) {
        super(table, config);
      }
      getSQLType() {
        return `date`;
      }
    };
    _a127 = entityKind;
    __publicField(MySqlDateString, _a127, "MySqlDateString");
    MySqlDateTimeBuilder = class extends MySqlColumnBuilder {
      constructor(name3, config) {
        super(name3, "date", "MySqlDateTime");
        this.config.fsp = config?.fsp;
      }
      /** @internal */
      build(table) {
        return new MySqlDateTime(table, this.config);
      }
    };
    _a128 = entityKind;
    __publicField(MySqlDateTimeBuilder, _a128, "MySqlDateTimeBuilder");
    MySqlDateTime = class extends MySqlColumn {
      constructor(table, config) {
        super(table, config);
        __publicField(this, "fsp");
        this.fsp = config.fsp;
      }
      getSQLType() {
        const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
        return `datetime${precision}`;
      }
      mapToDriverValue(value) {
        return value.toISOString().replace("T", " ").replace("Z", "");
      }
      mapFromDriverValue(value) {
        return /* @__PURE__ */ new Date(value.replace(" ", "T") + "Z");
      }
    };
    _a129 = entityKind;
    __publicField(MySqlDateTime, _a129, "MySqlDateTime");
    MySqlDateTimeStringBuilder = class extends MySqlColumnBuilder {
      constructor(name3, config) {
        super(name3, "string", "MySqlDateTimeString");
        this.config.fsp = config?.fsp;
      }
      /** @internal */
      build(table) {
        return new MySqlDateTimeString(table, this.config);
      }
    };
    _a130 = entityKind;
    __publicField(MySqlDateTimeStringBuilder, _a130, "MySqlDateTimeStringBuilder");
    MySqlDateTimeString = class extends MySqlColumn {
      constructor(table, config) {
        super(table, config);
        __publicField(this, "fsp");
        this.fsp = config.fsp;
      }
      getSQLType() {
        const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
        return `datetime${precision}`;
      }
    };
    _a131 = entityKind;
    __publicField(MySqlDateTimeString, _a131, "MySqlDateTimeString");
    MySqlDecimalBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3, precision, scale) {
        super(name3, "string", "MySqlDecimal");
        this.config.precision = precision;
        this.config.scale = scale;
      }
      /** @internal */
      build(table) {
        return new MySqlDecimal(table, this.config);
      }
    };
    _a132 = entityKind;
    __publicField(MySqlDecimalBuilder, _a132, "MySqlDecimalBuilder");
    MySqlDecimal = class extends MySqlColumnWithAutoIncrement {
      constructor() {
        super(...arguments);
        __publicField(this, "precision", this.config.precision);
        __publicField(this, "scale", this.config.scale);
      }
      getSQLType() {
        if (this.precision !== void 0 && this.scale !== void 0) {
          return `decimal(${this.precision},${this.scale})`;
        } else if (this.precision === void 0) {
          return "decimal";
        } else {
          return `decimal(${this.precision})`;
        }
      }
    };
    _a133 = entityKind;
    __publicField(MySqlDecimal, _a133, "MySqlDecimal");
    MySqlDoubleBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3, config) {
        super(name3, "number", "MySqlDouble");
        this.config.precision = config?.precision;
        this.config.scale = config?.scale;
      }
      /** @internal */
      build(table) {
        return new MySqlDouble(table, this.config);
      }
    };
    _a134 = entityKind;
    __publicField(MySqlDoubleBuilder, _a134, "MySqlDoubleBuilder");
    MySqlDouble = class extends MySqlColumnWithAutoIncrement {
      constructor() {
        super(...arguments);
        __publicField(this, "precision", this.config.precision);
        __publicField(this, "scale", this.config.scale);
      }
      getSQLType() {
        if (this.precision !== void 0 && this.scale !== void 0) {
          return `double(${this.precision},${this.scale})`;
        } else if (this.precision === void 0) {
          return "double";
        } else {
          return `double(${this.precision})`;
        }
      }
    };
    _a135 = entityKind;
    __publicField(MySqlDouble, _a135, "MySqlDouble");
    MySqlEnumColumnBuilder = class extends MySqlColumnBuilder {
      constructor(name3, values) {
        super(name3, "string", "MySqlEnumColumn");
        this.config.enumValues = values;
      }
      /** @internal */
      build(table) {
        return new MySqlEnumColumn(table, this.config);
      }
    };
    _a136 = entityKind;
    __publicField(MySqlEnumColumnBuilder, _a136, "MySqlEnumColumnBuilder");
    MySqlEnumColumn = class extends MySqlColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "enumValues", this.config.enumValues);
      }
      getSQLType() {
        return `enum(${this.enumValues.map((value) => `'${value}'`).join(",")})`;
      }
    };
    _a137 = entityKind;
    __publicField(MySqlEnumColumn, _a137, "MySqlEnumColumn");
    MySqlFloatBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3) {
        super(name3, "number", "MySqlFloat");
      }
      /** @internal */
      build(table) {
        return new MySqlFloat(table, this.config);
      }
    };
    _a138 = entityKind;
    __publicField(MySqlFloatBuilder, _a138, "MySqlFloatBuilder");
    MySqlFloat = class extends MySqlColumnWithAutoIncrement {
      getSQLType() {
        return "float";
      }
    };
    _a139 = entityKind;
    __publicField(MySqlFloat, _a139, "MySqlFloat");
    MySqlIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3) {
        super(name3, "number", "MySqlInt");
      }
      /** @internal */
      build(table) {
        return new MySqlInt(table, this.config);
      }
    };
    _a140 = entityKind;
    __publicField(MySqlIntBuilder, _a140, "MySqlIntBuilder");
    MySqlInt = class extends MySqlColumnWithAutoIncrement {
      getSQLType() {
        return "int";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }
    };
    _a141 = entityKind;
    __publicField(MySqlInt, _a141, "MySqlInt");
    MySqlJsonBuilder = class extends MySqlColumnBuilder {
      constructor(name3) {
        super(name3, "json", "MySqlJson");
      }
      /** @internal */
      build(table) {
        return new MySqlJson(table, this.config);
      }
    };
    _a142 = entityKind;
    __publicField(MySqlJsonBuilder, _a142, "MySqlJsonBuilder");
    MySqlJson = class extends MySqlColumn {
      getSQLType() {
        return "json";
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
    };
    _a143 = entityKind;
    __publicField(MySqlJson, _a143, "MySqlJson");
    MySqlMediumIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3) {
        super(name3, "number", "MySqlMediumInt");
      }
      /** @internal */
      build(table) {
        return new MySqlMediumInt(table, this.config);
      }
    };
    _a144 = entityKind;
    __publicField(MySqlMediumIntBuilder, _a144, "MySqlMediumIntBuilder");
    MySqlMediumInt = class extends MySqlColumnWithAutoIncrement {
      getSQLType() {
        return "mediumint";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }
    };
    _a145 = entityKind;
    __publicField(MySqlMediumInt, _a145, "MySqlMediumInt");
    MySqlRealBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3, config) {
        super(name3, "number", "MySqlReal");
        this.config.precision = config?.precision;
        this.config.scale = config?.scale;
      }
      /** @internal */
      build(table) {
        return new MySqlReal(table, this.config);
      }
    };
    _a146 = entityKind;
    __publicField(MySqlRealBuilder, _a146, "MySqlRealBuilder");
    MySqlReal = class extends MySqlColumnWithAutoIncrement {
      constructor() {
        super(...arguments);
        __publicField(this, "precision", this.config.precision);
        __publicField(this, "scale", this.config.scale);
      }
      getSQLType() {
        if (this.precision !== void 0 && this.scale !== void 0) {
          return `real(${this.precision}, ${this.scale})`;
        } else if (this.precision === void 0) {
          return "real";
        } else {
          return `real(${this.precision})`;
        }
      }
    };
    _a147 = entityKind;
    __publicField(MySqlReal, _a147, "MySqlReal");
    MySqlSerialBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3) {
        super(name3, "number", "MySqlSerial");
        this.config.hasDefault = true;
        this.config.autoIncrement = true;
      }
      /** @internal */
      build(table) {
        return new MySqlSerial(table, this.config);
      }
    };
    _a148 = entityKind;
    __publicField(MySqlSerialBuilder, _a148, "MySqlSerialBuilder");
    MySqlSerial = class extends MySqlColumnWithAutoIncrement {
      getSQLType() {
        return "serial";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }
    };
    _a149 = entityKind;
    __publicField(MySqlSerial, _a149, "MySqlSerial");
    MySqlSmallIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3) {
        super(name3, "number", "MySqlSmallInt");
      }
      /** @internal */
      build(table) {
        return new MySqlSmallInt(table, this.config);
      }
    };
    _a150 = entityKind;
    __publicField(MySqlSmallIntBuilder, _a150, "MySqlSmallIntBuilder");
    MySqlSmallInt = class extends MySqlColumnWithAutoIncrement {
      getSQLType() {
        return "smallint";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }
    };
    _a151 = entityKind;
    __publicField(MySqlSmallInt, _a151, "MySqlSmallInt");
    MySqlTextBuilder = class extends MySqlColumnBuilder {
      constructor(name3, textType, config) {
        super(name3, "string", "MySqlText");
        this.config.textType = textType;
        this.config.enumValues = config.enum;
      }
      /** @internal */
      build(table) {
        return new MySqlText(table, this.config);
      }
    };
    _a152 = entityKind;
    __publicField(MySqlTextBuilder, _a152, "MySqlTextBuilder");
    MySqlText = class extends MySqlColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "textType", this.config.textType);
        __publicField(this, "enumValues", this.config.enumValues);
      }
      getSQLType() {
        return this.textType;
      }
    };
    _a153 = entityKind;
    __publicField(MySqlText, _a153, "MySqlText");
    MySqlTimeBuilder = class extends MySqlColumnBuilder {
      constructor(name3, config) {
        super(name3, "string", "MySqlTime");
        this.config.fsp = config?.fsp;
      }
      /** @internal */
      build(table) {
        return new MySqlTime(table, this.config);
      }
    };
    _a154 = entityKind;
    __publicField(MySqlTimeBuilder, _a154, "MySqlTimeBuilder");
    MySqlTime = class extends MySqlColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "fsp", this.config.fsp);
      }
      getSQLType() {
        const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
        return `time${precision}`;
      }
    };
    _a155 = entityKind;
    __publicField(MySqlTime, _a155, "MySqlTime");
    MySqlDateColumnBaseBuilder = class extends MySqlColumnBuilder {
      defaultNow() {
        return this.default(sql`(now())`);
      }
      // "on update now" also adds an implicit default value to the column - https://dev.mysql.com/doc/refman/8.0/en/timestamp-initialization.html
      onUpdateNow() {
        this.config.hasOnUpdateNow = true;
        this.config.hasDefault = true;
        return this;
      }
    };
    _a156 = entityKind;
    __publicField(MySqlDateColumnBaseBuilder, _a156, "MySqlDateColumnBuilder");
    MySqlDateBaseColumn = class extends MySqlColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "hasOnUpdateNow", this.config.hasOnUpdateNow);
      }
    };
    _a157 = entityKind;
    __publicField(MySqlDateBaseColumn, _a157, "MySqlDateColumn");
    MySqlTimestampBuilder = class extends MySqlDateColumnBaseBuilder {
      constructor(name3, config) {
        super(name3, "date", "MySqlTimestamp");
        this.config.fsp = config?.fsp;
      }
      /** @internal */
      build(table) {
        return new MySqlTimestamp(table, this.config);
      }
    };
    _a158 = entityKind;
    __publicField(MySqlTimestampBuilder, _a158, "MySqlTimestampBuilder");
    MySqlTimestamp = class extends MySqlDateBaseColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "fsp", this.config.fsp);
      }
      getSQLType() {
        const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
        return `timestamp${precision}`;
      }
      mapFromDriverValue(value) {
        return /* @__PURE__ */ new Date(value + "+0000");
      }
      mapToDriverValue(value) {
        return value.toISOString().slice(0, -1).replace("T", " ");
      }
    };
    _a159 = entityKind;
    __publicField(MySqlTimestamp, _a159, "MySqlTimestamp");
    MySqlTimestampStringBuilder = class extends MySqlDateColumnBaseBuilder {
      constructor(name3, config) {
        super(name3, "string", "MySqlTimestampString");
        this.config.fsp = config?.fsp;
      }
      /** @internal */
      build(table) {
        return new MySqlTimestampString(table, this.config);
      }
    };
    _a160 = entityKind;
    __publicField(MySqlTimestampStringBuilder, _a160, "MySqlTimestampStringBuilder");
    MySqlTimestampString = class extends MySqlDateBaseColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "fsp", this.config.fsp);
      }
      getSQLType() {
        const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
        return `timestamp${precision}`;
      }
    };
    _a161 = entityKind;
    __publicField(MySqlTimestampString, _a161, "MySqlTimestampString");
    MySqlTinyIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      constructor(name3) {
        super(name3, "number", "MySqlTinyInt");
      }
      /** @internal */
      build(table) {
        return new MySqlTinyInt(table, this.config);
      }
    };
    _a162 = entityKind;
    __publicField(MySqlTinyIntBuilder, _a162, "MySqlTinyIntBuilder");
    MySqlTinyInt = class extends MySqlColumnWithAutoIncrement {
      getSQLType() {
        return "tinyint";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }
    };
    _a163 = entityKind;
    __publicField(MySqlTinyInt, _a163, "MySqlTinyInt");
    MySqlVarBinaryBuilder = class extends MySqlColumnBuilder {
      /** @internal */
      constructor(name3, config) {
        super(name3, "string", "MySqlVarBinary");
        this.config.length = config?.length;
      }
      /** @internal */
      build(table) {
        return new MySqlVarBinary(table, this.config);
      }
    };
    _a164 = entityKind;
    __publicField(MySqlVarBinaryBuilder, _a164, "MySqlVarBinaryBuilder");
    MySqlVarBinary = class extends MySqlColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "length", this.config.length);
      }
      getSQLType() {
        return this.length === void 0 ? `varbinary` : `varbinary(${this.length})`;
      }
    };
    _a165 = entityKind;
    __publicField(MySqlVarBinary, _a165, "MySqlVarBinary");
    MySqlVarCharBuilder = class extends MySqlColumnBuilder {
      /** @internal */
      constructor(name3, config) {
        super(name3, "string", "MySqlVarChar");
        this.config.length = config.length;
        this.config.enum = config.enum;
      }
      /** @internal */
      build(table) {
        return new MySqlVarChar(table, this.config);
      }
    };
    _a166 = entityKind;
    __publicField(MySqlVarCharBuilder, _a166, "MySqlVarCharBuilder");
    MySqlVarChar = class extends MySqlColumn {
      constructor() {
        super(...arguments);
        __publicField(this, "length", this.config.length);
        __publicField(this, "enumValues", this.config.enum);
      }
      getSQLType() {
        return this.length === void 0 ? `varchar` : `varchar(${this.length})`;
      }
    };
    _a167 = entityKind;
    __publicField(MySqlVarChar, _a167, "MySqlVarChar");
    MySqlYearBuilder = class extends MySqlColumnBuilder {
      constructor(name3) {
        super(name3, "number", "MySqlYear");
      }
      /** @internal */
      build(table) {
        return new MySqlYear(table, this.config);
      }
    };
    _a168 = entityKind;
    __publicField(MySqlYearBuilder, _a168, "MySqlYearBuilder");
    MySqlYear = class extends MySqlColumn {
      getSQLType() {
        return `year`;
      }
    };
    _a169 = entityKind;
    __publicField(MySqlYear, _a169, "MySqlYear");
    CheckBuilder2 = class {
      constructor(name3, value) {
        __publicField(this, "name");
        __publicField(this, "value");
        __publicField(this, "brand");
        this.name = name3;
        this.value = value;
      }
      /** @internal */
      build(table) {
        return new Check2(table, this);
      }
    };
    _a170 = entityKind;
    __publicField(CheckBuilder2, _a170, "MySqlCheckBuilder");
    Check2 = class {
      constructor(table, builder2) {
        __publicField(this, "table");
        __publicField(this, "name");
        __publicField(this, "value");
        this.table = table;
        this.name = builder2.name;
        this.value = builder2.value;
      }
    };
    _a171 = entityKind;
    __publicField(Check2, _a171, "MySqlCheck");
    IndexBuilderOn2 = class {
      constructor(name3, unique2) {
        __publicField(this, "name");
        __publicField(this, "unique");
        this.name = name3;
        this.unique = unique2;
      }
      on(...columns) {
        return new IndexBuilder2(this.name, columns, this.unique);
      }
    };
    _a172 = entityKind;
    __publicField(IndexBuilderOn2, _a172, "MySqlIndexBuilderOn");
    IndexBuilder2 = class {
      constructor(name3, columns, unique2) {
        /** @internal */
        __publicField(this, "config");
        this.config = {
          name: name3,
          columns,
          unique: unique2
        };
      }
      using(using) {
        this.config.using = using;
        return this;
      }
      algorythm(algorythm) {
        this.config.algorythm = algorythm;
        return this;
      }
      lock(lock) {
        this.config.lock = lock;
        return this;
      }
      /** @internal */
      build(table) {
        return new Index2(this.config, table);
      }
    };
    _a173 = entityKind;
    __publicField(IndexBuilder2, _a173, "MySqlIndexBuilder");
    Index2 = class {
      constructor(config, table) {
        __publicField(this, "config");
        this.config = { ...config, table };
      }
    };
    _a174 = entityKind;
    __publicField(Index2, _a174, "MySqlIndex");
    PrimaryKeyBuilder2 = class {
      constructor(columns) {
        /** @internal */
        __publicField(this, "columns");
        this.columns = columns;
      }
      /** @internal */
      build(table) {
        return new PrimaryKey2(table, this.columns);
      }
    };
    _a175 = entityKind;
    __publicField(PrimaryKeyBuilder2, _a175, "MySqlPrimaryKeyBuilder");
    PrimaryKey2 = class {
      constructor(table, columns) {
        __publicField(this, "table");
        __publicField(this, "columns");
        this.table = table;
        this.columns = columns;
      }
      getName() {
        return `${this.table[MySqlTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    };
    _a176 = entityKind;
    __publicField(PrimaryKey2, _a176, "MySqlPrimaryKey");
    MySqlSchema = class {
      constructor(schemaName) {
        __publicField(this, "schemaName");
        __publicField(this, "table", (name3, columns, extraConfig) => {
          return mysqlTableWithSchema(name3, columns, extraConfig, this.schemaName);
        });
        __publicField(this, "view", (name3, columns) => {
          return mysqlViewWithSchema(name3, columns, this.schemaName);
        });
        this.schemaName = schemaName;
      }
    };
    _a177 = entityKind;
    __publicField(MySqlSchema, _a177, "MySqlSchema");
  }
});

// .svelte-kit/output/server/chunks/index3.js
var mysqlTable2, user, key, session, itemsTable, itemsRelations, filesTable, filesRelations, schema, connection, db;
var init_index3 = __esm({
  ".svelte-kit/output/server/chunks/index3.js"() {
    init_dist();
    init_planetscale_serverless();
    init_shared_server();
    init_drizzle_orm();
    init_mysql_core();
    mysqlTable2 = mysqlTableCreator((name3) => `tako_${name3}`);
    user = mysqlTable2("auth_user", {
      id: varchar("id", {
        length: 15
        // change this when using custom user ids
      }).primaryKey(),
      email: varchar("email", { length: 128 }).unique()
      // other user attributes
    });
    key = mysqlTable2("user_key", {
      id: varchar("id", {
        length: 255
      }).primaryKey(),
      userId: varchar("user_id", {
        length: 15
      }).notNull(),
      hashedPassword: varchar("hashed_password", {
        length: 255
      })
    });
    session = mysqlTable2("user_session", {
      id: varchar("id", {
        length: 128
      }).primaryKey(),
      userId: varchar("user_id", {
        length: 15
      }).notNull(),
      activeExpires: bigint("active_expires", {
        mode: "number"
      }).notNull(),
      idleExpires: bigint("idle_expires", {
        mode: "number"
      }).notNull(),
      email: varchar("email", { length: 128 })
    });
    itemsTable = mysqlTable2("item", {
      id: varchar("id", {
        length: 48
      }).primaryKey(),
      userId: varchar("user_id", {
        length: 15
      }).notNull(),
      name: varchar("name", {
        length: 75
      }).notNull(),
      type: mysqlEnum("type", ["folder", "file"]).notNull(),
      parentId: varchar("parent_id", {
        length: 48
      }),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      updatedAt: timestamp("updated_at").notNull().defaultNow()
    });
    itemsRelations = relations(itemsTable, ({ one }) => ({
      file: one(filesTable, {
        fields: [itemsTable.id],
        references: [filesTable.itemId]
      })
    }));
    filesTable = mysqlTable2("file", {
      id: varchar("id", {
        length: 48
      }).primaryKey(),
      itemId: varchar("item_id", {
        length: 48
      }).notNull(),
      content: text("content").notNull()
    });
    filesRelations = relations(filesTable, ({ one }) => ({
      item: one(itemsTable, {
        fields: [filesTable.itemId],
        references: [itemsTable.id]
      })
    }));
    schema = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      filesRelations,
      filesTable,
      itemsRelations,
      itemsTable,
      key,
      mysqlTable: mysqlTable2,
      session,
      user
    }, Symbol.toStringTag, { value: "Module" }));
    connection = connect({
      url: private_env.DATABASE_URL
    });
    db = drizzle(connection, { schema });
  }
});

// node_modules/.pnpm/@lucia-auth+adapter-mysql@2.0.0_@planetscale+database@1.11.0_lucia@2.6.0/node_modules/@lucia-auth/adapter-mysql/dist/utils.js
var createPreparedStatementHelper, ESCAPE_CHAR, escapeName, helper, getSetArgs;
var init_utils = __esm({
  "node_modules/.pnpm/@lucia-auth+adapter-mysql@2.0.0_@planetscale+database@1.11.0_lucia@2.6.0/node_modules/@lucia-auth/adapter-mysql/dist/utils.js"() {
    createPreparedStatementHelper = (placeholder2) => {
      const helper2 = (values) => {
        const keys2 = Object.keys(values);
        return [
          keys2.map((k) => escapeName(k)),
          keys2.map((_, i2) => placeholder2(i2)),
          keys2.map((k) => values[k])
        ];
      };
      return helper2;
    };
    ESCAPE_CHAR = "`";
    escapeName = (val) => {
      return `${ESCAPE_CHAR}${val}${ESCAPE_CHAR}`;
    };
    helper = createPreparedStatementHelper(() => "?");
    getSetArgs = (fields, placeholders) => {
      return fields.map((field, i2) => [field, placeholders[i2]].join(" = ")).join(",");
    };
  }
});

// node_modules/.pnpm/@lucia-auth+adapter-mysql@2.0.0_@planetscale+database@1.11.0_lucia@2.6.0/node_modules/@lucia-auth/adapter-mysql/dist/drivers/mysql2.js
var init_mysql2 = __esm({
  "node_modules/.pnpm/@lucia-auth+adapter-mysql@2.0.0_@planetscale+database@1.11.0_lucia@2.6.0/node_modules/@lucia-auth/adapter-mysql/dist/drivers/mysql2.js"() {
    init_utils();
  }
});

// node_modules/.pnpm/@lucia-auth+adapter-mysql@2.0.0_@planetscale+database@1.11.0_lucia@2.6.0/node_modules/@lucia-auth/adapter-mysql/dist/drivers/planetscale.js
var planetscaleAdapter, get, getAll, transformPlanetscaleSession;
var init_planetscale = __esm({
  "node_modules/.pnpm/@lucia-auth+adapter-mysql@2.0.0_@planetscale+database@1.11.0_lucia@2.6.0/node_modules/@lucia-auth/adapter-mysql/dist/drivers/planetscale.js"() {
    init_utils();
    planetscaleAdapter = (connection2, tables) => {
      const ESCAPED_USER_TABLE_NAME = escapeName(tables.user);
      const ESCAPED_SESSION_TABLE_NAME = tables.session ? escapeName(tables.session) : null;
      const ESCAPED_KEY_TABLE_NAME = escapeName(tables.key);
      return (LuciaError2) => {
        return {
          getUser: async (userId) => {
            const result = await get(connection2.execute(`SELECT * FROM ${ESCAPED_USER_TABLE_NAME} WHERE id = ?`, [userId]));
            return result;
          },
          setUser: async (user2, key3) => {
            if (!key3) {
              const [userFields, userValues, userArgs] = helper(user2);
              await connection2.execute(`INSERT INTO ${ESCAPED_USER_TABLE_NAME} ( ${userFields} ) VALUES ( ${userValues} )`, userArgs);
              return;
            }
            try {
              await connection2.transaction(async (tx) => {
                const [userFields, userValues, userArgs] = helper(user2);
                await tx.execute(`INSERT INTO ${ESCAPED_USER_TABLE_NAME} ( ${userFields} ) VALUES ( ${userValues} )`, userArgs);
                const [keyFields, keyValues, keyArgs] = helper(key3);
                await tx.execute(`INSERT INTO ${ESCAPED_KEY_TABLE_NAME} ( ${keyFields} ) VALUES ( ${keyValues} )`, keyArgs);
              });
            } catch (e) {
              const error3 = e;
              if (error3.body?.message.includes("AlreadyExists") && error3.body?.message.includes("PRIMARY") && error3.body?.message.includes(`${tables.key}`)) {
                throw new LuciaError2("AUTH_DUPLICATE_KEY_ID");
              }
              throw e;
            }
          },
          deleteUser: async (userId) => {
            await connection2.execute(`DELETE FROM ${ESCAPED_USER_TABLE_NAME} WHERE id = ?`, [userId]);
          },
          updateUser: async (userId, partialUser) => {
            const [fields, values, args] = helper(partialUser);
            await connection2.execute(`UPDATE ${ESCAPED_USER_TABLE_NAME} SET ${getSetArgs(fields, values)} WHERE id = ?`, [...args, userId]);
          },
          getSession: async (sessionId) => {
            if (!ESCAPED_SESSION_TABLE_NAME) {
              throw new Error("Session table not defined");
            }
            const result = await get(connection2.execute(`SELECT * FROM ${ESCAPED_SESSION_TABLE_NAME} WHERE id = ?`, [sessionId]));
            return result ? transformPlanetscaleSession(result) : null;
          },
          getSessionsByUserId: async (userId) => {
            if (!ESCAPED_SESSION_TABLE_NAME) {
              throw new Error("Session table not defined");
            }
            const result = await getAll(connection2.execute(`SELECT * FROM ${ESCAPED_SESSION_TABLE_NAME} WHERE user_id = ?`, [userId]));
            return result.map((val) => transformPlanetscaleSession(val));
          },
          setSession: async (session2) => {
            if (!ESCAPED_SESSION_TABLE_NAME) {
              throw new Error("Session table not defined");
            }
            const [fields, values, args] = helper(session2);
            await connection2.execute(`INSERT INTO ${ESCAPED_SESSION_TABLE_NAME} ( ${fields} ) VALUES ( ${values} )`, args);
          },
          deleteSession: async (sessionId) => {
            if (!ESCAPED_SESSION_TABLE_NAME) {
              throw new Error("Session table not defined");
            }
            await connection2.execute(`DELETE FROM ${ESCAPED_SESSION_TABLE_NAME} WHERE id = ?`, [sessionId]);
          },
          deleteSessionsByUserId: async (userId) => {
            if (!ESCAPED_SESSION_TABLE_NAME) {
              throw new Error("Session table not defined");
            }
            await connection2.execute(`DELETE FROM ${ESCAPED_SESSION_TABLE_NAME} WHERE user_id = ?`, [userId]);
          },
          updateSession: async (sessionId, partialSession) => {
            if (!ESCAPED_SESSION_TABLE_NAME) {
              throw new Error("Session table not defined");
            }
            const [fields, values, args] = helper(partialSession);
            await connection2.execute(`UPDATE ${ESCAPED_SESSION_TABLE_NAME} SET ${getSetArgs(fields, values)} WHERE id = ?`, [...args, sessionId]);
          },
          getKey: async (keyId) => {
            const result = await get(connection2.execute(`SELECT * FROM ${ESCAPED_KEY_TABLE_NAME} WHERE id = ?`, [keyId]));
            return result;
          },
          getKeysByUserId: async (userId) => {
            const result = getAll(connection2.execute(`SELECT * FROM ${ESCAPED_KEY_TABLE_NAME} WHERE user_id = ?`, [userId]));
            return result;
          },
          setKey: async (key3) => {
            try {
              const [fields, values, args] = helper(key3);
              await connection2.execute(`INSERT INTO ${ESCAPED_KEY_TABLE_NAME} ( ${fields} ) VALUES ( ${values} )`, args);
            } catch (e) {
              const error3 = e;
              if (error3.body?.message.includes("AlreadyExists") && error3.body?.message.includes("PRIMARY") && error3.body?.message.includes(`${tables.key}`)) {
                throw new LuciaError2("AUTH_DUPLICATE_KEY_ID");
              }
              throw e;
            }
          },
          deleteKey: async (keyId) => {
            await connection2.execute(`DELETE FROM ${ESCAPED_KEY_TABLE_NAME} WHERE id = ?`, [keyId]);
          },
          deleteKeysByUserId: async (userId) => {
            await connection2.execute(`DELETE FROM ${ESCAPED_KEY_TABLE_NAME} WHERE user_id = ?`, [userId]);
          },
          updateKey: async (keyId, partialKey) => {
            const [fields, values, args] = helper(partialKey);
            await connection2.execute(`UPDATE ${ESCAPED_KEY_TABLE_NAME} SET ${getSetArgs(fields, values)} WHERE id = ?`, [...args, keyId]);
          },
          getSessionAndUser: async (sessionId) => {
            if (!ESCAPED_SESSION_TABLE_NAME) {
              throw new Error("Session table not defined");
            }
            const [sessionResult, userFromJoinResult] = await Promise.all([
              get(connection2.execute(`SELECT * FROM ${ESCAPED_SESSION_TABLE_NAME} WHERE id = ?`, [sessionId])),
              get(connection2.execute(`SELECT ${ESCAPED_USER_TABLE_NAME}.*, ${ESCAPED_SESSION_TABLE_NAME}.id as __session_id FROM ${ESCAPED_SESSION_TABLE_NAME} INNER JOIN ${ESCAPED_USER_TABLE_NAME} ON ${ESCAPED_USER_TABLE_NAME}.id = ${ESCAPED_SESSION_TABLE_NAME}.user_id WHERE ${ESCAPED_SESSION_TABLE_NAME}.id = ?`, [sessionId]))
            ]);
            if (!sessionResult || !userFromJoinResult)
              return [null, null];
            const { __session_id: _, ...userResult } = userFromJoinResult;
            return [transformPlanetscaleSession(sessionResult), userResult];
          }
        };
      };
    };
    get = async (queryPromise) => {
      const { rows } = await queryPromise;
      const result = rows.at(0) ?? null;
      return result;
    };
    getAll = async (queryPromise) => {
      const { rows } = await queryPromise;
      return rows;
    };
    transformPlanetscaleSession = (session2) => {
      return {
        ...session2,
        active_expires: Number(session2.active_expires),
        idle_expires: Number(session2.idle_expires)
      };
    };
  }
});

// node_modules/.pnpm/@lucia-auth+adapter-mysql@2.0.0_@planetscale+database@1.11.0_lucia@2.6.0/node_modules/@lucia-auth/adapter-mysql/dist/index.js
var init_dist2 = __esm({
  "node_modules/.pnpm/@lucia-auth+adapter-mysql@2.0.0_@planetscale+database@1.11.0_lucia@2.6.0/node_modules/@lucia-auth/adapter-mysql/dist/index.js"() {
    init_mysql2();
    init_planetscale();
  }
});

// .svelte-kit/output/server/chunks/lucia.js
function checkOpts(defaults3, opts) {
  const merged = Object.assign(defaults3, opts);
  return merged;
}
var parseCookie, serializeCookie, tryDecode, DEFAULT_SESSION_COOKIE_NAME, defaultSessionCookieAttributes, createSessionCookie, Cookie, logError, LuciaError, pbkdf2, u32, nextTick, asyncLoop, rotl, XorAndSalsa, BlockMix, scryptInit, scrypt, getRandomValues, DEFAULT_ALPHABET, generateRandomString, generateScryptHash, hashWithScrypt, validateScryptHash, constantTimeEqual, convertUint8ArrayToHex, isWithinExpiration, isValidDatabaseSession, DEBUG_GLOBAL, ESCAPE, DEFAULT_TEXT_FORMAT, DEFAULT_FG_BG, RED_CODE, LUCIA_COLOR_CODE, WHITE_CODE, GREEN_CODE, CYAN_CODE, YELLOW_CODE, PURPLE_CODE, BLUE_CODE, globalContext, format2, bgFormat, fgFormat, bg, fg, bold, dim, isDebugModeEnabled, linebreak, createCategory, enableDebugMode, disableDebugMode, debug, log, createHeadersFromObject, isAllowedOrigin, getBaseDomain, safeParseUrl, AuthRequest, isValidRequestOrigin, transformRequestContext, sveltekit, lucia$1, createAdapter, createKeyId, lucia, validateConfiguration, Auth, auth;
var init_lucia = __esm({
  ".svelte-kit/output/server/chunks/lucia.js"() {
    init_index3();
    init_dist2();
    parseCookie = (str) => {
      const obj = {};
      let index8 = 0;
      while (index8 < str.length) {
        const eqIdx = str.indexOf("=", index8);
        if (eqIdx === -1) {
          break;
        }
        let endIdx = str.indexOf(";", index8);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index8 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const key3 = str.slice(index8, eqIdx).trim();
        if (!(key3 in obj)) {
          let val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key3] = tryDecode(val);
        }
        index8 = endIdx + 1;
      }
      return obj;
    };
    serializeCookie = (name3, val, options2) => {
      const opt = options2 ?? {};
      const enc = opt.encode ?? encodeURIComponent;
      const value = enc(val);
      let str = name3 + "=" + value;
      if (null != opt.maxAge) {
        const maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        const expires = opt.expires;
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.priority) {
        const priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    };
    tryDecode = (str) => {
      try {
        return decodeURIComponent(str);
      } catch (e) {
        return str;
      }
    };
    DEFAULT_SESSION_COOKIE_NAME = "auth_session";
    defaultSessionCookieAttributes = {
      sameSite: "lax",
      path: "/"
    };
    createSessionCookie = (session2, options2) => {
      let expires;
      if (session2 === null) {
        expires = 0;
      } else if (options2.cookie.expires !== false) {
        expires = session2.idlePeriodExpiresAt.getTime();
      } else {
        expires = Date.now() + 1e3 * 60 * 60 * 24 * 365;
      }
      return new Cookie(options2.cookie.name ?? DEFAULT_SESSION_COOKIE_NAME, session2?.sessionId ?? "", {
        ...options2.cookie.attributes ?? defaultSessionCookieAttributes,
        httpOnly: true,
        expires: new Date(expires),
        secure: options2.env === "PROD"
      });
    };
    Cookie = class {
      constructor(name3, value, options2) {
        __publicField(this, "name");
        __publicField(this, "value");
        __publicField(this, "attributes");
        __publicField(this, "serialize", () => {
          return serializeCookie(this.name, this.value, this.attributes);
        });
        this.name = name3;
        this.value = value;
        this.attributes = options2;
      }
    };
    logError = (message) => {
      console.log("\x1B[31m%s\x1B[31m", `[LUCIA_ERROR] ${message}`);
    };
    LuciaError = class extends Error {
      constructor(errorMsg, detail) {
        super(errorMsg);
        __publicField(this, "detail");
        __publicField(this, "message");
        this.message = errorMsg;
        this.detail = detail ?? "";
      }
    };
    pbkdf2 = async (password, salt, options2) => {
      const pwKey = await crypto.subtle.importKey("raw", password, "PBKDF2", false, ["deriveBits"]);
      const keyBuffer = await crypto.subtle.deriveBits({
        name: "PBKDF2",
        hash: "SHA-256",
        salt,
        iterations: options2.c
      }, pwKey, options2.dkLen * 8);
      return new Uint8Array(keyBuffer);
    };
    u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    nextTick = async () => {
    };
    asyncLoop = async (iters, tick2, cb) => {
      let ts2 = Date.now();
      for (let i2 = 0; i2 < iters; i2++) {
        cb(i2);
        const diff = Date.now() - ts2;
        if (diff >= 0 && diff < tick2)
          continue;
        await nextTick();
        ts2 += diff;
      }
    };
    rotl = (a2, b) => a2 << b | a2 >>> 32 - b;
    XorAndSalsa = (prev, pi, input, ii, out, oi) => {
      const y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
      const y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
      const y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
      const y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
      const y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
      const y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
      const y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
      const y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
      let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
      for (let i2 = 0; i2 < 8; i2 += 2) {
        x04 ^= rotl(x00 + x12 | 0, 7);
        x08 ^= rotl(x04 + x00 | 0, 9);
        x12 ^= rotl(x08 + x04 | 0, 13);
        x00 ^= rotl(x12 + x08 | 0, 18);
        x09 ^= rotl(x05 + x01 | 0, 7);
        x13 ^= rotl(x09 + x05 | 0, 9);
        x01 ^= rotl(x13 + x09 | 0, 13);
        x05 ^= rotl(x01 + x13 | 0, 18);
        x14 ^= rotl(x10 + x06 | 0, 7);
        x02 ^= rotl(x14 + x10 | 0, 9);
        x06 ^= rotl(x02 + x14 | 0, 13);
        x10 ^= rotl(x06 + x02 | 0, 18);
        x03 ^= rotl(x15 + x11 | 0, 7);
        x07 ^= rotl(x03 + x15 | 0, 9);
        x11 ^= rotl(x07 + x03 | 0, 13);
        x15 ^= rotl(x11 + x07 | 0, 18);
        x01 ^= rotl(x00 + x03 | 0, 7);
        x02 ^= rotl(x01 + x00 | 0, 9);
        x03 ^= rotl(x02 + x01 | 0, 13);
        x00 ^= rotl(x03 + x02 | 0, 18);
        x06 ^= rotl(x05 + x04 | 0, 7);
        x07 ^= rotl(x06 + x05 | 0, 9);
        x04 ^= rotl(x07 + x06 | 0, 13);
        x05 ^= rotl(x04 + x07 | 0, 18);
        x11 ^= rotl(x10 + x09 | 0, 7);
        x08 ^= rotl(x11 + x10 | 0, 9);
        x09 ^= rotl(x08 + x11 | 0, 13);
        x10 ^= rotl(x09 + x08 | 0, 18);
        x12 ^= rotl(x15 + x14 | 0, 7);
        x13 ^= rotl(x12 + x15 | 0, 9);
        x14 ^= rotl(x13 + x12 | 0, 13);
        x15 ^= rotl(x14 + x13 | 0, 18);
      }
      out[oi++] = y00 + x00 | 0;
      out[oi++] = y01 + x01 | 0;
      out[oi++] = y02 + x02 | 0;
      out[oi++] = y03 + x03 | 0;
      out[oi++] = y04 + x04 | 0;
      out[oi++] = y05 + x05 | 0;
      out[oi++] = y06 + x06 | 0;
      out[oi++] = y07 + x07 | 0;
      out[oi++] = y08 + x08 | 0;
      out[oi++] = y09 + x09 | 0;
      out[oi++] = y10 + x10 | 0;
      out[oi++] = y11 + x11 | 0;
      out[oi++] = y12 + x12 | 0;
      out[oi++] = y13 + x13 | 0;
      out[oi++] = y14 + x14 | 0;
      out[oi++] = y15 + x15 | 0;
    };
    BlockMix = (input, ii, out, oi, r2) => {
      let head = oi + 0;
      let tail = oi + 16 * r2;
      for (let i2 = 0; i2 < 16; i2++)
        out[tail + i2] = input[ii + (2 * r2 - 1) * 16 + i2];
      for (let i2 = 0; i2 < r2; i2++, head += 16, ii += 16) {
        XorAndSalsa(out, tail, input, ii, out, head);
        if (i2 > 0)
          tail += 16;
        XorAndSalsa(out, head, input, ii += 16, out, tail);
      }
    };
    scryptInit = async (password, salt, _opts) => {
      const opts = checkOpts({
        dkLen: 32,
        asyncTick: 10,
        maxmem: 1024 ** 3 + 1024
      }, _opts);
      const { N, r: r2, p: p2, dkLen, asyncTick, maxmem, onProgress } = opts;
      if (onProgress !== void 0 && typeof onProgress !== "function")
        throw new Error("progressCb should be function");
      const blockSize = 128 * r2;
      const blockSize32 = blockSize / 4;
      if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
        throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
      }
      if (p2 < 0 || p2 > (2 ** 32 - 1) * 32 / blockSize) {
        throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
      }
      if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
        throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
      }
      const memUsed = blockSize * (N + p2);
      if (memUsed > maxmem) {
        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
      }
      const B2 = await pbkdf2(password, salt, { c: 1, dkLen: blockSize * p2 });
      const B32 = u32(B2);
      const V = u32(new Uint8Array(blockSize * N));
      const tmp = u32(new Uint8Array(blockSize));
      let blockMixCb = () => {
      };
      if (onProgress) {
        const totalBlockMix = 2 * N * p2;
        const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
        let blockMixCnt = 0;
        blockMixCb = () => {
          blockMixCnt++;
          if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
            onProgress(blockMixCnt / totalBlockMix);
        };
      }
      return { N, r: r2, p: p2, dkLen, blockSize32, V, B32, B: B2, tmp, blockMixCb, asyncTick };
    };
    scrypt = async (password, salt, opts) => {
      const { N, r: r2, p: p2, dkLen, blockSize32, V, B32, B: B2, tmp, blockMixCb, asyncTick } = await scryptInit(password, salt, opts);
      for (let pi = 0; pi < p2; pi++) {
        const Pi = blockSize32 * pi;
        for (let i2 = 0; i2 < blockSize32; i2++)
          V[i2] = B32[Pi + i2];
        let pos = 0;
        await asyncLoop(N - 1, asyncTick, (i2) => {
          BlockMix(V, pos, V, pos += blockSize32, r2);
          blockMixCb();
        });
        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r2);
        blockMixCb();
        await asyncLoop(N, asyncTick, (i2) => {
          const j2 = B32[Pi + blockSize32 - 16] % N;
          for (let k = 0; k < blockSize32; k++)
            tmp[k] = B32[Pi + k] ^ V[j2 * blockSize32 + k];
          BlockMix(tmp, 0, B32, Pi, r2);
          blockMixCb();
        });
      }
      const res = await pbkdf2(password, B2, { c: 1, dkLen });
      B2.fill(0);
      V.fill(0);
      tmp.fill(0);
      return res;
    };
    getRandomValues = (bytes2) => {
      return crypto.getRandomValues(new Uint8Array(bytes2));
    };
    DEFAULT_ALPHABET = "abcdefghijklmnopqrstuvwxyz1234567890";
    generateRandomString = (size2, alphabet = DEFAULT_ALPHABET) => {
      const mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      const step = -~(1.6 * mask * size2 / alphabet.length);
      let bytes2 = getRandomValues(step);
      let id = "";
      let index8 = 0;
      while (id.length !== size2) {
        id += alphabet[bytes2[index8] & mask] ?? "";
        index8 += 1;
        if (index8 > bytes2.length) {
          bytes2 = getRandomValues(step);
          index8 = 0;
        }
      }
      return id;
    };
    generateScryptHash = async (s2) => {
      const salt = generateRandomString(16);
      const key3 = await hashWithScrypt(s2.normalize("NFKC"), salt);
      return `s2:${salt}:${key3}`;
    };
    hashWithScrypt = async (s2, salt, blockSize = 16) => {
      const keyUint8Array = await scrypt(new TextEncoder().encode(s2), new TextEncoder().encode(salt), {
        N: 16384,
        r: blockSize,
        p: 1,
        dkLen: 64
      });
      return convertUint8ArrayToHex(keyUint8Array);
    };
    validateScryptHash = async (s2, hash2) => {
      if (hash2.startsWith("$2a")) {
        throw new LuciaError("AUTH_OUTDATED_PASSWORD");
      }
      const arr = hash2.split(":");
      if (arr.length === 2) {
        const [salt2, key22] = arr;
        const targetKey = await hashWithScrypt(s2.normalize("NFKC"), salt2, 8);
        const result = constantTimeEqual(targetKey, key22);
        return result;
      }
      if (arr.length !== 3)
        return false;
      const [version2, salt, key3] = arr;
      if (version2 === "s2") {
        const targetKey = await hashWithScrypt(s2.normalize("NFKC"), salt);
        const result = constantTimeEqual(targetKey, key3);
        return result;
      }
      return false;
    };
    constantTimeEqual = (a2, b) => {
      if (a2.length !== b.length) {
        return false;
      }
      const aUint8Array = new TextEncoder().encode(a2);
      const bUint8Array = new TextEncoder().encode(b);
      let c = 0;
      for (let i2 = 0; i2 < a2.length; i2++) {
        c |= aUint8Array[i2] ^ bUint8Array[i2];
      }
      return c === 0;
    };
    convertUint8ArrayToHex = (arr) => {
      return [...arr].map((x2) => x2.toString(16).padStart(2, "0")).join("");
    };
    isWithinExpiration = (expiresInMs) => {
      const currentTime = Date.now();
      if (currentTime > expiresInMs)
        return false;
      return true;
    };
    isValidDatabaseSession = (databaseSession) => {
      return isWithinExpiration(databaseSession.idle_expires);
    };
    DEBUG_GLOBAL = "__lucia_debug_mode";
    ESCAPE = "\x1B";
    DEFAULT_TEXT_FORMAT = "\x1B[0m";
    DEFAULT_FG_BG = `${ESCAPE}[0m`;
    RED_CODE = 9;
    LUCIA_COLOR_CODE = 63;
    WHITE_CODE = 231;
    GREEN_CODE = 34;
    CYAN_CODE = 6;
    YELLOW_CODE = 3;
    PURPLE_CODE = 5;
    BLUE_CODE = 4;
    globalContext = globalThis;
    globalContext[DEBUG_GLOBAL] = false;
    format2 = (text3, format22, removeFormat) => {
      return `${format22}${text3}${removeFormat ? removeFormat : DEFAULT_TEXT_FORMAT}`;
    };
    bgFormat = (text3, colorCode) => {
      return format2(text3, `${ESCAPE}[48;5;${colorCode}m`, DEFAULT_FG_BG);
    };
    fgFormat = (text3, colorCode) => {
      return format2(text3, `${ESCAPE}[38;5;${colorCode}m`, DEFAULT_FG_BG);
    };
    bg = {
      lucia: (text3) => bgFormat(text3, LUCIA_COLOR_CODE),
      red: (text3) => bgFormat(text3, RED_CODE),
      white: (text3) => bgFormat(text3, WHITE_CODE),
      green: (text3) => bgFormat(text3, GREEN_CODE),
      cyan: (text3) => bgFormat(text3, CYAN_CODE),
      yellow: (text3) => bgFormat(text3, YELLOW_CODE),
      purple: (text3) => bgFormat(text3, PURPLE_CODE),
      blue: (text3) => bgFormat(text3, BLUE_CODE)
    };
    fg = {
      lucia: (text3) => fgFormat(text3, LUCIA_COLOR_CODE),
      red: (text3) => fgFormat(text3, RED_CODE),
      white: (text3) => fgFormat(text3, WHITE_CODE),
      green: (text3) => fgFormat(text3, GREEN_CODE),
      cyan: (text3) => fgFormat(text3, CYAN_CODE),
      yellow: (text3) => fgFormat(text3, YELLOW_CODE),
      purple: (text3) => fgFormat(text3, PURPLE_CODE),
      blue: (text3) => fgFormat(text3, BLUE_CODE),
      default: (text3) => format2(text3, DEFAULT_TEXT_FORMAT)
    };
    bold = (text3) => {
      return format2(text3, `${ESCAPE}[1m`, `${ESCAPE}[22m`);
    };
    dim = (text3) => {
      return format2(text3, `${ESCAPE}[2m`, `${ESCAPE}[22m`);
    };
    isDebugModeEnabled = () => {
      return Boolean(globalContext[DEBUG_GLOBAL]);
    };
    linebreak = () => console.log("");
    createCategory = (name3, themeTextColor) => {
      const createLogger = (textColor = fg.default) => {
        return (text3, subtext) => {
          if (!isDebugModeEnabled())
            return;
          if (subtext) {
            return log(themeTextColor(`[${name3}]`), `${textColor(text3)}`, subtext);
          }
          log(themeTextColor(`[${name3}]`), `${textColor(text3)}`);
        };
      };
      return {
        info: createLogger(),
        notice: createLogger(fg.yellow),
        fail: createLogger(fg.red),
        success: createLogger(fg.green)
      };
    };
    enableDebugMode = () => {
      globalContext[DEBUG_GLOBAL] = true;
    };
    disableDebugMode = () => {
      globalContext[DEBUG_GLOBAL] = false;
    };
    debug = {
      init: (debugEnabled) => {
        if (debugEnabled) {
          enableDebugMode();
          linebreak();
          console.log(` ${bg.lucia(bold(fg.white(" lucia ")))}  ${fg.lucia(bold("Debug mode enabled"))}`);
        } else {
          disableDebugMode();
        }
      },
      request: {
        init: (method, href) => {
          if (!isDebugModeEnabled())
            return;
          linebreak();
          const getUrl = () => {
            try {
              const url = new URL(href);
              return url.origin + url.pathname;
            } catch {
              return href;
            }
          };
          log(bg.cyan(bold(fg.white(" request "))), fg.cyan(`${method.toUpperCase()} ${getUrl()}`));
        },
        ...createCategory("request", fg.cyan)
      },
      session: createCategory("session", fg.purple),
      key: createCategory("key", fg.blue)
    };
    log = (type, text3, subtext) => {
      if (!subtext) {
        return console.log(`${dim((/* @__PURE__ */ new Date()).toLocaleTimeString())}  ${type} ${text3}`);
      }
      console.log(`${dim((/* @__PURE__ */ new Date()).toLocaleTimeString())}  ${type} ${text3} ${dim(subtext)}`);
    };
    createHeadersFromObject = (headersObject) => {
      const headers = new Headers();
      for (const [key3, value] of Object.entries(headersObject)) {
        if (value === null || value === void 0)
          continue;
        if (typeof value === "string") {
          headers.set(key3, value);
        } else {
          for (const item of value) {
            headers.append(key3, item);
          }
        }
      }
      return headers;
    };
    isAllowedOrigin = (origin, host, allowedSubdomains) => {
      const originHost = new URL(origin).host;
      const baseDomain = getBaseDomain(host);
      if (host.length < 1 || origin.length < 1)
        return false;
      if (originHost === host)
        return true;
      if (allowedSubdomains === "*") {
        if (originHost.endsWith(`.${baseDomain}`))
          return true;
        return false;
      }
      for (const subdomain of allowedSubdomains) {
        const allowedHostPermutation = subdomain === null ? baseDomain : [subdomain, baseDomain].join(".");
        if (allowedHostPermutation === originHost)
          return true;
      }
      return false;
    };
    getBaseDomain = (host) => {
      if (host.startsWith("localhost:"))
        return host;
      return host.split(".").slice(-2).join(".");
    };
    safeParseUrl = (url) => {
      try {
        return new URL(url);
      } catch {
        return null;
      }
    };
    AuthRequest = class {
      constructor(auth2, config) {
        __publicField(this, "auth");
        __publicField(this, "requestContext");
        __publicField(this, "validatePromise", null);
        __publicField(this, "validateBearerTokenPromise", null);
        __publicField(this, "storedSessionId");
        __publicField(this, "bearerToken");
        __publicField(this, "setSession", (session2) => {
          const sessionId = session2?.sessionId ?? null;
          if (this.storedSessionId === sessionId)
            return;
          this.validatePromise = null;
          this.setSessionCookie(session2);
        });
        __publicField(this, "maybeSetSession", (session2) => {
          try {
            this.setSession(session2);
          } catch {
          }
        });
        __publicField(this, "setSessionCookie", (session2) => {
          const sessionId = session2?.sessionId ?? null;
          if (this.storedSessionId === sessionId)
            return;
          this.storedSessionId = sessionId;
          this.requestContext.setCookie(this.auth.createSessionCookie(session2));
          if (session2) {
            debug.request.notice("Session cookie stored", session2.sessionId);
          } else {
            debug.request.notice("Session cookie deleted");
          }
        });
        __publicField(this, "validate", async () => {
          if (this.validatePromise) {
            debug.request.info("Using cached result for session validation");
            return this.validatePromise;
          }
          this.validatePromise = new Promise(async (resolve) => {
            if (!this.storedSessionId)
              return resolve(null);
            try {
              const session2 = await this.auth.validateSession(this.storedSessionId);
              if (session2.fresh) {
                this.maybeSetSession(session2);
              }
              return resolve(session2);
            } catch (e) {
              if (e instanceof LuciaError && e.message === "AUTH_INVALID_SESSION_ID") {
                this.maybeSetSession(null);
                return resolve(null);
              }
              throw e;
            }
          });
          return await this.validatePromise;
        });
        __publicField(this, "validateBearerToken", async () => {
          if (this.validateBearerTokenPromise) {
            debug.request.info("Using cached result for bearer token validation");
            return this.validatePromise;
          }
          this.validatePromise = new Promise(async (resolve) => {
            if (!this.bearerToken)
              return resolve(null);
            try {
              const session2 = await this.auth.validateSession(this.bearerToken);
              return resolve(session2);
            } catch (e) {
              if (e instanceof LuciaError) {
                return resolve(null);
              }
              throw e;
            }
          });
          return await this.validatePromise;
        });
        debug.request.init(config.requestContext.request.method, config.requestContext.request.url ?? "(url unknown)");
        this.auth = auth2;
        this.requestContext = config.requestContext;
        const csrfProtectionConfig = typeof config.csrfProtection === "object" ? config.csrfProtection : {};
        const csrfProtectionEnabled = config.csrfProtection !== false;
        if (!csrfProtectionEnabled || isValidRequestOrigin(this.requestContext.request, csrfProtectionConfig)) {
          this.storedSessionId = this.requestContext.sessionCookie ?? auth2.readSessionCookie(this.requestContext.request.headers.get("Cookie"));
        } else {
          this.storedSessionId = null;
        }
        this.bearerToken = auth2.readBearerToken(this.requestContext.request.headers.get("Authorization"));
      }
    };
    isValidRequestOrigin = (request, config) => {
      const whitelist = ["GET", "HEAD", "OPTIONS", "TRACE"];
      if (whitelist.some((val) => val === request.method.toUpperCase())) {
        return true;
      }
      const requestOrigin = request.headers.get("Origin");
      if (!requestOrigin)
        return false;
      if (!requestOrigin) {
        debug.request.fail("No request origin available");
        return false;
      }
      let host = null;
      if (config.host !== void 0) {
        host = config.host ?? null;
      } else if (request.url !== null && request.url !== void 0) {
        host = safeParseUrl(request.url)?.host ?? null;
      } else {
        host = request.headers.get(config.hostHeader ?? "Host");
      }
      if (host !== null && isAllowedOrigin(requestOrigin, host, config.allowedSubDomains ?? [])) {
        debug.request.info("Valid request origin", requestOrigin);
        return true;
      }
      debug.request.info("Invalid request origin", requestOrigin);
      return false;
    };
    transformRequestContext = ({ request, setCookie: setCookie2, sessionCookie }) => {
      return {
        request: {
          url: request.url,
          method: request.method,
          headers: "authorization" in request.headers ? createHeadersFromObject(request.headers) : request.headers
        },
        setCookie: setCookie2,
        sessionCookie: sessionCookie ?? request.storedSessionCookie
      };
    };
    sveltekit = () => {
      return ({ args, sessionCookieName }) => {
        const [event] = args;
        const requestContext = {
          request: event.request,
          sessionCookie: event.cookies.get(sessionCookieName) ?? null,
          setCookie: (cookie) => {
            event.cookies.set(cookie.name, cookie.value, cookie.attributes);
          }
        };
        return requestContext;
      };
    };
    lucia$1 = () => {
      return ({ args }) => args[0];
    };
    createAdapter = (adapter) => {
      if (!("user" in adapter))
        return adapter(LuciaError);
      let userAdapter = adapter.user(LuciaError);
      let sessionAdapter = adapter.session(LuciaError);
      if ("getSessionAndUser" in userAdapter) {
        const { getSessionAndUser: _, ...extractedUserAdapter } = userAdapter;
        userAdapter = extractedUserAdapter;
      }
      if ("getSessionAndUser" in sessionAdapter) {
        const { getSessionAndUser: _, ...extractedSessionAdapter } = sessionAdapter;
        sessionAdapter = extractedSessionAdapter;
      }
      return {
        ...userAdapter,
        ...sessionAdapter
      };
    };
    createKeyId = (providerId, providerUserId) => {
      if (providerId.includes(":")) {
        throw new TypeError("Provider id must not include any colons (:)");
      }
      return `${providerId}:${providerUserId}`;
    };
    lucia = (config) => {
      return new Auth(config);
    };
    validateConfiguration = (config) => {
      const adapterProvided = config.adapter;
      if (!adapterProvided) {
        logError('Adapter is not defined in configuration ("config.adapter")');
        process.exit(1);
      }
    };
    Auth = class {
      constructor(config) {
        __publicField(this, "adapter");
        __publicField(this, "sessionCookieConfig");
        __publicField(this, "sessionExpiresIn");
        __publicField(this, "csrfProtection");
        __publicField(this, "env");
        __publicField(this, "passwordHash", {
          generate: generateScryptHash,
          validate: validateScryptHash
        });
        __publicField(this, "middleware", lucia$1());
        __publicField(this, "experimental");
        __publicField(this, "getUserAttributes");
        __publicField(this, "getSessionAttributes");
        __publicField(this, "transformDatabaseUser", (databaseUser) => {
          const attributes = this.getUserAttributes(databaseUser);
          return {
            ...attributes,
            userId: databaseUser.id
          };
        });
        __publicField(this, "transformDatabaseKey", (databaseKey) => {
          const [providerId, ...providerUserIdSegments] = databaseKey.id.split(":");
          const providerUserId = providerUserIdSegments.join(":");
          const userId = databaseKey.user_id;
          const isPasswordDefined = !!databaseKey.hashed_password;
          return {
            providerId,
            providerUserId,
            userId,
            passwordDefined: isPasswordDefined
          };
        });
        __publicField(this, "transformDatabaseSession", (databaseSession, context) => {
          const attributes = this.getSessionAttributes(databaseSession);
          const active = isWithinExpiration(databaseSession.active_expires);
          return {
            ...attributes,
            user: context.user,
            sessionId: databaseSession.id,
            activePeriodExpiresAt: new Date(Number(databaseSession.active_expires)),
            idlePeriodExpiresAt: new Date(Number(databaseSession.idle_expires)),
            state: active ? "active" : "idle",
            fresh: context.fresh
          };
        });
        __publicField(this, "getDatabaseUser", async (userId) => {
          const databaseUser = await this.adapter.getUser(userId);
          if (!databaseUser) {
            throw new LuciaError("AUTH_INVALID_USER_ID");
          }
          return databaseUser;
        });
        __publicField(this, "getDatabaseSession", async (sessionId) => {
          const databaseSession = await this.adapter.getSession(sessionId);
          if (!databaseSession) {
            debug.session.fail("Session not found", sessionId);
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
          }
          if (!isValidDatabaseSession(databaseSession)) {
            debug.session.fail(`Session expired at ${new Date(Number(databaseSession.idle_expires))}`, sessionId);
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
          }
          return databaseSession;
        });
        __publicField(this, "getDatabaseSessionAndUser", async (sessionId) => {
          if (this.adapter.getSessionAndUser) {
            const [databaseSession2, databaseUser2] = await this.adapter.getSessionAndUser(sessionId);
            if (!databaseSession2) {
              debug.session.fail("Session not found", sessionId);
              throw new LuciaError("AUTH_INVALID_SESSION_ID");
            }
            if (!isValidDatabaseSession(databaseSession2)) {
              debug.session.fail(`Session expired at ${new Date(Number(databaseSession2.idle_expires))}`, sessionId);
              throw new LuciaError("AUTH_INVALID_SESSION_ID");
            }
            return [databaseSession2, databaseUser2];
          }
          const databaseSession = await this.getDatabaseSession(sessionId);
          const databaseUser = await this.getDatabaseUser(databaseSession.user_id);
          return [databaseSession, databaseUser];
        });
        __publicField(this, "validateSessionIdArgument", (sessionId) => {
          if (!sessionId) {
            debug.session.fail("Empty session id");
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
          }
        });
        __publicField(this, "getNewSessionExpiration", (sessionExpiresIn) => {
          const activePeriodExpiresAt = new Date((/* @__PURE__ */ new Date()).getTime() + (sessionExpiresIn?.activePeriod ?? this.sessionExpiresIn.activePeriod));
          const idlePeriodExpiresAt = new Date(activePeriodExpiresAt.getTime() + (sessionExpiresIn?.idlePeriod ?? this.sessionExpiresIn.idlePeriod));
          return { activePeriodExpiresAt, idlePeriodExpiresAt };
        });
        __publicField(this, "getUser", async (userId) => {
          const databaseUser = await this.getDatabaseUser(userId);
          const user2 = this.transformDatabaseUser(databaseUser);
          return user2;
        });
        __publicField(this, "createUser", async (options2) => {
          const userId = options2.userId ?? generateRandomString(15);
          const userAttributes = options2.attributes ?? {};
          const databaseUser = {
            ...userAttributes,
            id: userId
          };
          if (options2.key === null) {
            await this.adapter.setUser(databaseUser, null);
            return this.transformDatabaseUser(databaseUser);
          }
          const keyId = createKeyId(options2.key.providerId, options2.key.providerUserId);
          const password = options2.key.password;
          const hashedPassword = password === null ? null : await this.passwordHash.generate(password);
          await this.adapter.setUser(databaseUser, {
            id: keyId,
            user_id: userId,
            hashed_password: hashedPassword
          });
          return this.transformDatabaseUser(databaseUser);
        });
        __publicField(this, "updateUserAttributes", async (userId, attributes) => {
          await this.adapter.updateUser(userId, attributes);
          return await this.getUser(userId);
        });
        __publicField(this, "deleteUser", async (userId) => {
          await this.adapter.deleteSessionsByUserId(userId);
          await this.adapter.deleteKeysByUserId(userId);
          await this.adapter.deleteUser(userId);
        });
        __publicField(this, "useKey", async (providerId, providerUserId, password) => {
          const keyId = createKeyId(providerId, providerUserId);
          const databaseKey = await this.adapter.getKey(keyId);
          if (!databaseKey) {
            debug.key.fail("Key not found", keyId);
            throw new LuciaError("AUTH_INVALID_KEY_ID");
          }
          const hashedPassword = databaseKey.hashed_password;
          if (hashedPassword !== null) {
            debug.key.info("Key includes password");
            if (!password) {
              debug.key.fail("Key password not provided", keyId);
              throw new LuciaError("AUTH_INVALID_PASSWORD");
            }
            const validPassword = await this.passwordHash.validate(password, hashedPassword);
            if (!validPassword) {
              debug.key.fail("Incorrect key password", password);
              throw new LuciaError("AUTH_INVALID_PASSWORD");
            }
            debug.key.notice("Validated key password");
          } else {
            if (password !== null) {
              debug.key.fail("Incorrect key password", password);
              throw new LuciaError("AUTH_INVALID_PASSWORD");
            }
            debug.key.info("No password included in key");
          }
          debug.key.success("Validated key", keyId);
          return this.transformDatabaseKey(databaseKey);
        });
        __publicField(this, "getSession", async (sessionId) => {
          this.validateSessionIdArgument(sessionId);
          const [databaseSession, databaseUser] = await this.getDatabaseSessionAndUser(sessionId);
          const user2 = this.transformDatabaseUser(databaseUser);
          return this.transformDatabaseSession(databaseSession, {
            user: user2,
            fresh: false
          });
        });
        __publicField(this, "getAllUserSessions", async (userId) => {
          const [user2, databaseSessions] = await Promise.all([
            this.getUser(userId),
            await this.adapter.getSessionsByUserId(userId)
          ]);
          const validStoredUserSessions = databaseSessions.filter((databaseSession) => {
            return isValidDatabaseSession(databaseSession);
          }).map((databaseSession) => {
            return this.transformDatabaseSession(databaseSession, {
              user: user2,
              fresh: false
            });
          });
          return validStoredUserSessions;
        });
        __publicField(this, "validateSession", async (sessionId) => {
          this.validateSessionIdArgument(sessionId);
          const [databaseSession, databaseUser] = await this.getDatabaseSessionAndUser(sessionId);
          const user2 = this.transformDatabaseUser(databaseUser);
          const session2 = this.transformDatabaseSession(databaseSession, {
            user: user2,
            fresh: false
          });
          if (session2.state === "active") {
            debug.session.success("Validated session", session2.sessionId);
            return session2;
          }
          const { activePeriodExpiresAt, idlePeriodExpiresAt } = this.getNewSessionExpiration();
          await this.adapter.updateSession(session2.sessionId, {
            active_expires: activePeriodExpiresAt.getTime(),
            idle_expires: idlePeriodExpiresAt.getTime()
          });
          const renewedDatabaseSession = {
            ...session2,
            idlePeriodExpiresAt,
            activePeriodExpiresAt,
            fresh: true
          };
          return renewedDatabaseSession;
        });
        __publicField(this, "createSession", async (options2) => {
          const { activePeriodExpiresAt, idlePeriodExpiresAt } = this.getNewSessionExpiration();
          const userId = options2.userId;
          const sessionId = options2?.sessionId ?? generateRandomString(40);
          const attributes = options2.attributes;
          const databaseSession = {
            ...attributes,
            id: sessionId,
            user_id: userId,
            active_expires: activePeriodExpiresAt.getTime(),
            idle_expires: idlePeriodExpiresAt.getTime()
          };
          const [user2] = await Promise.all([
            this.getUser(userId),
            this.adapter.setSession(databaseSession)
          ]);
          return this.transformDatabaseSession(databaseSession, {
            user: user2,
            fresh: false
          });
        });
        __publicField(this, "updateSessionAttributes", async (sessionId, attributes) => {
          this.validateSessionIdArgument(sessionId);
          await this.adapter.updateSession(sessionId, attributes);
          return this.getSession(sessionId);
        });
        __publicField(this, "invalidateSession", async (sessionId) => {
          this.validateSessionIdArgument(sessionId);
          await this.adapter.deleteSession(sessionId);
          debug.session.notice("Invalidated session", sessionId);
        });
        __publicField(this, "invalidateAllUserSessions", async (userId) => {
          await this.adapter.deleteSessionsByUserId(userId);
        });
        __publicField(this, "deleteDeadUserSessions", async (userId) => {
          const databaseSessions = await this.adapter.getSessionsByUserId(userId);
          const deadSessionIds = databaseSessions.filter((databaseSession) => {
            return !isValidDatabaseSession(databaseSession);
          }).map((databaseSession) => databaseSession.id);
          await Promise.all(deadSessionIds.map((deadSessionId) => {
            this.adapter.deleteSession(deadSessionId);
          }));
        });
        /**
         * @deprecated To be removed in next major release
         */
        __publicField(this, "validateRequestOrigin", (request) => {
          if (request.method === null) {
            debug.request.fail("Request method unavailable");
            throw new LuciaError("AUTH_INVALID_REQUEST");
          }
          if (request.url === null) {
            debug.request.fail("Request url unavailable");
            throw new LuciaError("AUTH_INVALID_REQUEST");
          }
          if (request.method.toUpperCase() !== "GET" && request.method.toUpperCase() !== "HEAD") {
            const requestOrigin = request.headers.origin;
            if (!requestOrigin) {
              debug.request.fail("No request origin available");
              throw new LuciaError("AUTH_INVALID_REQUEST");
            }
            try {
              const url = safeParseUrl(request.url);
              const allowedSubDomains = typeof this.csrfProtection === "object" ? this.csrfProtection.allowedSubDomains ?? [] : [];
              if (url === null || !isAllowedOrigin(requestOrigin, url.origin, allowedSubDomains)) {
                throw new LuciaError("AUTH_INVALID_REQUEST");
              }
              debug.request.info("Valid request origin", requestOrigin);
            } catch {
              debug.request.fail("Invalid origin string", requestOrigin);
              throw new LuciaError("AUTH_INVALID_REQUEST");
            }
          } else {
            debug.request.notice("Skipping CSRF check");
          }
        });
        __publicField(this, "readSessionCookie", (cookieHeader) => {
          if (!cookieHeader) {
            debug.request.info("No session cookie found");
            return null;
          }
          const cookies = parseCookie(cookieHeader);
          const sessionCookieName = this.sessionCookieConfig.name ?? DEFAULT_SESSION_COOKIE_NAME;
          const sessionId = cookies[sessionCookieName] ?? null;
          if (sessionId) {
            debug.request.info("Found session cookie", sessionId);
          } else {
            debug.request.info("No session cookie found");
          }
          return sessionId;
        });
        __publicField(this, "readBearerToken", (authorizationHeader) => {
          if (!authorizationHeader) {
            debug.request.info("No token found in authorization header");
            return null;
          }
          const [authScheme, token] = authorizationHeader.split(" ");
          if (authScheme !== "Bearer") {
            debug.request.fail("Invalid authorization header auth scheme", authScheme);
            return null;
          }
          return token ?? null;
        });
        __publicField(this, "handleRequest", (...args) => {
          const middleware = this.middleware;
          const sessionCookieName = this.sessionCookieConfig.name ?? DEFAULT_SESSION_COOKIE_NAME;
          return new AuthRequest(this, {
            csrfProtection: this.csrfProtection,
            requestContext: transformRequestContext(middleware({
              args,
              env: this.env,
              sessionCookieName
            }))
          });
        });
        __publicField(this, "createSessionCookie", (session2) => {
          return createSessionCookie(session2, {
            env: this.env,
            cookie: this.sessionCookieConfig
          });
        });
        __publicField(this, "createKey", async (options2) => {
          const keyId = createKeyId(options2.providerId, options2.providerUserId);
          let hashedPassword = null;
          if (options2.password !== null) {
            hashedPassword = await this.passwordHash.generate(options2.password);
          }
          const userId = options2.userId;
          await this.adapter.setKey({
            id: keyId,
            user_id: userId,
            hashed_password: hashedPassword
          });
          return {
            providerId: options2.providerId,
            providerUserId: options2.providerUserId,
            passwordDefined: !!options2.password,
            userId
          };
        });
        __publicField(this, "deleteKey", async (providerId, providerUserId) => {
          const keyId = createKeyId(providerId, providerUserId);
          await this.adapter.deleteKey(keyId);
        });
        __publicField(this, "getKey", async (providerId, providerUserId) => {
          const keyId = createKeyId(providerId, providerUserId);
          const databaseKey = await this.adapter.getKey(keyId);
          if (!databaseKey) {
            throw new LuciaError("AUTH_INVALID_KEY_ID");
          }
          const key3 = this.transformDatabaseKey(databaseKey);
          return key3;
        });
        __publicField(this, "getAllUserKeys", async (userId) => {
          const [databaseKeys] = await Promise.all([
            await this.adapter.getKeysByUserId(userId),
            this.getUser(userId)
          ]);
          return databaseKeys.map((databaseKey) => this.transformDatabaseKey(databaseKey));
        });
        __publicField(this, "updateKeyPassword", async (providerId, providerUserId, password) => {
          const keyId = createKeyId(providerId, providerUserId);
          const hashedPassword = password === null ? null : await this.passwordHash.generate(password);
          await this.adapter.updateKey(keyId, {
            hashed_password: hashedPassword
          });
          return await this.getKey(providerId, providerUserId);
        });
        validateConfiguration(config);
        this.adapter = createAdapter(config.adapter);
        this.env = config.env;
        this.sessionExpiresIn = {
          activePeriod: config.sessionExpiresIn?.activePeriod ?? 1e3 * 60 * 60 * 24,
          idlePeriod: config.sessionExpiresIn?.idlePeriod ?? 1e3 * 60 * 60 * 24 * 14
        };
        this.getUserAttributes = (databaseUser) => {
          const defaultTransform = () => {
            return {};
          };
          const transform = config.getUserAttributes ?? defaultTransform;
          return transform(databaseUser);
        };
        this.getSessionAttributes = (databaseSession) => {
          const defaultTransform = () => {
            return {};
          };
          const transform = config.getSessionAttributes ?? defaultTransform;
          return transform(databaseSession);
        };
        this.csrfProtection = config.csrfProtection ?? true;
        this.sessionCookieConfig = config.sessionCookie ?? {};
        if (config.passwordHash) {
          this.passwordHash = config.passwordHash;
        }
        if (config.middleware) {
          this.middleware = config.middleware;
        }
        this.experimental = {
          debugMode: config.experimental?.debugMode ?? false
        };
        debug.init(this.experimental.debugMode);
      }
    };
    auth = lucia({
      adapter: planetscaleAdapter(connection, {
        key: "tako_user_key",
        session: "tako_user_session",
        user: "tako_auth_user"
      }),
      env: "PROD",
      middleware: sveltekit(),
      getUserAttributes: (data) => {
        return {
          email: data.email
        };
      }
    });
  }
});

// .svelte-kit/output/server/chunks/hooks.server.js
var hooks_server_exports = {};
__export(hooks_server_exports, {
  handle: () => handle
});
var handle;
var init_hooks_server = __esm({
  ".svelte-kit/output/server/chunks/hooks.server.js"() {
    init_lucia();
    handle = async ({ event, resolve }) => {
      event.locals.auth = auth.handleRequest(event);
      return await resolve(event);
    };
  }
});

// .svelte-kit/output/server/chunks/index.js
function error(status, body) {
  if (isNaN(status) || status < 400 || status > 599) {
    throw new Error(`HTTP error status codes must be between 400 and 599 \u2014 ${status} is invalid`);
  }
  return new HttpError(status, body);
}
function redirect(status, location) {
  if (isNaN(status) || status < 300 || status > 308) {
    throw new Error("Invalid status code");
  }
  return new Redirect(status, location.toString());
}
function json(data, init3) {
  const body = JSON.stringify(data);
  const headers = new Headers(init3?.headers);
  if (!headers.has("content-length")) {
    headers.set("content-length", encoder.encode(body).byteLength.toString());
  }
  if (!headers.has("content-type")) {
    headers.set("content-type", "application/json");
  }
  return new Response(body, {
    ...init3,
    headers
  });
}
function text2(body, init3) {
  const headers = new Headers(init3?.headers);
  if (!headers.has("content-length")) {
    const encoded = encoder.encode(body);
    headers.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init3,
      headers
    });
  }
  return new Response(body, {
    ...init3,
    headers
  });
}
function fail(status, data) {
  return new ActionFailure(status, data);
}
var HttpError, Redirect, ActionFailure, encoder;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    HttpError = class {
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body) {
        this.status = status;
        if (typeof body === "string") {
          this.body = { message: body };
        } else if (body) {
          this.body = body;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location) {
        this.status = status;
        this.location = location;
      }
    };
    ActionFailure = class {
      /**
       * @param {number} status
       * @param {T} [data]
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    };
    encoder = new TextEncoder();
  }
});

// .svelte-kit/output/server/chunks/index2.js
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(value));
  }
  function subscribe2(run3, invalidate = noop) {
    const subscriber = [run3, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update2) || noop;
    }
    run3(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set2, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set2, update2);
      if (auto) {
        set2(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i2) => subscribe(
        store,
        (value) => {
          values[i2] = value;
          pending &= ~(1 << i2);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i2;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
function readonly(store) {
  return {
    subscribe: store.subscribe.bind(store)
  };
}
var subscriber_queue;
var init_index2 = __esm({
  ".svelte-kit/output/server/chunks/index2.js"() {
    init_ssr();
    subscriber_queue = [];
  }
});

// .svelte-kit/output/server/chunks/Toaster.svelte_svelte_type_style_lang.js
function toastFunction(message, data) {
  const id = data?.id || toastsCounter++;
  ToastState.addToast({
    title: message,
    ...data,
    id
  });
  return id;
}
var toastsCounter, Observer, ToastState, basicToast, useEffect;
var init_Toaster_svelte_svelte_type_style_lang = __esm({
  ".svelte-kit/output/server/chunks/Toaster.svelte_svelte_type_style_lang.js"() {
    toastsCounter = 0;
    Observer = class {
      constructor() {
        __publicField(this, "subscribers");
        __publicField(this, "toasts");
        // We use arrow functions to maintain the correct `this` reference
        __publicField(this, "subscribe", (subscriber) => {
          this.subscribers.push(subscriber);
          return () => {
            const index8 = this.subscribers.indexOf(subscriber);
            this.subscribers.splice(index8, 1);
          };
        });
        __publicField(this, "publish", (data) => {
          this.subscribers.forEach((subscriber) => subscriber(data));
        });
        __publicField(this, "addToast", (data) => {
          this.publish(data);
          this.toasts = [...this.toasts, data];
        });
        __publicField(this, "create", (data) => {
          const { message, ...rest } = data;
          const id = typeof data?.id === "number" || data.id && data.id?.length > 0 ? data.id : toastsCounter++;
          const alreadyExists = this.toasts.find((toast) => {
            return toast.id === id;
          });
          if (alreadyExists) {
            this.toasts = this.toasts.map((toast) => {
              if (toast.id === id) {
                this.publish({ ...toast, ...data, id, title: message });
                return { ...toast, ...data, id, title: message };
              }
              return toast;
            });
          } else {
            this.addToast({ title: message, ...rest, id });
          }
          return id;
        });
        __publicField(this, "dismiss", (id) => {
          if (!id) {
            this.toasts.forEach((toast) => {
              this.subscribers.forEach((subscriber) => subscriber({ id: toast.id, dismiss: true }));
            });
          }
          this.subscribers.forEach((subscriber) => subscriber({ id, dismiss: true }));
          return id;
        });
        __publicField(this, "message", (message, data) => {
          return this.create({ ...data, message });
        });
        __publicField(this, "error", (message, data) => {
          return this.create({ ...data, message, type: "error" });
        });
        __publicField(this, "success", (message, data) => {
          return this.create({ ...data, type: "success", message });
        });
        __publicField(this, "info", (message, data) => {
          return this.create({ ...data, type: "info", message });
        });
        __publicField(this, "warning", (message, data) => {
          return this.create({ ...data, type: "warning", message });
        });
        __publicField(this, "promise", (promise, data) => {
          const id = this.create({ ...data, promise, type: "loading", message: data?.loading });
          const p2 = promise instanceof Promise ? promise : promise();
          p2.then((promiseData) => {
            const message = typeof data?.success === "function" ? data.success(promiseData) : data?.success;
            this.create({ id, type: "success", message });
          }).catch((error3) => {
            const message = typeof data?.error === "function" ? data.error(error3) : data?.error;
            this.create({ id, type: "error", message });
          });
          return id;
        });
        // We can't provide the toast we just created as a prop as we didn't creat it yet, so we can create a default toast object, I just don't know how to use function in argument when calling()?
        __publicField(this, "custom", (component8, data) => {
          const id = data?.id || toastsCounter++;
          this.publish({ component: component8, id, ...data });
        });
        this.subscribers = [];
        this.toasts = [];
      }
    };
    ToastState = new Observer();
    basicToast = toastFunction;
    Object.assign(basicToast, {
      success: ToastState.success,
      info: ToastState.info,
      warning: ToastState.warning,
      error: ToastState.error,
      custom: ToastState.custom,
      message: ToastState.message,
      promise: ToastState.promise,
      dismiss: ToastState.dismiss
    });
    useEffect = (subscribe2) => ({ subscribe: subscribe2 });
  }
});

// .svelte-kit/output/server/entries/pages/_layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => Layout
});
function getInitialTheme(t) {
  if (t !== "system") {
    return t;
  }
  if (typeof window !== "undefined") {
    if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
      return "dark";
    }
    return "light";
  }
  return "light";
}
var Loader, Icon, TOAST_LIFETIME, GAP$1, TIME_BEFORE_UNMOUNT, Toast, css, VISIBLE_TOASTS_AMOUNT, VIEWPORT_OFFSET, TOAST_WIDTH, GAP, Toaster, Layout;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_ssr();
    init_Toaster_svelte_svelte_type_style_lang();
    Loader = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { visible } = $$props;
      const bars = Array(12).fill(0);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      return `<div class="sonner-loading-wrapper"${add_attribute("data-visible", visible, 0)}><div class="sonner-spinner">${each(bars, (_bar, i2) => {
        return `<div class="sonner-loading-bar"></div>`;
      })}</div></div>`;
    });
    Icon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { type = "success" } = $$props;
      if ($$props.type === void 0 && $$bindings.type && type !== void 0)
        $$bindings.type(type);
      return `${type === "success" ? `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" height="20" width="20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z" clip-rule="evenodd"></path></svg>` : `${type === "error" ? `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" height="20" width="20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"></path></svg>` : `${type === "info" ? `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" height="20" width="20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z" clip-rule="evenodd"></path></svg>` : `${type === "warning" ? `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" height="20" width="20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"></path></svg>` : ``}`}`}`}`;
    });
    TOAST_LIFETIME = 4e3;
    GAP$1 = 14;
    TIME_BEFORE_UNMOUNT = 200;
    Toast = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let isFront;
      let isVisible;
      let toastType;
      let toastClass;
      let toastDescriptionClass;
      let heightIndex;
      let coords;
      let toastsHeightBefore;
      let disabled;
      let isPromiseLoadingOrInfiniteDuration;
      let $$unsubscribe_effect = noop, $$subscribe_effect = () => ($$unsubscribe_effect(), $$unsubscribe_effect = subscribe(effect2, ($$value) => $$value), effect2);
      let { toast } = $$props;
      let { toasts } = $$props;
      let { index: index22 } = $$props;
      let { expanded } = $$props;
      let { invert } = $$props;
      let { heights } = $$props;
      let { position } = $$props;
      let { visibleToasts } = $$props;
      let { expandByDefault } = $$props;
      let { closeButton } = $$props;
      let { interacting } = $$props;
      let { duration } = $$props;
      let { descriptionClass = "" } = $$props;
      let mounted = false;
      let removed = false;
      let swiping = false;
      let swipeOut = false;
      let offsetBeforeRemove = 0;
      let initialHeight = 0;
      let toastRef;
      let offset2 = 0;
      let closeTimerStartTimeRef = 0;
      let closeTimerRemainingTimeRef = toast.duration || duration || TOAST_LIFETIME;
      let lastCloseTimerStartTimeRef = 0;
      const dispatch = createEventDispatcher();
      const deleteToast = () => {
        removed = true;
        offsetBeforeRemove = offset2;
        dispatch("setHeights", heights.filter((height) => height.toastId !== toast.id));
        setTimeout(
          () => {
            dispatch("removeToast", toast);
          },
          TIME_BEFORE_UNMOUNT
        );
      };
      let timeoutId;
      const pauseTimer = () => {
        if (lastCloseTimerStartTimeRef < closeTimerStartTimeRef) {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef;
          closeTimerRemainingTimeRef = closeTimerRemainingTimeRef - elapsedTime;
        }
        lastCloseTimerStartTimeRef = (/* @__PURE__ */ new Date()).getTime();
      };
      const startTimer = () => {
        closeTimerStartTimeRef = (/* @__PURE__ */ new Date()).getTime();
        timeoutId = setTimeout(
          () => {
            toast.onAutoClose?.(toast);
            deleteToast();
          },
          closeTimerRemainingTimeRef
        );
      };
      let effect2;
      onDestroy(() => {
        dispatch("setHeights", heights.filter((height) => height.toastId !== toast.id));
      });
      if ($$props.toast === void 0 && $$bindings.toast && toast !== void 0)
        $$bindings.toast(toast);
      if ($$props.toasts === void 0 && $$bindings.toasts && toasts !== void 0)
        $$bindings.toasts(toasts);
      if ($$props.index === void 0 && $$bindings.index && index22 !== void 0)
        $$bindings.index(index22);
      if ($$props.expanded === void 0 && $$bindings.expanded && expanded !== void 0)
        $$bindings.expanded(expanded);
      if ($$props.invert === void 0 && $$bindings.invert && invert !== void 0)
        $$bindings.invert(invert);
      if ($$props.heights === void 0 && $$bindings.heights && heights !== void 0)
        $$bindings.heights(heights);
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.visibleToasts === void 0 && $$bindings.visibleToasts && visibleToasts !== void 0)
        $$bindings.visibleToasts(visibleToasts);
      if ($$props.expandByDefault === void 0 && $$bindings.expandByDefault && expandByDefault !== void 0)
        $$bindings.expandByDefault(expandByDefault);
      if ($$props.closeButton === void 0 && $$bindings.closeButton && closeButton !== void 0)
        $$bindings.closeButton(closeButton);
      if ($$props.interacting === void 0 && $$bindings.interacting && interacting !== void 0)
        $$bindings.interacting(interacting);
      if ($$props.duration === void 0 && $$bindings.duration && duration !== void 0)
        $$bindings.duration(duration);
      if ($$props.descriptionClass === void 0 && $$bindings.descriptionClass && descriptionClass !== void 0)
        $$bindings.descriptionClass(descriptionClass);
      isFront = index22 === 0;
      isVisible = index22 + 1 <= visibleToasts;
      toastType = toast.type;
      toastClass = toast.class || "";
      toastDescriptionClass = toast.descriptionClass || "";
      heightIndex = heights.findIndex((height) => height.toastId === toast.id) || 0;
      coords = position.split("-");
      toastsHeightBefore = heights.reduce(
        (prev, curr, reducerIndex) => {
          if (reducerIndex >= heightIndex)
            return prev;
          return prev + curr.height;
        },
        0
      );
      invert = toast.invert || invert;
      disabled = toastType === "loading";
      {
        {
          offset2 = heightIndex * GAP$1 + toastsHeightBefore;
        }
      }
      isPromiseLoadingOrInfiniteDuration = toast.promise && toastType === "loading" || toast.duration === Number.POSITIVE_INFINITY;
      $$subscribe_effect(effect2 = useEffect(() => {
        if (!isPromiseLoadingOrInfiniteDuration) {
          if (expanded || interacting) {
            pauseTimer();
          } else {
            startTimer();
          }
        }
        return () => clearTimeout(timeoutId);
      }));
      {
        if (toast.delete) {
          deleteToast();
        }
      }
      $$unsubscribe_effect();
      return `<li${add_attribute("aria-live", toast.important ? "assertive" : "polite", 0)} aria-atomic="true" role="status"${add_attribute("tabindex", 0, 0)}${add_attribute("class", `${$$props.class} ${toastClass}`, 0)} data-sonner-toast=""${add_attribute("data-styled", !toast.component, 0)}${add_attribute("data-mounted", mounted, 0)}${add_attribute("data-promise", Boolean(toast.promise), 0)}${add_attribute("data-removed", removed, 0)}${add_attribute("data-visible", isVisible, 0)}${add_attribute("data-y-position", coords[0], 0)}${add_attribute("data-x-position", coords[1], 0)}${add_attribute("data-index", index22, 0)}${add_attribute("data-front", isFront, 0)}${add_attribute("data-swiping", swiping, 0)}${add_attribute("data-type", toastType, 0)}${add_attribute("data-invert", invert, 0)}${add_attribute("data-swipe-out", swipeOut, 0)}${add_attribute("data-expanded", Boolean(expanded || expandByDefault && mounted), 0)}${add_styles(merge_ssr_styles(escape(`${$$props.style} ${toast.style}`, true), {
        "--index": index22,
        "--toasts-before": index22,
        "--z-index": toasts.length - index22,
        "--offset": `${removed ? offsetBeforeRemove : offset2}px`,
        "--initial-height": expandByDefault ? "auto" : `${initialHeight}px`
      }))}${add_attribute("this", toastRef, 0)}>${closeButton && !toast.component ? `<button aria-label="Close toast"${add_attribute("data-disabled", disabled, 0)} data-close-button><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>` : ``} ${toast.component ? `${validate_component(toast.component || missing_component, "svelte:component").$$render($$result, {}, {}, {})}` : `${toast.title && typeof toast.title !== "string" ? `${validate_component(toast.title || missing_component, "svelte:component").$$render($$result, {}, {}, {})}` : `${toastType || toast.icon || toast.promise ? `<div data-icon="">${toast.promise ? `${validate_component(Loader, "Loader").$$render($$result, { visible: toastType === "loading" }, {}, {})}` : ``} ${toast.icon ? `${validate_component(toast.icon || missing_component, "svelte:component").$$render($$result, {}, {}, {})}` : `${validate_component(Icon, "Icon").$$render($$result, { type: toastType }, {}, {})}`}</div>` : ``} <div data-content=""><div data-title="">${escape(toast.title)}</div> ${toast.description ? `<div data-description=""${add_attribute("class", descriptionClass + toastDescriptionClass, 0)}>${escape(toast.description)}</div>` : ``}</div> ${toast.cancel ? `<button data-button data-cancel>${escape(toast.cancel.label)}</button>` : ``} ${toast.action ? `<button data-button="">${escape(toast.action.label)}</button>` : ``}`}`}</li>`;
    });
    css = {
      code: "[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial,\n      Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:6px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999}[data-sonner-toaster][data-x-position='right']{right:max(var(--offset), env(safe-area-inset-right))}[data-sonner-toaster][data-x-position='left']{left:max(var(--offset), env(safe-area-inset-left))}[data-sonner-toaster][data-x-position='center']{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position='top']{top:max(var(--offset), env(safe-area-inset-top))}[data-sonner-toaster][data-y-position='bottom']{bottom:max(var(--offset), env(safe-area-inset-bottom))}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;will-change:transform, opacity, height;-webkit-transition:transform 400ms, opacity 400ms, height 400ms, box-shadow 200ms;-moz-transition:transform 400ms, opacity 400ms, height 400ms, box-shadow 200ms;transition:transform 400ms, opacity 400ms, height 400ms, box-shadow 200ms;box-sizing:border-box;outline:none}[data-sonner-toast][data-styled='true']{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0px 4px 12px rgba(0, 0, 0, 0.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0px 4px 12px rgba(0, 0, 0, 0.1), 0 0 0 2px rgba(0, 0, 0, 0.2)}[data-sonner-toast][data-y-position='top']{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position='bottom']{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast] [data-description]{font-weight:400;line-height:1.4;color:inherit}[data-sonner-toast] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:-3px;margin-right:4px}[data-sonner-toast][data-promise='true'] [data-icon]>svg{opacity:0;transform:scale(0.8);transform-origin:center;animation:sonner-fade-in 300ms ease forwards}[data-sonner-toast] [data-icon]>*{flex-shrink:0}[data-sonner-toast] [data-icon] svg{margin-left:-1px}[data-sonner-toast] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:auto;border:none;cursor:pointer;outline:none;transition:opacity 400ms, box-shadow 200ms}[data-sonner-toast] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0, 0, 0, 0.4)}[data-sonner-toast] [data-button]:first-of-type{margin-left:auto}[data-sonner-toast] [data-cancel]{color:var(--color);background:var(--border-color)}[data-sonner-toast] [data-close-button]{position:absolute;left:0;top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:translate(-35%, -35%);border-radius:50%;opacity:0;cursor:pointer;z-index:1;transition:opacity 100ms, background 200ms, border-color 200ms}[data-sonner-toast] [data-close-button]:focus-visible{box-shadow:0px 4px 12px rgba(0, 0, 0, 0.1), 0 0 0 2px rgba(0, 0, 0, 0.2)}[data-sonner-toast] [data-disabled='true']{cursor:not-allowed}[data-sonner-toast]:hover [data-close-button]{opacity:1}[data-sonner-toast]:focus [data-close-button]{opacity:1}[data-sonner-toast]:focus-within [data-close-button]{opacity:1}[data-sonner-toast]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping='true']:before{content:'';position:absolute;left:0;right:0;height:100%}[data-sonner-toast][data-y-position='top'][data-swiping='true']:before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position='bottom'][data-swiping='true']:before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping='false'][data-removed='true']:before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast]:after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted='true']{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded='false'][data-front='false']{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity 400ms}[data-sonner-toast][data-expanded='false'][data-front='false'][data-styled='true']>*{opacity:0}[data-sonner-toast][data-visible='false']{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted='true'][data-expanded='true']{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed='true'][data-front='true'][data-swipe-out='false']{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed='true'][data-front='false'][data-swipe-out='false'][data-expanded='true']{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed='true'][data-front='false'][data-swipe-out='false'][data-expanded='false']{--y:translateY(40%);opacity:0;transition:transform 500ms, opacity 200ms}[data-sonner-toast][data-removed='true'][data-front='false']:before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping='true']{transform:var(--y) translateY(var(--swipe-amount, 0px));transition:none}[data-sonner-toast][data-swipe-out='true'][data-y-position='bottom'],[data-sonner-toast][data-swipe-out='true'][data-y-position='top']{animation:swipe-out 200ms ease-out forwards}@keyframes swipe-out{from{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media(max-width: 600px){[data-sonner-toaster]{position:fixed;--mobile-offset:16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - 32px)}[data-sonner-toaster][data-x-position='left']{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position='bottom']{bottom:20px}[data-sonner-toaster][data-y-position='top']{top:20px}[data-sonner-toaster][data-x-position='center']{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme='light']{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 91%);--success-text:hsl(140, 100%, 27%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%);--info-bg:hsl(210, 85%, 96%);--info-border:hsl(210, 92%, 91%);--info-text:hsl(210, 100%, 27%);--warning-bg:hsl(60, 85%, 96%);--warning-border:hsl(60, 92%, 91%);--warning-text:hsl(60, 100%, 19%)}[data-sonner-toaster][data-theme='light'] [data-sonner-toast][data-invert='true']{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-theme='dark'] [data-sonner-toast][data-invert='true']{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-theme='dark']{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%);--info-bg:hsl(210, 100%, 6%);--info-border:hsl(207, 100%, 12%);--info-text:hsl(210, 86%, 65%);--warning-bg:hsl(60, 100%, 6%);--warning-border:hsl(57, 100%, 12%);--warning-text:hsl(60, 86%, 65%)}[data-rich-colors='true'] [data-sonner-toast][data-type='success']{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors='true'] [data-sonner-toast][data-type='success'] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors='true'] [data-sonner-toast][data-type='error']{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors='true'] [data-sonner-toast][data-type='error'] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors='true'] [data-sonner-toast][data-type='info']{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors='true'] [data-sonner-toast][data-type='info'] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors='true'] [data-sonner-toast][data-type='warning']{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors='true'] [data-sonner-toast][data-type='warning'] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible='false']{transform-origin:center;animation:sonner-fade-out 0.2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(0.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-0.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-0.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-0.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-0.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-0.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-0.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-0.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-0.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-0.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:0.15}}@media(prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none !important;animation:none !important}}",
      map: null
    };
    VISIBLE_TOASTS_AMOUNT = 3;
    VIEWPORT_OFFSET = "32px";
    TOAST_WIDTH = 356;
    GAP = 14;
    Toaster = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let coords;
      let hotkeyLabel;
      let { invert = false } = $$props;
      let { theme = "light" } = $$props;
      let { position = "bottom-right" } = $$props;
      let { hotkey = ["altKey", "KeyT"] } = $$props;
      let { richColors = false } = $$props;
      let { expand = false } = $$props;
      let { duration = null } = $$props;
      let { visibleToasts = VISIBLE_TOASTS_AMOUNT } = $$props;
      let { closeButton = false } = $$props;
      let { toastOptions = {} } = $$props;
      let { offset: offset2 = null } = $$props;
      let toasts = [];
      let heights = [];
      let expanded = false;
      let interacting = false;
      getInitialTheme(theme);
      let listRef;
      onDestroy(() => {
      });
      if ($$props.invert === void 0 && $$bindings.invert && invert !== void 0)
        $$bindings.invert(invert);
      if ($$props.theme === void 0 && $$bindings.theme && theme !== void 0)
        $$bindings.theme(theme);
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.hotkey === void 0 && $$bindings.hotkey && hotkey !== void 0)
        $$bindings.hotkey(hotkey);
      if ($$props.richColors === void 0 && $$bindings.richColors && richColors !== void 0)
        $$bindings.richColors(richColors);
      if ($$props.expand === void 0 && $$bindings.expand && expand !== void 0)
        $$bindings.expand(expand);
      if ($$props.duration === void 0 && $$bindings.duration && duration !== void 0)
        $$bindings.duration(duration);
      if ($$props.visibleToasts === void 0 && $$bindings.visibleToasts && visibleToasts !== void 0)
        $$bindings.visibleToasts(visibleToasts);
      if ($$props.closeButton === void 0 && $$bindings.closeButton && closeButton !== void 0)
        $$bindings.closeButton(closeButton);
      if ($$props.toastOptions === void 0 && $$bindings.toastOptions && toastOptions !== void 0)
        $$bindings.toastOptions(toastOptions);
      if ($$props.offset === void 0 && $$bindings.offset && offset2 !== void 0)
        $$bindings.offset(offset2);
      $$result.css.add(css);
      coords = position.split("-");
      hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      {
        if (toasts.length <= 1) {
          expanded = false;
        }
      }
      return `${toasts.length > 0 ? `<section${add_attribute("aria-label", `Notifications ${hotkeyLabel}`, 0)}${add_attribute("tabindex", -1, 0)}><ol${add_attribute("tabindex", -1, 0)}${add_attribute("class", $$props.class, 0)} data-sonner-toaster${add_attribute("data-theme", theme, 0)}${add_attribute("data-rich-colors", richColors, 0)}${add_attribute("data-y-position", coords[0], 0)}${add_attribute("data-x-position", coords[1], 0)}${add_styles(merge_ssr_styles(escape($$props.style, true), {
        "--front-toast-height": `${heights[0]?.height}px`,
        "--offset": typeof offset2 === "number" ? `${offset2}px` : offset2 || VIEWPORT_OFFSET,
        "--width": `${TOAST_WIDTH}px`,
        "--gap": `${GAP}px`
      }))}${add_attribute("this", listRef, 0)}>${each(toasts, (toast, index22) => {
        return `${validate_component(Toast, "Toast").$$render(
          $$result,
          {
            index: index22,
            toast,
            duration,
            class: toastOptions?.class,
            descriptionClass: toastOptions?.descriptionClass,
            invert: Boolean(invert),
            visibleToasts,
            closeButton: Boolean(closeButton),
            interacting,
            position,
            style: toastOptions?.style ?? "",
            toasts,
            heights,
            expandByDefault: Boolean(expand),
            expanded
          },
          {},
          {}
        )}`;
      })}</ol></section>` : ``}`;
    });
    Layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Toaster, "Toaster").$$render($$result, {}, {}, {})} ${slots.default ? slots.default({}) : ``}`;
    });
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  stylesheets: () => stylesheets
});
var index, component_cache, component, imports, stylesheets, fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    index = 0;
    component = async () => component_cache ?? (component_cache = (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default);
    imports = ["_app/immutable/nodes/0.55d8856c.js", "_app/immutable/chunks/scheduler.e51e3a72.js", "_app/immutable/chunks/index.70313ae9.js", "_app/immutable/chunks/each.ed497e26.js", "_app/immutable/chunks/Toaster.svelte_svelte_type_style_lang.7ad7c14e.js"];
    stylesheets = ["_app/immutable/assets/0.c57fa6e9.css", "_app/immutable/assets/Toaster.37b6ac62.css"];
    fonts = ["_app/immutable/assets/fira-code-cyrillic-ext-400-normal.aeaf7f0a.woff2", "_app/immutable/assets/fira-code-cyrillic-ext-400-normal.96b1b870.woff", "_app/immutable/assets/fira-code-cyrillic-400-normal.dac6dde5.woff2", "_app/immutable/assets/fira-code-cyrillic-400-normal.b0cb6f39.woff", "_app/immutable/assets/fira-code-greek-ext-400-normal.9abd2774.woff2", "_app/immutable/assets/fira-code-greek-ext-400-normal.8c540835.woff", "_app/immutable/assets/fira-code-greek-400-normal.ab9177a1.woff2", "_app/immutable/assets/fira-code-greek-400-normal.f70ef159.woff", "_app/immutable/assets/fira-code-latin-ext-400-normal.5e162e63.woff2", "_app/immutable/assets/fira-code-latin-ext-400-normal.315dc11c.woff", "_app/immutable/assets/fira-code-latin-400-normal.2b407eb4.woff2", "_app/immutable/assets/fira-code-latin-400-normal.59bca7e3.woff", "_app/immutable/assets/inter-cyrillic-ext-400-normal.f7666a51.woff2", "_app/immutable/assets/inter-cyrillic-ext-400-normal.f83f176b.woff", "_app/immutable/assets/inter-cyrillic-400-normal.e9493683.woff2", "_app/immutable/assets/inter-cyrillic-400-normal.3a27cac9.woff", "_app/immutable/assets/inter-greek-ext-400-normal.d3e30cde.woff2", "_app/immutable/assets/inter-greek-ext-400-normal.37983db3.woff", "_app/immutable/assets/inter-greek-400-normal.2f2d421a.woff2", "_app/immutable/assets/inter-greek-400-normal.f8bb5355.woff", "_app/immutable/assets/inter-vietnamese-400-normal.5779ad5e.woff", "_app/immutable/assets/inter-latin-ext-400-normal.64a98f58.woff2", "_app/immutable/assets/inter-latin-ext-400-normal.495669c6.woff", "_app/immutable/assets/inter-latin-400-normal.0364d368.woff2", "_app/immutable/assets/inter-latin-400-normal.e3982e96.woff"];
  }
});

// .svelte-kit/output/server/chunks/stores.js
var getStores, page;
var init_stores = __esm({
  ".svelte-kit/output/server/chunks/stores.js"() {
    init_ssr();
    getStores = () => {
      const stores = getContext("__svelte__");
      return {
        /** @type {typeof page} */
        page: {
          subscribe: stores.page.subscribe
        },
        /** @type {typeof navigating} */
        navigating: {
          subscribe: stores.navigating.subscribe
        },
        /** @type {typeof updated} */
        updated: stores.updated
      };
    };
    page = {
      subscribe(fn) {
        const store = getStores().page;
        return store.subscribe(fn);
      }
    };
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error2
});
var Error2;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_ssr();
    init_stores();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $page, $$unsubscribe_page;
      $$unsubscribe_page = subscribe(page, (value) => $page = value);
      $$unsubscribe_page();
      return `<h1>${escape($page.status)}</h1> <p>${escape($page.error?.message)}</p>`;
    });
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2, component_cache2, component2, imports2, stylesheets2, fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    index2 = 1;
    component2 = async () => component_cache2 ?? (component_cache2 = (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default);
    imports2 = ["_app/immutable/nodes/1.7181729c.js", "_app/immutable/chunks/scheduler.e51e3a72.js", "_app/immutable/chunks/index.70313ae9.js", "_app/immutable/chunks/stores.7848577e.js", "_app/immutable/chunks/singletons.844f0d64.js", "_app/immutable/chunks/index.6cb2aa35.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});

// .svelte-kit/output/server/entries/pages/(authed)/_layout.server.ts.js
var layout_server_ts_exports = {};
__export(layout_server_ts_exports, {
  load: () => load
});
function sortItems(items) {
  return items?.sort((a2, b) => {
    if (a2.type === "folder" && b.type === "file")
      return -1;
    else if (a2.type === "file" && b.type === "folder")
      return 1;
    return a2.name.localeCompare(b.name);
  }) ?? [];
}
function createItemTreeFromList(list) {
  const map2 = {};
  const roots = [];
  for (let i2 = 0; i2 < list.length; i2 += 1) {
    map2[list[i2].id] = i2;
    list[i2].children = [];
  }
  for (let i2 = 0; i2 < list.length; i2 += 1) {
    const node = list[i2];
    if (node.parentId !== null) {
      list[map2[node.parentId]].children?.push(node);
      if (list[map2[node.parentId]].children)
        list[map2[node.parentId]].children = sortItems(list[map2[node.parentId]].children);
    } else {
      roots.push(node);
    }
  }
  return sortItems(roots);
}
var load;
var init_layout_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/(authed)/_layout.server.ts.js"() {
    init_index3();
    init_chunks();
    load = async ({ locals }) => {
      const session2 = await locals.auth.validate();
      if (!session2)
        throw redirect(302, "/signin");
      const items = await db.query.itemsTable.findMany({
        where: (table, { eq: eq2 }) => eq2(table.userId, session2.user.userId)
      });
      return {
        session: session2,
        items: createItemTreeFromList(items)
      };
    };
  }
});

// node_modules/.pnpm/clsx@2.0.0/node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e)
    n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    else
      for (t in e)
        e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length; )
    (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var init_clsx = __esm({
  "node_modules/.pnpm/clsx@2.0.0/node_modules/clsx/dist/clsx.mjs"() {
  }
});

// node_modules/.pnpm/tailwind-variants@0.1.14_tailwindcss@3.3.3/node_modules/tailwind-variants/dist/chunk-FHRYMRZ3.js
function i(t, e) {
  t.forEach(function(n) {
    Array.isArray(n) ? i(n, e) : e.push(n);
  });
}
function y(t) {
  let e = [];
  return i(t, e), e;
}
var a, l, u, x, p, g;
var init_chunk_FHRYMRZ3 = __esm({
  "node_modules/.pnpm/tailwind-variants@0.1.14_tailwindcss@3.3.3/node_modules/tailwind-variants/dist/chunk-FHRYMRZ3.js"() {
    a = (t) => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t;
    l = (t) => !t || typeof t != "object" || Object.keys(t).length === 0;
    u = (t, e) => JSON.stringify(t) === JSON.stringify(e);
    x = (...t) => y(t).filter(Boolean);
    p = (t, e) => {
      let n = {}, c = Object.keys(t), f = Object.keys(e);
      for (let o of c)
        if (f.includes(o)) {
          let r2 = t[o], s2 = e[o];
          typeof r2 == "object" && typeof s2 == "object" ? n[o] = p(r2, s2) : n[o] = s2 + " " + r2;
        } else
          n[o] = t[o];
      for (let o of f)
        c.includes(o) || (n[o] = e[o]);
      return n;
    };
    g = (t) => !t || typeof t != "string" ? t : t.replace(/\s+/g, " ").trim();
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/tw-join.mjs
function twJoin() {
  var index8 = 0;
  var argument;
  var resolvedValue;
  var string = "";
  while (index8 < arguments.length) {
    if (argument = arguments[index8++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  var resolvedValue;
  var string = "";
  for (var k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var init_tw_join = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/tw-join.mjs"() {
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/class-utils.mjs
function createClassUtils(config) {
  var classMap = createClassMap(config);
  var conflictingClassGroups = config.conflictingClassGroups, _config$conflictingCl = config.conflictingClassGroupModifiers, conflictingClassGroupModifiers = _config$conflictingCl === void 0 ? {} : _config$conflictingCl;
  function getClassGroupId(className) {
    var classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    var conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [].concat(conflicts, conflictingClassGroupModifiers[classGroupId]);
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  var currentClassPart = classParts[0];
  var nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  var classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  var classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(function(_ref) {
    var validator2 = _ref.validator;
    return validator2(classRest);
  })?.classGroupId;
}
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    var arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    var property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config) {
  var theme = config.theme, prefix = config.prefix;
  var classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  var prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(function(_ref2) {
    var classGroupId = _ref2[0], classGroup = _ref2[1];
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach(function(classDefinition) {
    if (typeof classDefinition === "string") {
      var classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(function(_ref3) {
      var key3 = _ref3[0], classGroup2 = _ref3[1];
      processClassesRecursively(classGroup2, getPart(classPartObject, key3), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path) {
  var currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach(function(pathPart) {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(function(_ref4) {
    var classGroupId = _ref4[0], classGroup = _ref4[1];
    var prefixedClassGroup = classGroup.map(function(classDefinition) {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(function(_ref5) {
          var key3 = _ref5[0], value = _ref5[1];
          return [prefix + key3, value];
        }));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
var CLASS_PART_SEPARATOR, arbitraryPropertyRegex;
var init_class_utils = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/class-utils.mjs"() {
    CLASS_PART_SEPARATOR = "-";
    arbitraryPropertyRegex = /^\[(.+)\]$/;
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/lru-cache.mjs
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: function get4() {
        return void 0;
      },
      set: function set2() {
      }
    };
  }
  var cacheSize = 0;
  var cache = /* @__PURE__ */ new Map();
  var previousCache = /* @__PURE__ */ new Map();
  function update2(key3, value) {
    cache.set(key3, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }
  return {
    get: function get4(key3) {
      var value = cache.get(key3);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key3)) !== void 0) {
        update2(key3, value);
        return value;
      }
    },
    set: function set2(key3, value) {
      if (cache.has(key3)) {
        cache.set(key3, value);
      } else {
        update2(key3, value);
      }
    }
  };
}
var init_lru_cache = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/lru-cache.mjs"() {
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/modifier-utils.mjs
function createSplitModifiers(config) {
  var separator = config.separator || ":";
  var isSeparatorSingleCharacter = separator.length === 1;
  var firstSeparatorCharacter = separator[0];
  var separatorLength = separator.length;
  return function splitModifiers(className) {
    var modifiers2 = [];
    var bracketDepth = 0;
    var modifierStart = 0;
    var postfixModifierPosition;
    for (var index8 = 0; index8 < className.length; index8++) {
      var currentCharacter = className[index8];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index8, index8 + separatorLength) === separator)) {
          modifiers2.push(className.slice(modifierStart, index8));
          modifierStart = index8 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index8;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    var baseClassNameWithImportantModifier = modifiers2.length === 0 ? className : className.substring(modifierStart);
    var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    var maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers: modifiers2,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers2) {
  if (modifiers2.length <= 1) {
    return modifiers2;
  }
  var sortedModifiers = [];
  var unsortedModifiers = [];
  modifiers2.forEach(function(modifier) {
    var isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());
  return sortedModifiers;
}
var IMPORTANT_MODIFIER;
var init_modifier_utils = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/modifier-utils.mjs"() {
    IMPORTANT_MODIFIER = "!";
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/config-utils.mjs
function createConfigUtils(config) {
  return {
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config),
    ...createClassUtils(config)
  };
}
var init_config_utils = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/config-utils.mjs"() {
    init_class_utils();
    init_lru_cache();
    init_modifier_utils();
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/merge-classlist.mjs
function mergeClassList(classList, configUtils) {
  var splitModifiers = configUtils.splitModifiers, getClassGroupId = configUtils.getClassGroupId, getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;
  var classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map(function(originalClassName) {
    var _splitModifiers = splitModifiers(originalClassName), modifiers2 = _splitModifiers.modifiers, hasImportantModifier = _splitModifiers.hasImportantModifier, baseClassName = _splitModifiers.baseClassName, maybePostfixModifierPosition = _splitModifiers.maybePostfixModifierPosition;
    var classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    var hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    var variantModifier = sortModifiers(modifiers2).join(":");
    var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter(function(parsed) {
    if (!parsed.isTailwindClass) {
      return true;
    }
    var modifierId = parsed.modifierId, classGroupId = parsed.classGroupId, hasPostfixModifier = parsed.hasPostfixModifier;
    var classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(function(group) {
      return classGroupsInConflict.add(modifierId + group);
    });
    return true;
  }).reverse().map(function(parsed) {
    return parsed.originalClassName;
  }).join(" ");
}
var SPLIT_CLASSES_REGEX;
var init_merge_classlist = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/merge-classlist.mjs"() {
    init_modifier_utils();
    SPLIT_CLASSES_REGEX = /\s+/;
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/create-tailwind-merge.mjs
function createTailwindMerge() {
  for (var _len = arguments.length, createConfig = new Array(_len), _key = 0; _key < _len; _key++) {
    createConfig[_key] = arguments[_key];
  }
  var configUtils;
  var cacheGet;
  var cacheSet;
  var functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    var firstCreateConfig = createConfig[0], restCreateConfig = createConfig.slice(1);
    var config = restCreateConfig.reduce(function(previousConfig, createConfigCurrent) {
      return createConfigCurrent(previousConfig);
    }, firstCreateConfig());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    var cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    var result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var init_create_tailwind_merge = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/create-tailwind-merge.mjs"() {
    init_config_utils();
    init_merge_classlist();
    init_tw_join();
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/from-theme.mjs
function fromTheme(key3) {
  var themeGetter = function themeGetter2(theme) {
    return theme[key3] || [];
  };
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
var init_from_theme = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/from-theme.mjs"() {
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/validators.mjs
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value) || isArbitraryLength(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, "size", isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
function isArbitraryUrl(value) {
  return getIsArbitraryValue(value, "url", isUrl);
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isNumber(value) {
  return !Number.isNaN(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isInteger(value) {
  return isIntegerOnly(value) || getIsArbitraryValue(value, "number", isIntegerOnly);
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isAny() {
  return true;
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function getIsArbitraryValue(value, label, testValue) {
  var result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return result[1] === label;
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value);
}
function isNever() {
  return false;
}
function isUrl(value) {
  return value.startsWith("url(");
}
function isIntegerOnly(value) {
  return Number.isInteger(Number(value));
}
function isShadow(value) {
  return shadowRegex.test(value);
}
var arbitraryValueRegex, fractionRegex, stringLengths, tshirtUnitRegex, lengthUnitRegex, shadowRegex;
var init_validators = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/validators.mjs"() {
    arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
    fractionRegex = /^\d+\/\d+$/;
    stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
    tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
    lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
    shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/default-config.mjs
function getDefaultConfig() {
  var colors = fromTheme("colors");
  var spacing = fromTheme("spacing");
  var blur2 = fromTheme("blur");
  var brightness = fromTheme("brightness");
  var borderColor = fromTheme("borderColor");
  var borderRadius = fromTheme("borderRadius");
  var borderSpacing = fromTheme("borderSpacing");
  var borderWidth = fromTheme("borderWidth");
  var contrast = fromTheme("contrast");
  var grayscale = fromTheme("grayscale");
  var hueRotate = fromTheme("hueRotate");
  var invert = fromTheme("invert");
  var gap = fromTheme("gap");
  var gradientColorStops = fromTheme("gradientColorStops");
  var gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  var inset = fromTheme("inset");
  var margin = fromTheme("margin");
  var opacity = fromTheme("opacity");
  var padding = fromTheme("padding");
  var saturate = fromTheme("saturate");
  var scale = fromTheme("scale");
  var sepia = fromTheme("sepia");
  var skew = fromTheme("skew");
  var space = fromTheme("space");
  var translate = fromTheme("translate");
  var getOverscroll = function getOverscroll2() {
    return ["auto", "contain", "none"];
  };
  var getOverflow = function getOverflow2() {
    return ["auto", "hidden", "clip", "visible", "scroll"];
  };
  var getSpacingWithAutoAndArbitrary = function getSpacingWithAutoAndArbitrary2() {
    return ["auto", isArbitraryValue, spacing];
  };
  var getSpacingWithArbitrary = function getSpacingWithArbitrary2() {
    return [isArbitraryValue, spacing];
  };
  var getLengthWithEmpty = function getLengthWithEmpty2() {
    return ["", isLength];
  };
  var getNumberWithAutoAndArbitrary = function getNumberWithAutoAndArbitrary2() {
    return ["auto", isNumber, isArbitraryValue];
  };
  var getPositions = function getPositions2() {
    return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  };
  var getLineStyles = function getLineStyles2() {
    return ["solid", "dashed", "dotted", "double", "none"];
  };
  var getBlendModes = function getBlendModes2() {
    return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  };
  var getAlign = function getAlign2() {
    return ["start", "end", "center", "between", "around", "evenly", "stretch"];
  };
  var getZeroAndEmpty = function getZeroAndEmpty2() {
    return ["", "0", isArbitraryValue];
  };
  var getBreaks = function getBreaks2() {
    return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  };
  var getNumber = function getNumber2() {
    return [isNumber, isArbitraryNumber];
  };
  var getNumberAndArbitrary = function getNumberAndArbitrary2() {
    return [isNumber, isArbitraryValue];
  };
  return {
    cacheSize: 500,
    theme: {
      colors: [isAny],
      spacing: [isLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmpty(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      "float": [{
        "float": ["right", "left", "none"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [].concat(getPositions(), [isArbitraryValue])
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal"].concat(getAlign())
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal"].concat(getAlign(), ["baseline"])
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [].concat(getAlign(), ["baseline"])
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": ["min", "max", "fit", isArbitraryValue, isLength]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize, isArbitraryValue]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["min", "max", "fit", isArbitraryValue, isLength]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isArbitraryValue, isLength]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [].concat(getLineStyles(), ["wavy"])
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isArbitraryValue, isLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      "break": [{
        "break": ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [].concat(getPositions(), [isArbitraryPosition])
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryUrl]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [].concat(getLineStyles(), ["hidden"])
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [""].concat(getLineStyles())
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isArbitraryValue, isLength]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmpty()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur2]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur2]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: ["appearance-none"],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "pinch-zoom", "manipulation", {
          pan: ["x", "left", "right", "y", "up", "down"]
        }]
      }],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
var init_default_config = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/default-config.mjs"() {
    init_from_theme();
    init_validators();
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/merge-configs.mjs
function mergeConfigs(baseConfig, configExtension) {
  for (var key3 in configExtension) {
    mergePropertyRecursively(baseConfig, key3, configExtension[key3]);
  }
  return baseConfig;
}
function mergePropertyRecursively(baseObject, mergeKey, mergeValue) {
  if (!hasOwnProperty.call(baseObject, mergeKey) || overrideTypes.has(typeof mergeValue) || mergeValue === null) {
    baseObject[mergeKey] = mergeValue;
    return;
  }
  if (Array.isArray(mergeValue) && Array.isArray(baseObject[mergeKey])) {
    baseObject[mergeKey] = baseObject[mergeKey].concat(mergeValue);
    return;
  }
  if (typeof mergeValue === "object" && typeof baseObject[mergeKey] === "object") {
    if (baseObject[mergeKey] === null) {
      baseObject[mergeKey] = mergeValue;
      return;
    }
    for (var nextKey in mergeValue) {
      mergePropertyRecursively(baseObject[mergeKey], nextKey, mergeValue[nextKey]);
    }
  }
}
var hasOwnProperty, overrideTypes;
var init_merge_configs = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/merge-configs.mjs"() {
    hasOwnProperty = Object.prototype.hasOwnProperty;
    overrideTypes = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/extend-tailwind-merge.mjs
function extendTailwindMerge(configExtension) {
  for (var _len = arguments.length, createConfig = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    createConfig[_key - 1] = arguments[_key];
  }
  return typeof configExtension === "function" ? createTailwindMerge.apply(void 0, [getDefaultConfig, configExtension].concat(createConfig)) : createTailwindMerge.apply(void 0, [function() {
    return mergeConfigs(getDefaultConfig(), configExtension);
  }].concat(createConfig));
}
var init_extend_tailwind_merge = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/extend-tailwind-merge.mjs"() {
    init_create_tailwind_merge();
    init_default_config();
    init_merge_configs();
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/tw-merge.mjs
var twMerge;
var init_tw_merge = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/lib/tw-merge.mjs"() {
    init_create_tailwind_merge();
    init_default_config();
    twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
  }
});

// node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/tailwind-merge.mjs
var init_tailwind_merge = __esm({
  "node_modules/.pnpm/tailwind-merge@1.14.0/node_modules/tailwind-merge/dist/tailwind-merge.mjs"() {
    init_extend_tailwind_merge();
    init_tw_merge();
  }
});

// node_modules/.pnpm/tailwind-variants@0.1.14_tailwindcss@3.3.3/node_modules/tailwind-variants/dist/index.js
var re2, Z, j, B, O, R, A, Y, ce;
var init_dist3 = __esm({
  "node_modules/.pnpm/tailwind-variants@0.1.14_tailwindcss@3.3.3/node_modules/tailwind-variants/dist/index.js"() {
    init_chunk_FHRYMRZ3();
    init_tailwind_merge();
    re2 = { twMerge: true, twMergeConfig: {}, responsiveVariants: false };
    Z = (i2) => i2 || void 0;
    j = (...i2) => Z(y(i2).filter(Boolean).join(" "));
    B = null;
    O = {};
    R = false;
    A = (...i2) => (v) => v.twMerge ? ((!B || R) && (R = false, B = l(O) ? twMerge : extendTailwindMerge(O)), Z(B(j(i2)))) : j(i2);
    Y = (i2, v) => {
      for (let e in v)
        i2.hasOwnProperty(e) ? i2[e] = j(i2[e], v[e]) : i2[e] = v[e];
      return i2;
    };
    ce = (i2, v) => {
      let { extend: e$1 = null, slots: N = {}, variants: q = {}, compoundVariants: C = [], compoundSlots: V = [], defaultVariants: F = {} } = i2, m = { ...re2, ...v }, M = e$1 != null && e$1.base ? j(e$1.base, i2 == null ? void 0 : i2.base) : i2 == null ? void 0 : i2.base, g$1 = e$1 != null && e$1.variants && !l(e$1.variants) ? p(q, e$1.variants) : q, h = e$1 != null && e$1.defaultVariants && !l(e$1.defaultVariants) ? { ...e$1.defaultVariants, ...F } : F;
      !l(m.twMergeConfig) && !u(m.twMergeConfig, O) && (R = true, O = m.twMergeConfig);
      let $ = l(N) ? {} : { base: i2 == null ? void 0 : i2.base, ...N }, w = l(e$1 == null ? void 0 : e$1.slots) ? $ : Y(e$1 == null ? void 0 : e$1.slots, l($) ? { base: i2 == null ? void 0 : i2.base } : $), d = (f) => {
        if (l(g$1) && l(N) && l(e$1 == null ? void 0 : e$1.slots))
          return A(M, f == null ? void 0 : f.class, f == null ? void 0 : f.className)(m);
        if (C && !Array.isArray(C))
          throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof C}`);
        if (V && !Array.isArray(V))
          throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof V}`);
        let K = (t, n, a2 = [], s2) => {
          let r2 = a2;
          if (typeof n == "string")
            r2 = r2.concat(g(n).split(" ").map((l2) => `${t}:${l2}`));
          else if (Array.isArray(n))
            r2 = r2.concat(n.reduce((l2, c) => l2.concat(`${t}:${c}`), []));
          else if (typeof n == "object" && typeof s2 == "string") {
            for (let l2 in n)
              if (n.hasOwnProperty(l2) && l2 === s2) {
                let c = n[l2];
                if (c && typeof c == "string") {
                  let y2 = g(c);
                  r2[s2] ? r2[s2] = r2[s2].concat(y2.split(" ").map((u2) => `${t}:${u2}`)) : r2[s2] = y2.split(" ").map((u2) => `${t}:${u2}`);
                } else
                  Array.isArray(c) && c.length > 0 && (r2[s2] = c.reduce((y2, u2) => y2.concat(`${t}:${u2}`), []));
              }
          }
          return r2;
        }, U = (t, n = g$1, a$1 = null, s2 = null) => {
          var H;
          let r2 = n[t];
          if (!r2 || l(r2))
            return null;
          let l2 = (H = s2 == null ? void 0 : s2[t]) != null ? H : f == null ? void 0 : f[t];
          if (l2 === null)
            return null;
          let c = a(l2), y2 = Array.isArray(m.responsiveVariants) && m.responsiveVariants.length > 0 || m.responsiveVariants === true, u2 = h == null ? void 0 : h[t], b$1 = [];
          if (typeof c == "object" && y2)
            for (let [k, I] of Object.entries(c)) {
              let te = r2[I];
              if (k === "initial") {
                u2 = I;
                continue;
              }
              Array.isArray(m.responsiveVariants) && !m.responsiveVariants.includes(k) || (b$1 = K(k, te, b$1, a$1));
            }
          let S = r2[c] || r2[a(u2)];
          return typeof b$1 == "object" && typeof a$1 == "string" && b$1[a$1] ? Y(b$1, S) : b$1.length > 0 ? (b$1.push(S), b$1) : S;
        }, x2 = () => g$1 ? Object.keys(g$1).map((t) => U(t, g$1)) : null, P = (t, n) => {
          if (!g$1 || typeof g$1 != "object")
            return null;
          let a2 = new Array();
          for (let s2 in g$1) {
            let r2 = U(s2, g$1, t, n), l2 = t === "base" && typeof r2 == "string" ? r2 : r2 && r2[t];
            l2 && (a2[a2.length] = l2);
          }
          return a2;
        }, W = {};
        for (let t in f)
          f[t] !== void 0 && (W[t] = f[t]);
        let z2 = (t, n) => {
          var s2;
          let a2 = typeof (f == null ? void 0 : f[t]) == "object" ? { [t]: (s2 = f[t]) == null ? void 0 : s2.initial } : {};
          return { ...h, ...W, ...a2, ...n };
        }, D = (t = [], n) => {
          let a2 = [];
          for (let { class: s2, className: r2, ...l2 } of t) {
            let c = true;
            for (let [y2, u2] of Object.entries(l2)) {
              let b = z2(y2, n);
              if (Array.isArray(u2)) {
                if (!u2.includes(b[y2])) {
                  c = false;
                  break;
                }
              } else if (b[y2] !== u2) {
                c = false;
                break;
              }
            }
            c && (s2 && a2.push(s2), r2 && a2.push(r2));
          }
          return a2;
        }, G = (t) => {
          let n = D(C, t), a2 = D(e$1 == null ? void 0 : e$1.compoundVariants, t);
          return x(a2, n);
        }, p2 = (t) => {
          let n = G(t);
          if (!Array.isArray(n))
            return n;
          let a2 = {};
          for (let s2 of n)
            if (typeof s2 == "string" && (a2.base = A(a2.base, s2)(m)), typeof s2 == "object")
              for (let [r2, l2] of Object.entries(s2))
                a2[r2] = A(a2[r2], l2)(m);
          return a2;
        }, ee = (t) => {
          if (V.length < 1)
            return null;
          let n = {};
          for (let { slots: a2 = [], class: s2, className: r2, ...l2 } of V) {
            if (!l(l2)) {
              let c = true;
              for (let y2 of Object.keys(l2)) {
                let u2 = z2(y2, t)[y2];
                if (u2 === void 0 || u2 !== l2[y2]) {
                  c = false;
                  break;
                }
              }
              if (!c)
                continue;
            }
            for (let c of a2)
              n[c] = n[c] || [], n[c].push([s2, r2]);
          }
          return n;
        };
        if (!l(N) || !l(e$1 == null ? void 0 : e$1.slots)) {
          let t = {};
          if (typeof w == "object" && !l(w))
            for (let n of Object.keys(w))
              t[n] = (a2) => {
                var s2, r2;
                return A(w[n], P(n, a2), ((s2 = p2(a2)) != null ? s2 : [])[n], ((r2 = ee(a2)) != null ? r2 : [])[n], a2 == null ? void 0 : a2.class, a2 == null ? void 0 : a2.className)(m);
              };
          return t;
        }
        return A(M, x2(), G(), f == null ? void 0 : f.class, f == null ? void 0 : f.className)(m);
      }, _ = () => {
        if (!(!g$1 || typeof g$1 != "object"))
          return Object.keys(g$1);
      };
      return d.variantKeys = _(), d.extend = e$1, d.base = M, d.slots = w, d.variants = g$1, d.defaultVariants = h, d.compoundSlots = V, d.compoundVariants = C, d;
    };
  }
});

// .svelte-kit/output/server/entries/pages/(authed)/_layout.svelte.js
var layout_svelte_exports2 = {};
__export(layout_svelte_exports2, {
  default: () => Layout2
});
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component8 = dirty_components[flushidx];
        flushidx++;
        set_current_component(component8);
        update(component8.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function is_void(name22) {
  return void_element_names.test(name22) || name22.toLowerCase() === "!doctype";
}
function client_method(key3) {
  {
    if (key3 === "before_navigate" || key3 === "after_navigate" || key3 === "on_navigate") {
      return () => {
      };
    } else {
      const name_lookup = {
        disable_scroll_handling: "disableScrollHandling",
        preload_data: "preloadData",
        preload_code: "preloadCode",
        invalidate_all: "invalidateAll"
      };
      return () => {
        throw new Error(`Cannot call ${name_lookup[key3] ?? key3}(...) on the server`);
      };
    }
  }
}
function last(array2) {
  return array2[array2.length - 1];
}
function wrapArray(array2, startIndex) {
  return array2.map((_, index8) => array2[(startIndex + index8) % array2.length]);
}
function lightable(value) {
  function subscribe2(run3) {
    run3(value);
    return () => {
    };
  }
  return { subscribe: subscribe2 };
}
function builder(name22, args) {
  const { stores, action, returned } = args ?? {};
  const derivedStore = (() => {
    if (stores && returned) {
      return derived(stores, (values) => {
        const result = returned(values);
        if (isFunctionWithParams(result)) {
          const fn = (...args2) => {
            return hiddenAction({
              ...result(...args2),
              [`data-melt-${name22}`]: "",
              action: action ?? noop2
            });
          };
          fn.action = action ?? noop2;
          return fn;
        }
        return hiddenAction({
          ...result,
          [`data-melt-${name22}`]: "",
          action: action ?? noop2
        });
      });
    } else {
      const returnedFn = returned;
      const result = returnedFn?.();
      if (isFunctionWithParams(result)) {
        const resultFn = (...args2) => {
          return hiddenAction({
            ...result(...args2),
            [`data-melt-${name22}`]: "",
            action: action ?? noop2
          });
        };
        resultFn.action = action ?? noop2;
        return lightable(resultFn);
      }
      return lightable(hiddenAction({
        ...result,
        [`data-melt-${name22}`]: "",
        action: action ?? noop2
      }));
    }
  })();
  const actionFn = action ?? (() => {
  });
  actionFn.subscribe = derivedStore.subscribe;
  return actionFn;
}
function createElHelpers(prefix) {
  const name22 = (part) => part ? `${prefix}-${part}` : prefix;
  const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ""}`;
  const selector2 = (part) => `[data-melt-${prefix}${part ? `-${part}` : ""}]`;
  const getEl = (part) => document.querySelector(selector2(part));
  return {
    name: name22,
    attribute,
    selector: selector2,
    getEl
  };
}
function isHTMLElement$1(element) {
  return element instanceof HTMLElement;
}
function isElementDisabled(element) {
  const ariaDisabled = element.getAttribute("aria-disabled");
  const disabled = element.getAttribute("disabled");
  const dataDisabled = element.hasAttribute("data-disabled");
  if (ariaDisabled === "true" || disabled !== null || dataDisabled) {
    return true;
  }
  return false;
}
function isTouch(event) {
  return event.pointerType === "touch";
}
function isLeftClick(event) {
  return event.button === 0 && event.ctrlKey === false && event.metaKey === false;
}
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
function noop2() {
}
function addEventListener(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options2));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options2));
  };
}
function addMeltEventListener(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  if (typeof handler === "function") {
    const handlerWithMelt = withMelt((_event) => handler(_event));
    events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options2));
    return () => {
      events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options2));
    };
  }
  return () => noop2();
}
function dispatchMeltEvent(originalEvent) {
  const node = originalEvent.currentTarget;
  if (!isHTMLElement$1(node))
    return null;
  const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {
    detail: {
      originalEvent
    },
    cancelable: true
  });
  node.dispatchEvent(customMeltEvent);
  return customMeltEvent;
}
function withMelt(handler) {
  return (event) => {
    const customEvent = dispatchMeltEvent(event);
    if (customEvent?.defaultPrevented)
      return;
    return handler(event);
  };
}
function addHighlight(element) {
  element.setAttribute("data-highlighted", "");
}
function removeHighlight(element) {
  element.removeAttribute("data-highlighted");
}
function omit(obj, ...keys2) {
  const result = {};
  for (const key3 of Object.keys(obj)) {
    if (!keys2.includes(key3)) {
      result[key3] = obj[key3];
    }
  }
  return result;
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function styleToString(style) {
  return Object.keys(style).reduce((str, key3) => {
    if (style[key3] === void 0)
      return str;
    return str + `${key3}:${style[key3]};`;
  }, "");
}
function generateId$1() {
  return nanoid(10);
}
function debounce(fn, wait = 500) {
  let timeout = null;
  return function(...args) {
    const later = () => {
      timeout = null;
      fn(...args);
    };
    timeout && clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
function getPlatform() {
  const agent2 = navigator.userAgentData;
  return agent2?.platform ?? navigator.platform;
}
function makeHull(points) {
  const newPoints = points.slice();
  newPoints.sort(POINT_COMPARATOR);
  return makeHullPresorted(newPoints);
}
function makeHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i2 = 0; i2 < points.length; i2++) {
    const p2 = points[i2];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q.x - r2.x) * (p2.y - r2.y) >= (q.y - r2.y) * (p2.x - r2.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i2 = points.length - 1; i2 >= 0; i2--) {
    const p2 = points[i2];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q.x - r2.x) * (p2.y - r2.y) >= (q.y - r2.y) * (p2.x - r2.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length == 1 && lowerHull.length == 1 && upperHull[0].x == lowerHull[0].x && upperHull[0].y == lowerHull[0].y)
    return upperHull;
  else
    return upperHull.concat(lowerHull);
}
function POINT_COMPARATOR(a2, b) {
  if (a2.x < b.x)
    return -1;
  else if (a2.x > b.x)
    return 1;
  else if (a2.y < b.y)
    return -1;
  else if (a2.y > b.y)
    return 1;
  else
    return 0;
}
function getPointsFromEl(el) {
  const rect = el.getBoundingClientRect();
  return [
    { x: rect.left, y: rect.top },
    { x: rect.right, y: rect.top },
    { x: rect.right, y: rect.bottom },
    { x: rect.left, y: rect.bottom }
  ];
}
function makeHullFromElements(els) {
  const points = els.flatMap((el) => getPointsFromEl(el));
  return makeHull(points);
}
function pointInPolygon(point, polygon) {
  let inside = false;
  for (let i2 = 0, j2 = polygon.length - 1; i2 < polygon.length; j2 = i2++) {
    const xi = polygon[i2].x;
    const yi = polygon[i2].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function assignStyle(el, style) {
  if (!el)
    return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
function setCSSProperty(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function removeScroll(_document) {
  const doc3 = _document ?? document;
  const win = doc3.defaultView ?? window;
  const { documentElement, body } = doc3;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked)
    return noop2;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const scrollbarSidePadding = win.getComputedStyle(body)[paddingProperty];
  const setStyle = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = visualViewport?.offsetLeft ?? 0;
    const offsetTop = visualViewport?.offsetTop ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
    });
    return () => {
      restoreStyle?.();
      win.scrollTo(scrollX, scrollY);
    };
  };
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];
  return () => {
    cleanups.forEach((fn) => fn?.());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}
function derivedVisible(obj) {
  const { open, forceVisible, activeTrigger } = obj;
  return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);
}
function derivedWithUnsubscribe(stores, fn) {
  let unsubscribers = [];
  const onUnsubscribe = (cb) => {
    unsubscribers.push(cb);
  };
  const unsubscribe = () => {
    unsubscribers.forEach((fn2) => fn2());
    unsubscribers = [];
  };
  const derivedStore = derived(stores, ($storeValues) => {
    unsubscribe();
    return fn($storeValues, onUnsubscribe);
  });
  onDestroy(unsubscribe);
  const subscribe2 = (...args) => {
    const unsub = derivedStore.subscribe(...args);
    return () => {
      unsub();
      unsubscribe();
    };
  };
  return {
    ...derivedStore,
    subscribe: subscribe2
  };
}
function effect(stores, fn) {
  const unsub = derivedWithUnsubscribe(stores, (stores2, onUnsubscribe) => {
    return {
      stores: stores2,
      onUnsubscribe
    };
  }).subscribe(({ stores: stores2, onUnsubscribe }) => {
    const returned = fn(stores2);
    if (returned) {
      onUnsubscribe(returned);
    }
  });
  onDestroy(unsub);
  return unsub;
}
function toWritableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key3) => {
    const propertyKey = key3;
    const value = properties[propertyKey];
    result[propertyKey] = writable(value);
  });
  return result;
}
function handleRovingFocus(nextElement) {
  if (!isBrowser$1)
    return;
  const currentFocusedElement = document.activeElement;
  if (!isHTMLElement$1(currentFocusedElement))
    return;
  if (currentFocusedElement === nextElement)
    return;
  currentFocusedElement.tabIndex = -1;
  nextElement.tabIndex = 0;
  sleep(1).then(() => nextElement.focus());
}
function getFocusableElements() {
  return Array.from(document.querySelectorAll('a[href]:not([tabindex="-1"]), button:not([disabled]):not([tabindex="-1"]), input:not([disabled]):not([tabindex="-1"]), select:not([disabled]):not([tabindex="-1"]), textarea:not([disabled]):not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])'));
}
function getNextFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const nextIndex = currentIndex + 1;
  const nextElement = focusableElements[nextIndex];
  if (nextIndex < focusableElements.length && isHTMLElement$1(nextElement)) {
    return nextElement;
  }
  return null;
}
function getPreviousFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const previousIndex = currentIndex - 1;
  const prevElement = focusableElements[previousIndex];
  if (previousIndex >= 0 && isHTMLElement$1(prevElement)) {
    return prevElement;
  }
  return null;
}
function createTypeaheadSearch(args = {}) {
  const withDefaults = { ...defaults$6, ...args };
  const typed = writable([]);
  const resetTyped = debounce(() => {
    typed.update(() => []);
  });
  const handleTypeaheadSearch = (key3, items) => {
    const currentItem = document.activeElement;
    if (!isHTMLElement$1(currentItem))
      return;
    const $typed = get_store_value(typed);
    if (!Array.isArray($typed)) {
      return;
    }
    $typed.push(key3.toLowerCase());
    typed.update(() => $typed);
    const candidateItems = items.filter((item) => {
      if (item.getAttribute("disabled") === "true" || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("data-disabled")) {
        return false;
      }
      return true;
    });
    const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);
    const normalizeSearch = isRepeated ? $typed[0] : $typed.join("");
    const currentItemIndex = currentItem ? candidateItems.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizeSearch.length === 1;
    if (excludeCurrentItem) {
      wrappedItems = wrappedItems.filter((v) => v !== currentItem);
    }
    const nextItem = wrappedItems.find((item) => item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));
    if (isHTMLElement$1(nextItem) && nextItem !== currentItem) {
      withDefaults.onMatch(nextItem);
    }
    resetTyped();
  };
  return {
    typed,
    resetTyped,
    handleTypeaheadSearch
  };
}
function getPortalParent(node) {
  let parent = node.parentElement;
  while (isHTMLElement$1(parent) && !parent.hasAttribute("data-portal")) {
    parent = parent.parentElement;
  }
  return parent || "body";
}
function getPortalDestination(node, portalProp) {
  const portalParent = getPortalParent(node);
  if (portalProp !== void 0)
    return portalProp;
  if (portalParent === "body")
    return document.body;
  return null;
}
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param2) {
  return typeof value === "function" ? value(param2) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow(state, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y2
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
async function convertValueToCoords(state, options2) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options2, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit2 = isWebKit();
  const css3 = getComputedStyle$1(element);
  return css3.transform !== "none" || css3.perspective !== "none" || (css3.containerType ? css3.containerType !== "normal" : false) || !webkit2 && (css3.backdropFilter ? css3.backdropFilter !== "none" : false) || !webkit2 && (css3.filter ? css3.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css3.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css3.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element) {
  const css3 = getComputedStyle$1(element);
  let width = parseFloat(css3.width) || 0;
  let height = parseFloat(css3.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css3 = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css3.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css3.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
function useFloating(reference, floating, opts = {}) {
  if (!floating || !reference)
    return {
      destroy: noop2
    };
  const options2 = { ...defaultConfig$1, ...opts };
  const arrowEl = floating.querySelector("[data-arrow=true]");
  const middleware = [];
  if (options2.flip) {
    middleware.push(flip({
      boundary: options2.boundary,
      padding: options2.overflowPadding
    }));
  }
  const arrowOffset = isHTMLElement$1(arrowEl) ? arrowEl.offsetHeight / 2 : 0;
  if (options2.gutter || options2.offset) {
    const data = options2.gutter ? { mainAxis: options2.gutter } : options2.offset;
    if (data?.mainAxis != null) {
      data.mainAxis += arrowOffset;
    }
    middleware.push(offset(data));
  }
  middleware.push(shift({
    boundary: options2.boundary,
    crossAxis: options2.overlap,
    padding: options2.overflowPadding
  }));
  if (arrowEl) {
    middleware.push(arrow({ element: arrowEl, padding: 8 }));
  }
  middleware.push(size({
    padding: options2.overflowPadding,
    apply({ rects, availableHeight, availableWidth }) {
      if (options2.sameWidth) {
        Object.assign(floating.style, {
          width: `${Math.round(rects.reference.width)}px`,
          minWidth: "unset"
        });
      }
      if (options2.fitViewport) {
        Object.assign(floating.style, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        });
      }
    }
  }));
  function compute() {
    if (!reference || !floating)
      return;
    const { placement, strategy } = options2;
    computePosition(reference, floating, {
      placement,
      middleware,
      strategy
    }).then((data) => {
      const x2 = Math.round(data.x);
      const y2 = Math.round(data.y);
      Object.assign(floating.style, {
        top: `${y2}px`,
        left: `${x2}px`
      });
      if (isHTMLElement$1(arrowEl) && data.middlewareData.arrow) {
        const { x: x22, y: y22 } = data.middlewareData.arrow;
        const dir = data.placement.split("-")[0];
        Object.assign(arrowEl.style, {
          position: "absolute",
          left: x22 != null ? `${x22}px` : "",
          top: y22 != null ? `${y22}px` : "",
          [dir]: `calc(100% - ${arrowOffset}px)`,
          transform: ARROW_TRANSFORM[dir],
          backgroundColor: "inherit",
          zIndex: "inherit"
        });
      }
      return data;
    });
  }
  Object.assign(floating.style, {
    position: options2.strategy
  });
  return {
    destroy: autoUpdate(reference, floating, compute)
  };
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source2), true).forEach(function(key3) {
      _defineProperty(target, key3, source2[key3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key3) {
      Object.defineProperty(target, key3, Object.getOwnPropertyDescriptor(source2, key3));
    });
  }
  return target;
}
function _defineProperty(obj, key3, value) {
  key3 = _toPropertyKey(key3);
  if (key3 in obj) {
    Object.defineProperty(obj, key3, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key3] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key3 = _toPrimitive(arg, "string");
  return typeof key3 === "symbol" ? key3 : String(key3);
}
function createFocusTrap2(config = {}) {
  let trap;
  const { immediate, ...focusTrapOptions } = config;
  const hasFocus = writable(false);
  const isPaused = writable(false);
  const activate = (opts) => trap?.activate(opts);
  const deactivate = (opts) => {
    trap?.deactivate(opts);
  };
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.set(true);
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.set(false);
    }
  };
  const useFocusTrap = (node) => {
    trap = createFocusTrap$1(node, {
      ...focusTrapOptions,
      onActivate() {
        hasFocus.set(true);
        config.onActivate?.();
      },
      onDeactivate() {
        hasFocus.set(false);
        config.onDeactivate?.();
      }
    });
    if (immediate) {
      activate();
    }
    return {
      destroy() {
        deactivate();
        trap = void 0;
      }
    };
  };
  return {
    useFocusTrap,
    hasFocus: readonly(hasFocus),
    isPaused: readonly(isPaused),
    activate,
    deactivate,
    pause,
    unpause
  };
}
function createLabel() {
  const root = builder("label", {
    action: (node) => {
      const mouseDown = addMeltEventListener(node, "mousedown", (e) => {
        if (!e.defaultPrevented && e.detail > 1) {
          e.preventDefault();
        }
      });
      return {
        destroy: mouseDown
      };
    }
  });
  return {
    elements: {
      root
    }
  };
}
function createMenuBuilder(opts) {
  const { name: name22, selector: selector2 } = createElHelpers(opts.selector);
  const { preventScroll, arrowSize, positioning, closeOnEscape, closeOnOutsideClick, portal, forceVisible, typeahead } = opts.rootOptions;
  const rootOpen = opts.rootOpen;
  const rootActiveTrigger = opts.rootActiveTrigger;
  const nextFocusable = opts.nextFocusable;
  const prevFocusable = opts.prevFocusable;
  const isUsingKeyboard = writable(false);
  const lastPointerX = writable(0);
  const pointerGraceIntent = writable(null);
  const pointerDir = writable("right");
  const currentFocusedItem = writable(null);
  const pointerMovingToSubmenu = derivedWithUnsubscribe([pointerDir, pointerGraceIntent], ([$pointerDir, $pointerGraceIntent]) => {
    return (e) => {
      const isMovingTowards = $pointerDir === $pointerGraceIntent?.side;
      return isMovingTowards && isPointerInGraceArea(e, $pointerGraceIntent?.area);
    };
  });
  const { typed, handleTypeaheadSearch } = createTypeaheadSearch();
  const rootIds = {
    menu: generateId$1(),
    trigger: generateId$1()
  };
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const rootMenu = builder(name22(), {
    stores: [isVisible, portal],
    returned: ([$isVisible, $portal]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: rootIds.menu,
        "aria-labelledby": rootIds.trigger,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": $portal ? "" : void 0,
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop2;
      const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          setMeltMenuAttribute(node, selector2);
          const popper = usePopper(node, {
            anchorElement: $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              clickOutside: $closeOnOutsideClick ? void 0 : null,
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          });
          if (popper && popper.destroy) {
            unsubPopper = popper.destroy;
          }
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        const target = e.target;
        const menuEl = e.currentTarget;
        if (!isHTMLElement$1(target) || !isHTMLElement$1(menuEl))
          return;
        const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e.key)) {
          handleMenuNavigation(e);
        }
        if (e.key === kbd.TAB) {
          e.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e.key.length === 1;
        const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
        if (!isModifierKey && isCharacterKey && get_store_value(typeahead) === true) {
          handleTypeaheadSearch(e.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const rootTrigger = builder(name22("trigger"), {
    stores: [rootOpen],
    returned: ([$rootOpen]) => {
      return {
        "aria-controls": rootIds.menu,
        "aria-expanded": $rootOpen,
        "data-state": $rootOpen ? "open" : "closed",
        id: rootIds.trigger,
        tabindex: 0
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        const $rootOpen = get_store_value(rootOpen);
        const triggerEl = e.currentTarget;
        if (!isHTMLElement$1(triggerEl))
          return;
        handleOpen(triggerEl);
        if (!$rootOpen)
          e.preventDefault();
      }), addMeltEventListener(node, "keydown", (e) => {
        const triggerEl = e.currentTarget;
        if (!isHTMLElement$1(triggerEl))
          return;
        if (!(SELECTION_KEYS.includes(e.key) || e.key === kbd.ARROW_DOWN))
          return;
        e.preventDefault();
        handleOpen(triggerEl);
        const menuId = triggerEl.getAttribute("aria-controls");
        if (!menuId)
          return;
        const menu = document.getElementById(menuId);
        if (!menu)
          return;
        const menuItems = getMenuItems(menu);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const rootArrow = builder(name22("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const item = builder(name22("item"), {
    returned: () => {
      return {
        role: "menuitem",
        tabindex: -1,
        "data-orientation": "vertical"
      };
    },
    action: (node) => {
      setMeltMenuAttribute(node, selector2);
      applyAttrsIfDisabled(node);
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
        const itemEl = e.currentTarget;
        if (!isHTMLElement$1(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e.preventDefault();
          return;
        }
      }), addMeltEventListener(node, "click", (e) => {
        const itemEl = e.currentTarget;
        if (!isHTMLElement$1(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e.preventDefault();
          return;
        }
        if (e.defaultPrevented) {
          handleRovingFocus(itemEl);
          return;
        }
        sleep(1).then(() => {
          rootOpen.set(false);
        });
      }), addMeltEventListener(node, "keydown", (e) => {
        onItemKeyDown(e);
      }), addMeltEventListener(node, "pointermove", (e) => {
        onMenuItemPointerMove(e);
      }), addMeltEventListener(node, "pointerleave", (e) => {
        onMenuItemPointerLeave(e);
      }), addMeltEventListener(node, "focusin", (e) => {
        onItemFocusIn(e);
      }), addMeltEventListener(node, "focusout", (e) => {
        onItemFocusOut(e);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const group = builder(name22("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = builder(name22("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const checkboxItemDefaults = {
    defaultChecked: false,
    disabled: false
  };
  const createCheckboxItem = (props) => {
    const withDefaults = { ...checkboxItemDefaults, ...props };
    const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked ?? null);
    const checked = overridable(checkedWritable, withDefaults.onCheckedChange);
    const disabled = writable(withDefaults.disabled);
    const checkboxItem = builder(name22("checkbox-item"), {
      stores: [checked, disabled],
      returned: ([$checked, $disabled]) => {
        return {
          role: "menuitemcheckbox",
          tabindex: -1,
          "data-orientation": "vertical",
          "aria-checked": isIndeterminate($checked) ? "mixed" : $checked ? "true" : "false",
          "data-disabled": $disabled ? "" : void 0,
          "data-state": getCheckedState($checked)
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector2);
        applyAttrsIfDisabled(node);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement$1(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement$1(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e.preventDefault();
            return;
          }
          if (e.defaultPrevented) {
            handleRovingFocus(itemEl);
            return;
          }
          checked.update((prev) => {
            if (isIndeterminate(prev))
              return true;
            return !prev;
          });
          tick().then(() => {
            rootOpen.set(false);
          });
        }), addMeltEventListener(node, "keydown", (e) => {
          onItemKeyDown(e);
        }), addMeltEventListener(node, "pointermove", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement$1(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            onItemLeave(e);
            return;
          }
          onMenuItemPointerMove(e, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e) => {
          onMenuItemPointerLeave(e);
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          onItemFocusOut(e);
        }));
        return {
          destroy: unsub
        };
      }
    });
    return {
      elements: {
        checkboxItem
      },
      states: {
        checked
      },
      options: {
        disabled
      }
    };
  };
  const createMenuRadioGroup = (args = {}) => {
    const valueWritable = args.value ?? writable(args.defaultValue ?? null);
    const value = overridable(valueWritable, args.onValueChange);
    const radioGroup = builder(name22("radio-group"), {
      returned: () => ({
        role: "group"
      })
    });
    const radioItemDefaults = {
      disabled: false
    };
    const radioItem = builder(name22("radio-item"), {
      stores: [value],
      returned: ([$value]) => {
        return (itemProps) => {
          const { value: itemValue, disabled } = { ...radioItemDefaults, ...itemProps };
          const checked = $value === itemValue;
          return {
            disabled,
            role: "menuitemradio",
            "data-state": checked ? "checked" : "unchecked",
            "aria-checked": checked,
            "data-disabled": disabled ? "" : void 0,
            "data-value": itemValue,
            "data-orientation": "vertical",
            tabindex: -1
          };
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector2);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement$1(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement$1(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e.preventDefault();
            return;
          }
          if (e.defaultPrevented) {
            if (!isHTMLElement$1(itemEl))
              return;
            handleRovingFocus(itemEl);
            return;
          }
          value.set(itemValue);
          tick().then(() => {
            rootOpen.set(false);
          });
        }), addMeltEventListener(node, "keydown", (e) => {
          onItemKeyDown(e);
        }), addMeltEventListener(node, "pointermove", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement$1(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            onItemLeave(e);
            return;
          }
          onMenuItemPointerMove(e, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e) => {
          onMenuItemPointerLeave(e);
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          onItemFocusOut(e);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(value, ($value) => {
      return (itemValue) => {
        return $value === itemValue;
      };
    });
    return {
      elements: {
        radioGroup,
        radioItem
      },
      states: {
        value
      },
      helpers: {
        isChecked
      }
    };
  };
  const { elements: { root: separator } } = createSeparator({
    orientation: "horizontal"
  });
  const subMenuDefaults = {
    ...defaults$5,
    disabled: false,
    positioning: {
      placement: "right-start",
      gutter: 8
    }
  };
  const createSubmenu = (args) => {
    const withDefaults = { ...subMenuDefaults, ...args };
    const subOpen = writable(false);
    const options2 = toWritableStores(withDefaults);
    const { positioning: positioning2, arrowSize: arrowSize2, disabled } = options2;
    const subActiveTrigger = writable(null);
    const subOpenTimer = writable(null);
    const pointerGraceTimer = writable(0);
    const subIds = {
      menu: generateId$1(),
      trigger: generateId$1()
    };
    const subIsVisible = derivedVisible({
      open: subOpen,
      forceVisible,
      activeTrigger: subActiveTrigger
    });
    const subMenu = builder(name22("submenu"), {
      stores: [subIsVisible],
      returned: ([$subIsVisible]) => {
        return {
          role: "menu",
          hidden: $subIsVisible ? void 0 : true,
          style: styleToString({
            display: $subIsVisible ? void 0 : "none"
          }),
          id: subIds.menu,
          "aria-labelledby": subIds.trigger,
          "data-state": $subIsVisible ? "open" : "closed",
          tabindex: -1
        };
      },
      action: (node) => {
        let unsubPopper = noop2;
        const unsubDerived = effect([subIsVisible, positioning2], ([$subIsVisible, $positioning]) => {
          unsubPopper();
          if (!$subIsVisible)
            return;
          const activeTrigger = get_store_value(subActiveTrigger);
          if (!activeTrigger)
            return;
          tick().then(() => {
            const parentMenuEl = getParentMenu(activeTrigger);
            const popper = usePopper(node, {
              anchorElement: activeTrigger,
              open: subOpen,
              options: {
                floating: $positioning,
                portal: isHTMLElement$1(parentMenuEl) ? parentMenuEl : void 0,
                clickOutside: null,
                focusTrap: null
              }
            });
            if (popper && popper.destroy) {
              unsubPopper = popper.destroy;
            }
          });
        });
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
          if (e.key === kbd.ESCAPE) {
            return;
          }
          const target = e.target;
          const menuEl = e.currentTarget;
          if (!isHTMLElement$1(target) || !isHTMLElement$1(menuEl))
            return;
          const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
          if (!isKeyDownInside)
            return;
          if (FIRST_LAST_KEYS.includes(e.key)) {
            e.stopImmediatePropagation();
            handleMenuNavigation(e);
            return;
          }
          const isCloseKey = SUB_CLOSE_KEYS["ltr"].includes(e.key);
          const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
          const isCharacterKey = e.key.length === 1;
          if (isCloseKey) {
            const $subActiveTrigger = get_store_value(subActiveTrigger);
            e.preventDefault();
            subOpen.update(() => {
              if ($subActiveTrigger) {
                handleRovingFocus($subActiveTrigger);
              }
              return false;
            });
            return;
          }
          if (e.key === kbd.TAB) {
            e.preventDefault();
            rootOpen.set(false);
            handleTabNavigation(e, nextFocusable, prevFocusable);
            return;
          }
          if (!isModifierKey && isCharacterKey && get_store_value(typeahead) === true) {
            handleTypeaheadSearch(e.key, getMenuItems(menuEl));
          }
        }), addMeltEventListener(node, "pointermove", (e) => {
          onMenuPointerMove(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          const $subActiveTrigger = get_store_value(subActiveTrigger);
          if (get_store_value(isUsingKeyboard)) {
            const target = e.target;
            const submenuEl = document.getElementById(subIds.menu);
            if (!isHTMLElement$1(submenuEl) || !isHTMLElement$1(target))
              return;
            if (!submenuEl.contains(target) && target !== $subActiveTrigger) {
              subOpen.set(false);
            }
          } else {
            const menuEl = e.currentTarget;
            const relatedTarget = e.relatedTarget;
            if (!isHTMLElement$1(relatedTarget) || !isHTMLElement$1(menuEl))
              return;
            if (!menuEl.contains(relatedTarget) && relatedTarget !== $subActiveTrigger) {
              subOpen.set(false);
            }
          }
        }));
        return {
          destroy() {
            unsubDerived();
            unsubPopper();
            unsubEvents();
          }
        };
      }
    });
    const subTrigger = builder(name22("subtrigger"), {
      stores: [subOpen, disabled],
      returned: ([$subOpen, $disabled]) => {
        return {
          role: "menuitem",
          id: subIds.trigger,
          tabindex: -1,
          "aria-controls": subIds.menu,
          "aria-expanded": $subOpen,
          "data-state": $subOpen ? "open" : "closed",
          "data-disabled": $disabled ? "" : void 0,
          "aria-haspopop": "menu"
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector2);
        applyAttrsIfDisabled(node);
        const unsubTimer = () => {
          clearTimerStore(subOpenTimer);
          window.clearTimeout(get_store_value(pointerGraceTimer));
          pointerGraceIntent.set(null);
        };
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "click", (e) => {
          if (e.defaultPrevented)
            return;
          const triggerEl = e.currentTarget;
          if (!isHTMLElement$1(triggerEl) || isElementDisabled(triggerEl))
            return;
          handleRovingFocus(triggerEl);
          if (!get_store_value(subOpen)) {
            subOpen.update((prev) => {
              const isAlreadyOpen = prev;
              if (!isAlreadyOpen) {
                subActiveTrigger.set(triggerEl);
                return !prev;
              }
              return prev;
            });
          }
        }), addMeltEventListener(node, "keydown", (e) => {
          const $typed = get_store_value(typed);
          const triggerEl = e.currentTarget;
          if (!isHTMLElement$1(triggerEl) || isElementDisabled(triggerEl))
            return;
          const isTypingAhead = $typed.length > 0;
          if (isTypingAhead && e.key === kbd.SPACE)
            return;
          if (SUB_OPEN_KEYS["ltr"].includes(e.key)) {
            if (!get_store_value(subOpen)) {
              triggerEl.click();
              e.preventDefault();
              return;
            }
            const menuId = triggerEl.getAttribute("aria-controls");
            if (!menuId)
              return;
            const menuEl = document.getElementById(menuId);
            if (!isHTMLElement$1(menuEl))
              return;
            const firstItem = getMenuItems(menuEl)[0];
            handleRovingFocus(firstItem);
          }
        }), addMeltEventListener(node, "pointermove", (e) => {
          if (!isMouse(e))
            return;
          onItemEnter(e);
          if (e.defaultPrevented)
            return;
          const triggerEl = e.currentTarget;
          if (!isHTMLElement$1(triggerEl))
            return;
          handleRovingFocus(triggerEl);
          const openTimer = get_store_value(subOpenTimer);
          if (!get_store_value(subOpen) && !openTimer && !isElementDisabled(triggerEl)) {
            subOpenTimer.set(window.setTimeout(() => {
              subOpen.update(() => {
                subActiveTrigger.set(triggerEl);
                return true;
              });
              clearTimerStore(subOpenTimer);
            }, 100));
          }
        }), addMeltEventListener(node, "pointerleave", (e) => {
          if (!isMouse(e))
            return;
          clearTimerStore(subOpenTimer);
          const submenuEl = document.getElementById(subIds.menu);
          const contentRect = submenuEl?.getBoundingClientRect();
          if (contentRect) {
            const side = submenuEl?.dataset.side;
            const rightSide = side === "right";
            const bleed = rightSide ? -5 : 5;
            const contentNearEdge = contentRect[rightSide ? "left" : "right"];
            const contentFarEdge = contentRect[rightSide ? "right" : "left"];
            pointerGraceIntent.set({
              area: [
                // Apply a bleed on clientX to ensure that our exit point is
                // consistently within polygon bounds
                { x: e.clientX + bleed, y: e.clientY },
                { x: contentNearEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.bottom },
                { x: contentNearEdge, y: contentRect.bottom }
              ],
              side
            });
            window.clearTimeout(get_store_value(pointerGraceTimer));
            pointerGraceTimer.set(window.setTimeout(() => {
              pointerGraceIntent.set(null);
            }, 300));
          } else {
            onTriggerLeave(e);
            if (e.defaultPrevented)
              return;
            pointerGraceIntent.set(null);
          }
        }), addMeltEventListener(node, "focusout", (e) => {
          const triggerEl = e.currentTarget;
          if (!isHTMLElement$1(triggerEl))
            return;
          removeHighlight(triggerEl);
          const relatedTarget = e.relatedTarget;
          if (!isHTMLElement$1(relatedTarget))
            return;
          const menuId = triggerEl.getAttribute("aria-controls");
          if (!menuId)
            return;
          const menu = document.getElementById(menuId);
          if (menu && !menu.contains(relatedTarget)) {
            subOpen.set(false);
          }
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }));
        return {
          destroy() {
            unsubTimer();
            unsubEvents();
          }
        };
      }
    });
    const subArrow = builder(name22("subarrow"), {
      stores: arrowSize2,
      returned: ($arrowSize) => ({
        "data-arrow": true,
        style: styleToString({
          position: "absolute",
          width: `var(--arrow-size, ${$arrowSize}px)`,
          height: `var(--arrow-size, ${$arrowSize}px)`
        })
      })
    });
    effect([rootOpen], ([$rootOpen]) => {
      if (!$rootOpen) {
        subActiveTrigger.set(null);
        subOpen.set(false);
      }
    });
    effect([pointerGraceIntent], ([$pointerGraceIntent]) => {
      if (!isBrowser$1 || $pointerGraceIntent)
        return;
      window.clearTimeout(get_store_value(pointerGraceTimer));
    });
    effect([subOpen], ([$subOpen]) => {
      if (!isBrowser$1)
        return;
      sleep(1).then(() => {
        const menuEl = document.getElementById(subIds.menu);
        if (!menuEl)
          return;
        if ($subOpen && get_store_value(isUsingKeyboard)) {
          const menuItems = getMenuItems(menuEl);
          if (!menuItems.length)
            return;
          handleRovingFocus(menuItems[0]);
        }
        if (!$subOpen) {
          const focusedItem = get_store_value(currentFocusedItem);
          if (focusedItem && menuEl.contains(focusedItem)) {
            removeHighlight(focusedItem);
          }
        }
        if (menuEl && !$subOpen) {
          const subTriggerEl = document.getElementById(subIds.trigger);
          if (!subTriggerEl || document.activeElement === subTriggerEl)
            return;
          removeHighlight(subTriggerEl);
        }
      });
    });
    return {
      elements: {
        subTrigger,
        subMenu,
        subArrow
      },
      states: {
        subOpen
      },
      options: options2
    };
  };
  effect([rootOpen, currentFocusedItem], ([$rootOpen, $currentFocusedItem]) => {
    if (!$rootOpen && $currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
  });
  effect([rootOpen, rootActiveTrigger, preventScroll], ([$rootOpen, $rootActiveTrigger, $preventScroll]) => {
    if (!isBrowser$1)
      return;
    const unsubs = [];
    if (opts.removeScroll && $rootOpen && $preventScroll) {
      unsubs.push(removeScroll());
    }
    if (!$rootOpen && $rootActiveTrigger) {
      handleRovingFocus($rootActiveTrigger);
    }
    sleep(1).then(() => {
      const menuEl = document.getElementById(rootIds.menu);
      if (menuEl && $rootOpen && get_store_value(isUsingKeyboard)) {
        if (opts.disableFocusFirstItem) {
          handleRovingFocus(menuEl);
          return;
        }
        const menuItems = getMenuItems(menuEl);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      } else if ($rootActiveTrigger) {
        handleRovingFocus($rootActiveTrigger);
      } else {
        if (opts.disableTriggerRefocus) {
          return;
        }
        const triggerEl = document.getElementById(rootIds.trigger);
        if (!triggerEl)
          return;
        handleRovingFocus(triggerEl);
      }
    });
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect(rootOpen, ($rootOpen) => {
    if (!isBrowser$1)
      return;
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown2 = (e) => {
      isUsingKeyboard.set(true);
      if (e.key === kbd.ESCAPE && $rootOpen) {
        rootOpen.set(false);
        return;
      }
    };
    return executeCallbacks(addEventListener(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener(document, "pointermove", handlePointer, { capture: true, once: true }), addEventListener(document, "keydown", handleKeyDown2, { capture: true }));
  });
  function handleOpen(triggerEl) {
    rootOpen.update((prev) => {
      const isOpen = !prev;
      if (isOpen) {
        nextFocusable.set(getNextFocusable(triggerEl));
        prevFocusable.set(getPreviousFocusable(triggerEl));
        rootActiveTrigger.set(triggerEl);
      }
      return isOpen;
    });
  }
  function onItemFocusIn(e) {
    const itemEl = e.currentTarget;
    if (!isHTMLElement$1(itemEl))
      return;
    const $currentFocusedItem = get_store_value(currentFocusedItem);
    if ($currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
    addHighlight(itemEl);
    currentFocusedItem.set(itemEl);
  }
  function onItemFocusOut(e) {
    const itemEl = e.currentTarget;
    if (!isHTMLElement$1(itemEl))
      return;
    removeHighlight(itemEl);
  }
  function onItemEnter(e) {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  }
  function onItemLeave(e) {
    if (isPointerMovingToSubmenu(e)) {
      return;
    }
    const target = e.target;
    if (!isHTMLElement$1(target))
      return;
    const parentMenuEl = getParentMenu(target);
    if (!parentMenuEl)
      return;
    handleRovingFocus(parentMenuEl);
  }
  function onTriggerLeave(e) {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  }
  function onMenuPointerMove(e) {
    if (!isMouse(e))
      return;
    const target = e.target;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement$1(currentTarget) || !isHTMLElement$1(target))
      return;
    const $lastPointerX = get_store_value(lastPointerX);
    const pointerXHasChanged = $lastPointerX !== e.clientX;
    if (currentTarget.contains(target) && pointerXHasChanged) {
      const newDir = e.clientX > $lastPointerX ? "right" : "left";
      pointerDir.set(newDir);
      lastPointerX.set(e.clientX);
    }
  }
  function onMenuItemPointerMove(e, currTarget = null) {
    if (!isMouse(e))
      return;
    onItemEnter(e);
    if (e.defaultPrevented)
      return;
    if (currTarget) {
      handleRovingFocus(currTarget);
      return;
    }
    const currentTarget = e.currentTarget;
    if (!isHTMLElement$1(currentTarget))
      return;
    handleRovingFocus(currentTarget);
  }
  function onMenuItemPointerLeave(e) {
    if (!isMouse(e))
      return;
    onItemLeave(e);
  }
  function onItemKeyDown(e) {
    const $typed = get_store_value(typed);
    const isTypingAhead = $typed.length > 0;
    if (isTypingAhead && e.key === kbd.SPACE) {
      e.preventDefault();
      return;
    }
    if (SELECTION_KEYS.includes(e.key)) {
      e.preventDefault();
      const itemEl = e.currentTarget;
      if (!isHTMLElement$1(itemEl))
        return;
      itemEl.click();
    }
  }
  function isIndeterminate(checked) {
    return checked === "indeterminate";
  }
  function getCheckedState(checked) {
    return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
  }
  function isPointerMovingToSubmenu(e) {
    return get_store_value(pointerMovingToSubmenu)(e);
  }
  function getParentMenu(element) {
    const parentMenuEl = element.closest('[role="menu"]');
    if (!isHTMLElement$1(parentMenuEl))
      return null;
    return parentMenuEl;
  }
  return {
    trigger: rootTrigger,
    menu: rootMenu,
    open: rootOpen,
    item,
    group,
    groupLabel,
    arrow: rootArrow,
    options: opts.rootOptions,
    createCheckboxItem,
    createSubmenu,
    createMenuRadioGroup,
    separator,
    rootIds,
    handleTypeaheadSearch
  };
}
function handleTabNavigation(e, nextFocusable, prevFocusable) {
  if (e.shiftKey) {
    const $prevFocusable = get_store_value(prevFocusable);
    if ($prevFocusable) {
      e.preventDefault();
      $prevFocusable.focus();
      prevFocusable.set(null);
    }
  } else {
    const $nextFocusable = get_store_value(nextFocusable);
    if ($nextFocusable) {
      e.preventDefault();
      $nextFocusable.focus();
      nextFocusable.set(null);
    }
  }
}
function getMenuItems(menuElement) {
  return Array.from(menuElement.querySelectorAll(`[data-melt-menu-id="${menuElement.id}"]`)).filter((item) => isHTMLElement$1(item));
}
function applyAttrsIfDisabled(element) {
  if (!element || !isElementDisabled(element))
    return;
  element.setAttribute("data-disabled", "");
  element.setAttribute("aria-disabled", "true");
}
function clearTimerStore(timerStore) {
  if (!isBrowser$1)
    return;
  const timer = get_store_value(timerStore);
  if (timer) {
    window.clearTimeout(timer);
    timerStore.set(null);
  }
}
function isMouse(e) {
  return e.pointerType === "mouse";
}
function setMeltMenuAttribute(element, selector2) {
  if (!element)
    return;
  const menuEl = element.closest(`${selector2()}, ${selector2("submenu")}`);
  if (!isHTMLElement$1(menuEl))
    return;
  element.setAttribute("data-melt-menu-id", menuEl.id);
}
function handleMenuNavigation(e) {
  e.preventDefault();
  const currentFocusedItem = document.activeElement;
  const currentTarget = e.currentTarget;
  if (!isHTMLElement$1(currentFocusedItem) || !isHTMLElement$1(currentTarget))
    return;
  const menuItems = getMenuItems(currentTarget);
  if (!menuItems.length)
    return;
  const candidateNodes = menuItems.filter((item) => {
    if (item.hasAttribute("data-disabled") || item.getAttribute("disabled") === "true") {
      return false;
    }
    return true;
  });
  const currentIndex = candidateNodes.indexOf(currentFocusedItem);
  let nextIndex;
  switch (e.key) {
    case kbd.ARROW_DOWN:
      nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : currentIndex;
      break;
    case kbd.ARROW_UP:
      nextIndex = currentIndex > 0 ? currentIndex - 1 : 0;
      break;
    case kbd.HOME:
      nextIndex = 0;
      break;
    case kbd.END:
      nextIndex = candidateNodes.length - 1;
      break;
    default:
      return;
  }
  handleRovingFocus(candidateNodes[nextIndex]);
}
function isPointerInGraceArea(e, area) {
  if (!area)
    return false;
  const cursorPos = { x: e.clientX, y: e.clientY };
  return isPointInPolygon(cursorPos, area);
}
function isPointInPolygon(point, polygon) {
  const { x: x2, y: y2 } = point;
  let inside = false;
  for (let i2 = 0, j2 = polygon.length - 1; i2 < polygon.length; j2 = i2++) {
    const xi = polygon[i2].x;
    const yi = polygon[i2].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function createContextMenu(props) {
  const withDefaults = { ...defaults$4, ...props };
  const rootOptions = toWritableStores(withDefaults);
  const { positioning, closeOnOutsideClick, portal, forceVisible, closeOnEscape } = rootOptions;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults?.onOpenChange);
  const rootActiveTrigger = writable(null);
  const nextFocusable = writable(null);
  const prevFocusable = writable(null);
  const { item, createCheckboxItem, arrow: arrow22, createSubmenu, createMenuRadioGroup, rootIds, separator, handleTypeaheadSearch, group, groupLabel } = createMenuBuilder({
    rootOpen,
    rootActiveTrigger,
    rootOptions,
    nextFocusable,
    prevFocusable,
    disableFocusFirstItem: true,
    disableTriggerRefocus: true,
    selector: "context-menu",
    removeScroll: true
  });
  const point = writable(null);
  const virtual = derivedWithUnsubscribe([point], ([$point]) => {
    if ($point === null)
      return null;
    return {
      getBoundingClientRect: () => DOMRect.fromRect({
        width: 0,
        height: 0,
        ...$point
      })
    };
  });
  const longPressTimer = writable(0);
  function handleClickOutside(e) {
    if (e.defaultPrevented)
      return;
    const target = e.target;
    if (!(target instanceof Element))
      return;
    if (target.id === rootIds.trigger && isLeftClick(e)) {
      rootOpen.set(false);
      return;
    }
    if (target.id !== rootIds.trigger && !target.closest(selector())) {
      rootOpen.set(false);
    }
  }
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const menu = builder(name$2(), {
    stores: [isVisible, portal],
    returned: ([$isVisible, $portal]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: rootIds.menu,
        "aria-labelledby": rootIds.trigger,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": $portal ? "" : void 0,
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop2;
      const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          setMeltMenuAttribute(node, selector);
          const $virtual = get_store_value(virtual);
          const popper = usePopper(node, {
            anchorElement: $virtual ? $virtual : $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              clickOutside: $closeOnOutsideClick ? {
                handler: handleClickOutside
              } : null,
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          });
          if (!popper || !popper.destroy)
            return;
          unsubPopper = popper.destroy;
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        const target = e.target;
        const menuEl = e.currentTarget;
        if (!isHTMLElement$1(target) || !isHTMLElement$1(menuEl))
          return;
        const isKeyDownInside = target.closest("[role='menu']") === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e.key)) {
          handleMenuNavigation(e);
        }
        if (e.key === kbd.TAB) {
          e.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e.key.length === 1;
        const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
        if (!isModifierKey && isCharacterKey) {
          handleTypeaheadSearch(e.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const trigger = builder(name$2("trigger"), {
    stores: rootOpen,
    returned: ($rootOpen) => {
      return {
        "aria-controls": rootIds.menu,
        "aria-expanded": $rootOpen,
        "data-state": $rootOpen ? "open" : "closed",
        id: rootIds.trigger,
        style: styleToString({
          WebkitTouchCallout: "none"
        })
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      const handleOpen = (e) => {
        point.set({
          x: e.clientX,
          y: e.clientY
        });
        nextFocusable.set(getNextFocusable(node));
        prevFocusable.set(getPreviousFocusable(node));
        rootActiveTrigger.set(node);
        rootOpen.set(true);
      };
      const unsubTimer = () => {
        clearTimerStore(longPressTimer);
      };
      const unsub = executeCallbacks(addMeltEventListener(node, "contextmenu", (e) => {
        clearTimerStore(longPressTimer);
        handleOpen(e);
        e.preventDefault();
      }), addMeltEventListener(node, "pointerdown", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
        longPressTimer.set(window.setTimeout(() => handleOpen(e), 700));
      }), addMeltEventListener(node, "pointermove", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }), addMeltEventListener(node, "pointercancel", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }), addMeltEventListener(node, "pointerup", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }));
      return {
        destroy() {
          unsubTimer();
          unsub();
        }
      };
    }
  });
  return {
    elements: {
      menu,
      trigger,
      item,
      arrow: arrow22,
      separator,
      group,
      groupLabel
    },
    states: {
      open: rootOpen
    },
    builders: {
      createSubmenu,
      createCheckboxItem,
      createMenuRadioGroup
    },
    options: rootOptions
  };
}
function isTouchOrPen(e) {
  return e.pointerType !== "mouse";
}
function createDialog(props) {
  const withDefaults = { ...defaults$3, ...props };
  const options2 = toWritableStores(withDefaults);
  const { preventScroll, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible } = options2;
  const activeTrigger = writable(null);
  const ids = {
    content: generateId$1(),
    title: generateId$1(),
    description: generateId$1(),
    trigger: generateId$1()
  };
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults?.onOpenChange);
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  function handleOpen(e) {
    const el = e.currentTarget;
    const triggerEl = e.currentTarget;
    if (!isHTMLElement$1(el) || !isHTMLElement$1(triggerEl))
      return;
    open.set(true);
    activeTrigger.set(triggerEl);
  }
  function handleClose() {
    open.set(false);
    const triggerEl = document.getElementById(ids.trigger);
    if (triggerEl) {
      tick().then(() => {
        triggerEl.focus();
      });
    }
  }
  effect([open], ([$open]) => {
    sleep(100).then(() => {
      if ($open) {
        openDialogIds.update((prev) => {
          prev.push(ids.content);
          return prev;
        });
      } else {
        openDialogIds.update((prev) => prev.filter((id) => id !== ids.content));
      }
    });
  });
  const trigger = builder(name$1("trigger"), {
    stores: open,
    returned: ($open) => {
      return {
        id: ids.trigger,
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        "aria-controls": ids.content,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        handleOpen(e);
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        handleOpen(e);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const overlay = builder(name$1("overlay"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": true,
        "data-state": $isVisible ? "open" : "closed"
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop2;
      if (get_store_value(closeOnEscape)) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      return {
        destroy() {
          unsubEscapeKeydown();
        }
      };
    }
  });
  const content = builder(name$1("content"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        id: ids.content,
        role: get_store_value(role),
        "aria-describedby": ids.description,
        "aria-labelledby": ids.title,
        "data-state": $isVisible ? "open" : "closed",
        tabindex: -1,
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        })
      };
    },
    action: (node) => {
      let activate = noop2;
      let deactivate = noop2;
      const destroy = executeCallbacks(effect([open], ([$open]) => {
        if (!$open)
          return;
        const focusTrap = createFocusTrap2({
          immediate: false,
          escapeDeactivates: false,
          returnFocusOnDeactivate: false,
          fallbackFocus: node
        });
        activate = focusTrap.activate;
        deactivate = focusTrap.deactivate;
        const ac = focusTrap.useFocusTrap(node);
        if (ac && ac.destroy) {
          return ac.destroy;
        } else {
          return focusTrap.deactivate;
        }
      }), effect([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {
        return useClickOutside(node, {
          enabled: $open,
          handler: (e) => {
            if (e.defaultPrevented)
              return;
            const $openDialogIds = get_store_value(openDialogIds);
            const isLast = last($openDialogIds) === ids.content;
            if ($closeOnOutsideClick && isLast) {
              handleClose();
            }
          }
        }).destroy;
      }), effect([closeOnEscape], ([$closeOnEscape]) => {
        if (!$closeOnEscape)
          return noop2;
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          return escapeKeydown.destroy;
        }
        return noop2;
      }), effect([isVisible], ([$isVisible]) => {
        tick().then(() => {
          if (!$isVisible) {
            deactivate();
          } else {
            activate();
          }
        });
      }));
      return {
        destroy
      };
    }
  });
  const portalled = builder(name$1("portalled"), {
    stores: portal,
    returned: ($portal) => ({
      "data-portal": $portal ? "" : void 0
    }),
    action: (node) => {
      const unsubPortal = effect([portal], ([$portal]) => {
        if (!$portal)
          return noop2;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop2;
        const portalAction = usePortal(node, portalDestination);
        if (portalAction && portalAction.destroy) {
          return portalAction.destroy;
        } else {
          return noop2;
        }
      });
      return {
        destroy() {
          unsubPortal();
        }
      };
    }
  });
  const title = builder(name$1("title"), {
    returned: () => ({
      id: ids.title
    })
  });
  const description = builder(name$1("description"), {
    returned: () => ({
      id: ids.description
    })
  });
  const close2 = builder(name$1("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleClose();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.SPACE && e.key !== kbd.ENTER)
          return;
        e.preventDefault();
        handleClose();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([open, preventScroll], ([$open, $preventScroll]) => {
    if (!isBrowser$1)
      return;
    const unsubs = [];
    if ($preventScroll && $open)
      unsubs.push(removeScroll());
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  return {
    elements: {
      content,
      trigger,
      title,
      description,
      overlay,
      close: close2,
      portalled
    },
    states: {
      open
    },
    options: options2
  };
}
function createDropdownMenu(props) {
  const withDefaults = { ...defaults$2, ...props };
  const rootOptions = toWritableStores(withDefaults);
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults?.onOpenChange);
  const rootActiveTrigger = writable(null);
  const nextFocusable = writable(null);
  const prevFocusable = writable(null);
  const { trigger, menu, item, arrow: arrow22, createSubmenu, createCheckboxItem, createMenuRadioGroup, separator, group, groupLabel } = createMenuBuilder({
    rootOptions,
    rootOpen,
    rootActiveTrigger,
    nextFocusable,
    prevFocusable,
    disableTriggerRefocus: true,
    selector: "dropdown-menu",
    removeScroll: true
  });
  return {
    elements: {
      trigger,
      menu,
      item,
      arrow: arrow22,
      separator,
      group,
      groupLabel
    },
    states: {
      open: rootOpen
    },
    builders: {
      createCheckboxItem,
      createSubmenu,
      createMenuRadioGroup
    },
    options: rootOptions
  };
}
function createTooltip(props) {
  const withDefaults = { ...defaults, ...props };
  const options2 = toWritableStores(omit(withDefaults, "open"));
  const { positioning, arrowSize, closeOnPointerDown, openDelay, closeDelay, forceVisible, portal, closeOnEscape } = options2;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults?.onOpenChange);
  const activeTrigger = writable(null);
  const ids = {
    content: generateId$1(),
    trigger: generateId$1()
  };
  let clickedTrigger = false;
  let openTimeout = null;
  let closeTimeout = null;
  function openTooltip() {
    if (closeTimeout) {
      window.clearTimeout(closeTimeout);
      closeTimeout = null;
    }
    if (!openTimeout) {
      openTimeout = window.setTimeout(() => {
        open.set(true);
        openTimeout = null;
      }, get_store_value(openDelay));
    }
  }
  function closeTooltip(isBlur) {
    if (openTimeout) {
      window.clearTimeout(openTimeout);
      openTimeout = null;
    }
    if (isBlur && isMouseInTooltipArea)
      return;
    if (!closeTimeout) {
      closeTimeout = window.setTimeout(() => {
        open.set(false);
        if (isBlur)
          clickedTrigger = false;
        closeTimeout = null;
      }, get_store_value(closeDelay));
    }
  }
  const trigger = builder(name2("trigger"), {
    returned: () => {
      return {
        "aria-describedby": ids.content
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", () => {
        const $closeOnPointerDown = get_store_value(closeOnPointerDown);
        if (!$closeOnPointerDown)
          return;
        open.set(false);
        clickedTrigger = true;
        if (openTimeout) {
          window.clearTimeout(openTimeout);
          openTimeout = null;
        }
      }), addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        openTooltip();
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        if (openTimeout) {
          window.clearTimeout(openTimeout);
          openTimeout = null;
        }
      }), addMeltEventListener(node, "focus", () => {
        if (clickedTrigger)
          return;
        openTooltip();
      }), addMeltEventListener(node, "blur", () => closeTooltip(true)), addMeltEventListener(node, "keydown", (e) => {
        if (get_store_value(closeOnEscape) && e.key === kbd.ESCAPE) {
          if (openTimeout) {
            window.clearTimeout(openTimeout);
            openTimeout = null;
          }
          open.set(false);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const isVisible = derivedVisible({ open, activeTrigger, forceVisible });
  const content = builder(name2("content"), {
    stores: [isVisible, portal],
    returned: ([$isVisible, $portal]) => {
      return {
        role: "tooltip",
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: ids.content,
        "data-portal": $portal ? "" : void 0
      };
    },
    action: (node) => {
      let unsubFloating = noop2;
      let unsubPortal = noop2;
      const unsubDerived = effect([isVisible, activeTrigger, positioning, portal], ([$isVisible, $activeTrigger, $positioning, $portal]) => {
        if (!$isVisible || !$activeTrigger) {
          unsubPortal();
          unsubFloating();
          return;
        }
        tick().then(() => {
          const floatingReturn = useFloating($activeTrigger, node, $positioning);
          unsubFloating = floatingReturn.destroy;
          if (!$portal) {
            unsubPortal();
            return;
          }
          const portalDest = getPortalDestination(node, $portal);
          if (portalDest) {
            const portalReturn = usePortal(node, portalDest);
            if (portalReturn && portalReturn.destroy) {
              unsubPortal = portalReturn.destroy;
            }
          }
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "pointerenter", openTooltip), addMeltEventListener(node, "pointerdown", openTooltip));
      return {
        destroy() {
          unsubEvents();
          unsubPortal();
          unsubFloating();
          unsubDerived();
        }
      };
    }
  });
  const arrow22 = builder(name2("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  let isMouseInTooltipArea = false;
  effect([isVisible, activeTrigger], ([$isVisible, $activeTrigger]) => {
    if (!$isVisible || !$activeTrigger)
      return;
    return executeCallbacks(addEventListener(document, "mousemove", (e) => {
      const contentEl = document.getElementById(ids.content);
      if (!contentEl)
        return;
      const polygon = makeHullFromElements([$activeTrigger, contentEl]);
      isMouseInTooltipArea = pointInPolygon({
        x: e.clientX,
        y: e.clientY
      }, polygon);
      if (isMouseInTooltipArea || document.activeElement === $activeTrigger && !clickedTrigger) {
        openTooltip();
      } else {
        closeTooltip();
      }
    }));
  });
  return {
    elements: {
      trigger,
      content,
      arrow: arrow22
    },
    states: { open },
    options: options2
  };
}
function generateId() {
  return nanoid(10);
}
function removeUndefined(obj) {
  const result = {};
  for (const key3 in obj) {
    const value = obj[key3];
    if (value !== void 0) {
      result[key3] = value;
    }
  }
  return result;
}
function getOptionUpdater(options2) {
  return function(key3, value) {
    if (value === void 0)
      return;
    const store = options2[key3];
    store.set(value);
  };
}
function getAttrs(builders) {
  const attrs = {};
  builders.forEach((builder2) => {
    Object.keys(builder2).forEach((key3) => {
      if (key3 !== "action") {
        attrs[key3] = builder2[key3];
      }
    });
  });
  return attrs;
}
function disabledAttrs(disabled) {
  return disabled ? { "aria-disabled": true, "data-disabled": "" } : {};
}
function setTransitionTimes(transitionTimes, transitionsObj) {
  if (!isBrowser)
    return;
  const { transition, transitionConfig, inTransition, inTransitionConfig, outTransition, outTransitionConfig } = transitionsObj;
  if (transition) {
    if (transitionConfig) {
      const { delay: delay4, duration: duration2 } = transition(document.body, transitionConfig);
      const time2 = calcTime(delay4, duration2);
      transitionTimes.set({
        in: time2,
        out: time2
      });
      return;
    }
    const { delay: delay3, duration } = transition(document.body);
    const time = calcTime(delay3, duration);
    transitionTimes.set({
      in: time,
      out: time
    });
    return;
  }
  let inTime = 0;
  let outTime = 0;
  if (inTransition) {
    if (inTransitionConfig) {
      const { delay: delay3, duration } = inTransition(document.body, inTransitionConfig);
      inTime = calcTime(delay3, duration);
    } else {
      const { delay: delay3, duration } = inTransition(document.body);
      inTime = calcTime(delay3, duration);
    }
  }
  if (outTransition) {
    if (outTransitionConfig) {
      const { delay: delay3, duration } = outTransition(document.body, outTransitionConfig);
      outTime = calcTime(delay3, duration);
    } else {
      const { delay: delay3, duration } = outTransition(document.body);
      outTime = calcTime(delay3, duration);
    }
  }
  transitionTimes.set({
    in: inTime,
    out: outTime
  });
}
function calcTime(delay3, duration) {
  const numDelay = delay3 ?? 0;
  const numDuration = duration ?? 0;
  return numDelay + numDuration;
}
function createDispatcher() {
  const dispatch = createEventDispatcher();
  return (e) => {
    const { originalEvent } = e.detail;
    const { cancelable } = e;
    const type = originalEvent.type;
    const shouldContinue = dispatch(type, { originalEvent, currentTarget: originalEvent.currentTarget }, { cancelable });
    if (!shouldContinue) {
      e.preventDefault();
    }
  };
}
function set$4(props) {
  const alertDialog = createDialog({
    ...removeUndefined(props),
    role: "alertdialog"
  });
  setContext(NAME$4, {
    ...alertDialog,
    transitionTimes: props.transitionTimes,
    tOpen: props.tOpen
  });
  return {
    ...alertDialog,
    updateOption: getOptionUpdater(alertDialog.options)
  };
}
function get$4() {
  return getContext(NAME$4);
}
function set$3(props) {
  const contextMenu = createContextMenu(removeUndefined(props));
  setContext(NAME$3, contextMenu);
  return {
    ...contextMenu,
    updateOption: getOptionUpdater(contextMenu.options)
  };
}
function get$3() {
  return getContext(NAME$3);
}
function setSub$1(props) {
  const { builders: { createSubmenu } } = get$3();
  const sub = createSubmenu(removeUndefined(props));
  setContext(SUB_NAME$1, sub);
  return {
    ...sub,
    updateOption: getOptionUpdater(sub.options)
  };
}
function getSub() {
  return getContext(SUB_NAME$1);
}
function setRadioGroup$1(props) {
  const { builders: { createMenuRadioGroup } } = get$3();
  const radioGroup = createMenuRadioGroup(removeUndefined(props));
  setContext(RADIO_GROUP_NAME$1, radioGroup);
  return radioGroup;
}
function setRadioItem$1(value) {
  const radioGroup = getContext(RADIO_GROUP_NAME$1);
  setContext(RADIO_ITEM_NAME$1, {
    isChecked: radioGroup.helpers.isChecked,
    value
  });
  return radioGroup;
}
function getRadioIndicator$1() {
  return getContext(RADIO_ITEM_NAME$1);
}
function getSubTrigger$1() {
  return getContext(SUB_NAME$1);
}
function getContent$1(sideoffset = 5) {
  const menu = get$3();
  menu.options.positioning.update((prev) => ({ ...prev, gutter: sideoffset }));
  return menu;
}
function getSubContent$1(sideOffset = -1) {
  const submenu = getContext(SUB_NAME$1);
  const { options: { positioning } } = submenu;
  positioning.update((prev) => ({ ...prev, gutter: sideOffset }));
  return submenu;
}
function setCheckboxItem$1(props) {
  const { builders: { createCheckboxItem } } = get$3();
  const checkboxItem = createCheckboxItem(removeUndefined(props));
  setContext(CHECKBOX_ITEM_NAME$1, checkboxItem.states.checked);
  return {
    ...checkboxItem,
    updateOption: getOptionUpdater(checkboxItem.options)
  };
}
function getCheckboxIndicator$1() {
  return getContext(CHECKBOX_ITEM_NAME$1);
}
function setGroup$1() {
  const { elements: { group } } = get$3();
  const id = generateId();
  setContext(GROUP_NAME$1, id);
  return { group, id };
}
function getGroupLabel$1() {
  const id = getContext(GROUP_NAME$1) ?? generateId();
  const { elements: { groupLabel } } = get$3();
  return { groupLabel, id };
}
function setArrow$2(size2 = 8) {
  const menu = get$3();
  menu.options.arrowSize.set(size2);
  return menu;
}
function set$2(props) {
  const dialog = createDialog({ ...removeUndefined(props), role: "dialog" });
  setContext(NAME$2, {
    ...dialog,
    transitionTimes: props.transitionTimes,
    tOpen: props.tOpen
  });
  return {
    ...dialog,
    updateOption: getOptionUpdater(dialog.options)
  };
}
function get$2() {
  return getContext(NAME$2);
}
function get$1() {
  return getContext(NAME$1);
}
function set$1(props) {
  const dropdownMenu = createDropdownMenu({ ...removeUndefined(props), forceVisible: true });
  setContext(NAME$1, dropdownMenu);
  return {
    ...dropdownMenu,
    updateOption: getOptionUpdater(dropdownMenu.options)
  };
}
function setSub(props) {
  const { builders: { createSubmenu } } = get$1();
  const sub = createSubmenu(removeUndefined(props));
  setContext(SUB_NAME, sub);
  return {
    ...sub,
    updateOption: getOptionUpdater(sub.options)
  };
}
function setRadioGroup(props) {
  const { builders: { createMenuRadioGroup } } = get$1();
  const radioGroup = createMenuRadioGroup(props);
  setContext(RADIO_GROUP_NAME, radioGroup);
  return radioGroup;
}
function setRadioItem(value) {
  const dropdownMenu = getContext(RADIO_GROUP_NAME);
  setContext(RADIO_ITEM_NAME, { isChecked: dropdownMenu.helpers.isChecked, value });
  return dropdownMenu;
}
function getRadioIndicator() {
  return getContext(RADIO_ITEM_NAME);
}
function getSubTrigger() {
  const submenu = getContext(SUB_NAME);
  return submenu;
}
function getContent(sideoffset = 5) {
  const menu = get$1();
  menu.options.positioning.update((prev) => ({ ...prev, gutter: sideoffset }));
  return menu;
}
function getSubContent(sideOffset = -1) {
  const submenu = getContext(SUB_NAME);
  submenu.options.positioning.update((prev) => ({ ...prev, gutter: sideOffset }));
  return submenu;
}
function setCheckboxItem(props) {
  const { builders: { createCheckboxItem } } = get$1();
  const checkboxItem = createCheckboxItem(removeUndefined(props));
  setContext(CHECKBOX_ITEM_NAME, checkboxItem.states.checked);
  return {
    ...checkboxItem,
    updateOption: getOptionUpdater(checkboxItem.options)
  };
}
function getCheckboxIndicator() {
  return getContext(CHECKBOX_ITEM_NAME);
}
function setGroup() {
  const { elements: { group } } = get$1();
  const id = generateId();
  setContext(GROUP_NAME, id);
  return { group, id };
}
function getGroupLabel() {
  const id = getContext(GROUP_NAME) ?? generateId();
  const { elements: { groupLabel } } = get$1();
  return { groupLabel, id };
}
function setArrow$1(size2 = 8) {
  const menu = get$1();
  menu.options.arrowSize.set(size2);
  return menu;
}
function set(props) {
  const tooltip = createTooltip({
    positioning: {
      placement: "top"
    },
    openDelay: 700,
    ...removeUndefined(props)
  });
  setContext(NAME, tooltip);
  return {
    ...tooltip,
    updateOption: getOptionUpdater(tooltip.options)
  };
}
function get2(sideOffset = 0) {
  const tooltip = getContext(NAME);
  const { options: { positioning } } = tooltip;
  positioning.update((prev) => ({ ...prev, gutter: sideOffset }));
  return tooltip;
}
function setArrow(size2 = 8) {
  const tooltip = get2();
  tooltip.options.arrowSize.set(size2);
  return tooltip;
}
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
function fade(node, { delay: delay3 = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay: delay3,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function fly(node, { delay: delay3 = 0, duration = 400, easing = cubicOut, x: x2 = 0, y: y2 = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const od = target_opacity * (1 - opacity);
  const [xValue, xUnit] = split_css_unit(x2);
  const [yValue, yUnit] = split_css_unit(y2);
  return {
    delay: delay3,
    duration,
    easing,
    css: (t, u2) => `
			transform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});
			opacity: ${target_opacity - od * u2}`
  };
}
var dirty_components, binding_callbacks, render_callbacks, flush_callbacks, resolved_promise, update_scheduled, seen_callbacks, flushidx, void_element_names, afterNavigate, hiddenAction, isFunctionWithParams, isBrowser$1, isFunction, overridable, urlAlphabet, nanoid, kbd, FIRST_KEYS, LAST_KEYS, FIRST_LAST_KEYS, SELECTION_KEYS, isDom, pt, isTouchDevice, isMac, isApple, isIos, LOCK_CLASSNAME, defaults$6, documentClickStore, useClickOutside, documentEscapeKeyStore, useEscapeKeydown, min, max, round, floor, createCoords, oppositeSideMap, oppositeAlignmentMap, computePosition$1, arrow, flip, offset, shift, size, noOffsets, getElementRects, platform, computePosition, defaultConfig$1, ARROW_TRANSFORM, candidateSelectors, candidateSelector, NoElement, matches, getRootNode, isInert, isContentEditable, getCandidates, getCandidatesIteratively, hasTabIndex, getTabIndex, getSortOrderTabIndex, sortOrderedTabbables, isInput, isHiddenInput, isDetailsWithSummary, getCheckedRadio, isTabbableRadio, isRadio, isNonTabbableRadio, isNodeAttached, isZeroArea, isHidden, isDisabledFromFieldset, isNodeMatchingSelectorFocusable, isNodeMatchingSelectorTabbable, isValidShadowRootTabbable, sortByOrder, tabbable, focusable, isTabbable, focusableCandidateSelector, isFocusable, activeFocusTraps, isSelectableInput, isEscapeEvent, isTabEvent, isKeyForward, isKeyBackward, delay, findIndex, valueOrHandler, getActualTarget, internalTrapStack, createFocusTrap$1, defaultConfig, usePopper, usePortal, SUB_OPEN_KEYS, SUB_CLOSE_KEYS, defaults$5, defaults$4, name$2, selector, name$1, defaults$3, openDialogIds, defaults$2, defaults$1, createSeparator, defaults, name2, isBrowser, NAME$4, ctx$5, AlertDialog, AlertDialogTitle, AlertDialogAction, AlertDialogCancel, AlertDialogPortal, AlertDialogContent, AlertDialogOverlay, AlertDialogDescription, Button$1, NAME$3, SUB_NAME$1, RADIO_GROUP_NAME$1, CHECKBOX_ITEM_NAME$1, RADIO_ITEM_NAME$1, GROUP_NAME$1, ctx$4, ContextMenu, ContextMenuItem, ContextMenuContent, ContextMenuTrigger, ContextMenuSeparator, NAME$2, ctx$3, Dialog, DialogTitle, DialogPortal, DialogContent, DialogOverlay, NAME$1, SUB_NAME, RADIO_GROUP_NAME, CHECKBOX_ITEM_NAME, RADIO_ITEM_NAME, GROUP_NAME, ctx$2, DropdownMenu, DropdownMenuItem, DropdownMenuGroup, DropdownMenuContent, DropdownMenuTrigger, DropdownMenuSeparator, ctx$1, Label$1, NAME, ctx, Tooltip, TooltipContent, TooltipTrigger, flyAndScale, Alert_dialog_title, Button, buttonVariants, Alert_dialog_action, Alert_dialog_cancel, Alert_dialog_portal, Alert_dialog_footer, Alert_dialog_header, Alert_dialog_overlay, Alert_dialog_content, Alert_dialog_description, Root$5, alertDialogDeleteItemId, DeleteItemAlertDialog, Dialog_title, Dialog_portal, Dialog_footer, Dialog_header, Dialog_overlay, Dialog_content, Root$4, Input, Label, dialogRenameItem, RenameItemDialog, searchDialogOpen, SearchCommand, Sheet_portal, Sheet_overlay, Sheet_content, Root$3, sheetVariants, sheetTransitions, sortOrder, Tooltip_content, Root$2, Trigger$2, SidebarNewFolderButton, SidebarNewNoteButton, SidebarSearchButton, Dropdown_menu_item, Dropdown_menu_content, Check3, Check$1, ChevronRight, ChevronRight$1, Pencil2, Pencil2$1, Trash, Trash$1, Dropdown_menu_separator, Root$1, Trigger$1, Group, SidebarSortButton, Context_menu_item, Context_menu_content, Context_menu_separator, Root2, Trigger, TreeView, Sidebar, Layout2;
var init_layout_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/(authed)/_layout.svelte.js"() {
    init_ssr();
    init_stores();
    init_index2();
    init_clsx();
    init_dist3();
    init_Toaster_svelte_svelte_type_style_lang();
    init_tailwind_merge();
    dirty_components = [];
    binding_callbacks = [];
    render_callbacks = [];
    flush_callbacks = [];
    resolved_promise = /* @__PURE__ */ Promise.resolve();
    update_scheduled = false;
    seen_callbacks = /* @__PURE__ */ new Set();
    flushidx = 0;
    void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
    afterNavigate = /* @__PURE__ */ client_method("after_navigate");
    hiddenAction = (obj) => {
      return new Proxy(obj, {
        get(target, prop, receiver) {
          return Reflect.get(target, prop, receiver);
        },
        ownKeys(target) {
          return Reflect.ownKeys(target).filter((key3) => key3 !== "action");
        }
      });
    };
    isFunctionWithParams = (fn) => {
      return typeof fn === "function";
    };
    isBrowser$1 = typeof document !== "undefined";
    isFunction = (v) => typeof v === "function";
    overridable = (store, onChange) => {
      const update2 = (updater, sideEffect) => {
        store.update((curr) => {
          const next = updater(curr);
          let res = next;
          if (onChange) {
            res = onChange({ curr, next });
          }
          sideEffect?.(res);
          return res;
        });
      };
      const set2 = (curr) => {
        update2(() => curr);
      };
      return {
        ...store,
        update: update2,
        set: set2
      };
    };
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    nanoid = (size2 = 21) => {
      let id = "";
      let i2 = size2;
      while (i2--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    kbd = {
      ALT: "Alt",
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      BACKSPACE: "Backspace",
      CAPS_LOCK: "CapsLock",
      CONTROL: "Control",
      DELETE: "Delete",
      END: "End",
      ENTER: "Enter",
      ESCAPE: "Escape",
      F1: "F1",
      F10: "F10",
      F11: "F11",
      F12: "F12",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      HOME: "Home",
      META: "Meta",
      PAGE_DOWN: "PageDown",
      PAGE_UP: "PageUp",
      SHIFT: "Shift",
      SPACE: " ",
      TAB: "Tab",
      CTRL: "Control"
    };
    FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];
    LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];
    FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
    SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];
    isDom = () => typeof window !== "undefined";
    pt = (v) => isDom() && v.test(getPlatform());
    isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
    isMac = () => pt(/^Mac/) && !isTouchDevice();
    isApple = () => pt(/mac|iphone|ipad|ipod/i);
    isIos = () => isApple() && !isMac();
    LOCK_CLASSNAME = "data-melt-scroll-lock";
    defaults$6 = {
      onMatch: handleRovingFocus
    };
    documentClickStore = readable(void 0, (set2) => {
      function clicked(event) {
        set2(event);
        set2(void 0);
      }
      const unsubscribe = addEventListener(document, "pointerdown", clicked, {
        passive: false,
        capture: true
      });
      return unsubscribe;
    });
    useClickOutside = (node, config = {}) => {
      let options2 = { enabled: true, ...config };
      function isEnabled() {
        return typeof options2.enabled === "boolean" ? options2.enabled : get_store_value(options2.enabled);
      }
      const unsubscribe = documentClickStore.subscribe((e) => {
        if (!isEnabled() || !e || e.target === node) {
          return;
        }
        const composedPath = e.composedPath();
        if (composedPath.includes(node))
          return;
        if (options2.ignore) {
          if (isFunction(options2.ignore)) {
            if (options2.ignore(e))
              return;
          } else if (Array.isArray(options2.ignore)) {
            if (options2.ignore.length > 0 && options2.ignore.some((ignoreEl) => {
              return ignoreEl && (e.target === ignoreEl || composedPath.includes(ignoreEl));
            }))
              return;
          }
        }
        options2.handler?.(e);
      });
      return {
        update(params) {
          options2 = { ...options2, ...params };
        },
        destroy() {
          unsubscribe();
        }
      };
    };
    documentEscapeKeyStore = readable(void 0, (set2) => {
      function keydown(event) {
        if (event && event.key === kbd.ESCAPE) {
          set2(event);
        }
        set2(void 0);
      }
      const unsubscribe = addEventListener(document, "keydown", keydown, {
        passive: false,
        capture: true
      });
      return unsubscribe;
    });
    useEscapeKeydown = (node, config = {}) => {
      node.dataset.escapee = "";
      let options2 = { enabled: true, ...config };
      function isEnabled() {
        return typeof options2.enabled === "boolean" ? options2.enabled : get_store_value(options2.enabled);
      }
      const unsubscribe = documentEscapeKeyStore.subscribe((e) => {
        if (!e || !isEnabled())
          return;
        const target = e.target;
        if (!isHTMLElement$1(target) || target.closest("[data-escapee]") !== node) {
          return;
        }
        if (options2.ignore) {
          if (isFunction(options2.ignore)) {
            if (options2.ignore(e))
              return;
          } else if (Array.isArray(options2.ignore)) {
            if (options2.ignore.length > 0 && options2.ignore.some((ignoreEl) => {
              return ignoreEl && target === ignoreEl;
            }))
              return;
          }
        }
        options2.handler?.(e);
      });
      return {
        update(params) {
          options2 = { ...options2, ...params };
        },
        destroy() {
          node.removeAttribute("data-escapee");
          unsubscribe();
        }
      };
    };
    min = Math.min;
    max = Math.max;
    round = Math.round;
    floor = Math.floor;
    createCoords = (v) => ({
      x: v,
      y: v
    });
    oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    oppositeAlignmentMap = {
      start: "end",
      end: "start"
    };
    computePosition$1 = async (reference, floating, config) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform: platform2
      } = config;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
      let rects = await platform2.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x: x2,
        y: y2
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i2 = 0; i2 < validMiddleware.length; i2++) {
        const {
          name: name22,
          fn
        } = validMiddleware[i2];
        const {
          x: nextX,
          y: nextY,
          data,
          reset: reset3
        } = await fn({
          x: x2,
          y: y2,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference,
            floating
          }
        });
        x2 = nextX != null ? nextX : x2;
        y2 = nextY != null ? nextY : y2;
        middlewareData = {
          ...middlewareData,
          [name22]: {
            ...middlewareData[name22],
            ...data
          }
        };
        if (reset3 && resetCount <= 50) {
          resetCount++;
          if (typeof reset3 === "object") {
            if (reset3.placement) {
              statefulPlacement = reset3.placement;
            }
            if (reset3.rects) {
              rects = reset3.rects === true ? await platform2.getElementRects({
                reference,
                floating,
                strategy
              }) : reset3.rects;
            }
            ({
              x: x2,
              y: y2
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i2 = -1;
          continue;
        }
      }
      return {
        x: x2,
        y: y2,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    arrow = (options2) => ({
      name: "arrow",
      options: options2,
      async fn(state) {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          platform: platform2,
          elements,
          middlewareData
        } = state;
        const {
          element,
          padding = 0
        } = evaluate(options2, state) || {};
        if (element == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding);
        const coords = {
          x: x2,
          y: y2
        };
        const axis = getAlignmentAxis(placement);
        const length = getAxisLength(axis);
        const arrowDimensions = await platform2.getDimensions(element);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
          clientSize = elements.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = min(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
        const min$1 = minPadding;
        const max2 = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset2 = clamp(min$1, center, max2);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset2,
            centerOffset: center - offset2 - alignmentOffset,
            ...shouldAddOffset && {
              alignmentOffset
            }
          },
          reset: shouldAddOffset
        };
      }
    });
    flip = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "flip",
        options: options2,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform: platform2,
            elements
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options2, state);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides[0]], overflow[sides[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements[nextIndex];
            if (nextPlacement) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$map$so;
                  const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    };
    offset = function(options2) {
      if (options2 === void 0) {
        options2 = 0;
      }
      return {
        name: "offset",
        options: options2,
        async fn(state) {
          const {
            x: x2,
            y: y2
          } = state;
          const diffCoords = await convertValueToCoords(state, options2);
          return {
            x: x2 + diffCoords.x,
            y: y2 + diffCoords.y,
            data: diffCoords
          };
        }
      };
    };
    shift = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "shift",
        options: options2,
        async fn(state) {
          const {
            x: x2,
            y: y2,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x22,
                  y: y22
                } = _ref;
                return {
                  x: x22,
                  y: y22
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate(options2, state);
          const coords = {
            x: x2,
            y: y2
          };
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x2,
              y: limitedCoords.y - y2
            }
          };
        }
      };
    };
    size = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "size",
        options: options2,
        async fn(state) {
          const {
            placement,
            rects,
            platform: platform2,
            elements
          } = state;
          const {
            apply: apply2 = () => {
            },
            ...detectOverflowOptions
          } = evaluate(options2, state);
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis = getSideAxis(placement) === "y";
          const {
            width,
            height
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const overflowAvailableHeight = height - overflow[heightSide];
          const overflowAvailableWidth = width - overflow[widthSide];
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if (isYAxis) {
            const maximumClippingWidth = width - overflow.left - overflow.right;
            availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
          } else {
            const maximumClippingHeight = height - overflow.top - overflow.bottom;
            availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max(overflow.left, 0);
            const xMax = max(overflow.right, 0);
            const yMin = max(overflow.top, 0);
            const yMax = max(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
            } else {
              availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
            }
          }
          await apply2({
            ...state,
            availableWidth,
            availableHeight
          });
          const nextDimensions = await platform2.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        }
      };
    };
    noOffsets = /* @__PURE__ */ createCoords(0);
    getElementRects = async function(_ref) {
      let {
        reference,
        floating,
        strategy
      } = _ref;
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      return {
        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
        floating: {
          x: 0,
          y: 0,
          ...await getDimensionsFn(floating)
        }
      };
    };
    platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement,
      getClippingRect,
      getOffsetParent,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale,
      isElement,
      isRTL
    };
    computePosition = (reference, floating, options2) => {
      const cache = /* @__PURE__ */ new Map();
      const mergedOptions = {
        platform,
        ...options2
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache
      };
      return computePosition$1(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
      });
    };
    defaultConfig$1 = {
      strategy: "absolute",
      placement: "top",
      gutter: 5,
      flip: true,
      sameWidth: false,
      overflowPadding: 8
    };
    ARROW_TRANSFORM = {
      bottom: "rotate(45deg)",
      left: "rotate(135deg)",
      top: "rotate(225deg)",
      right: "rotate(315deg)"
    };
    candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
    candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    NoElement = typeof Element === "undefined";
    matches = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
      var _element$getRootNode;
      return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
    } : function(element) {
      return element === null || element === void 0 ? void 0 : element.ownerDocument;
    };
    isInert = function isInert2(node, lookUp) {
      var _node$getAttribute;
      if (lookUp === void 0) {
        lookUp = true;
      }
      var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
      var inert = inertAtt === "" || inertAtt === "true";
      var result = inert || lookUp && node && isInert2(node.parentNode);
      return result;
    };
    isContentEditable = function isContentEditable2(node) {
      var _node$getAttribute2;
      var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
      return attValue === "" || attValue === "true";
    };
    getCandidates = function getCandidates2(el, includeContainer, filter) {
      if (isInert(el)) {
        return [];
      }
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter);
      return candidates;
    };
    getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options2) {
      var candidates = [];
      var elementsToCheck = Array.from(elements);
      while (elementsToCheck.length) {
        var element = elementsToCheck.shift();
        if (isInert(element, false)) {
          continue;
        }
        if (element.tagName === "SLOT") {
          var assigned = element.assignedElements();
          var content = assigned.length ? assigned : element.children;
          var nestedCandidates = getCandidatesIteratively2(content, true, options2);
          if (options2.flatten) {
            candidates.push.apply(candidates, nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element,
              candidates: nestedCandidates
            });
          }
        } else {
          var validCandidate = matches.call(element, candidateSelector);
          if (validCandidate && options2.filter(element) && (includeContainer || !elements.includes(element))) {
            candidates.push(element);
          }
          var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
          typeof options2.getShadowRoot === "function" && options2.getShadowRoot(element);
          var validShadowRoot = !isInert(shadowRoot, false) && (!options2.shadowRootFilter || options2.shadowRootFilter(element));
          if (shadowRoot && validShadowRoot) {
            var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options2);
            if (options2.flatten) {
              candidates.push.apply(candidates, _nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element,
                candidates: _nestedCandidates
              });
            }
          } else {
            elementsToCheck.unshift.apply(elementsToCheck, element.children);
          }
        }
      }
      return candidates;
    };
    hasTabIndex = function hasTabIndex2(node) {
      return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
    };
    getTabIndex = function getTabIndex2(node) {
      if (!node) {
        throw new Error("No node provided");
      }
      if (node.tabIndex < 0) {
        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
          return 0;
        }
      }
      return node.tabIndex;
    };
    getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
      var tabIndex = getTabIndex(node);
      if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
        return 0;
      }
      return tabIndex;
    };
    sortOrderedTabbables = function sortOrderedTabbables2(a2, b) {
      return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
    };
    isInput = function isInput2(node) {
      return node.tagName === "INPUT";
    };
    isHiddenInput = function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    };
    isDetailsWithSummary = function isDetailsWithSummary2(node) {
      var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r2;
    };
    getCheckedRadio = function getCheckedRadio2(nodes, form) {
      for (var i2 = 0; i2 < nodes.length; i2++) {
        if (nodes[i2].checked && nodes[i2].form === form) {
          return nodes[i2];
        }
      }
    };
    isTabbableRadio = function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = function queryRadios2(name22) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name22 + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    isRadio = function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    };
    isNonTabbableRadio = function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    isNodeAttached = function isNodeAttached2(node) {
      var _nodeRoot;
      var nodeRoot = node && getRootNode(node);
      var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
      var attached = false;
      if (nodeRoot && nodeRoot !== node) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
        while (!attached && nodeRootHost) {
          var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
          nodeRoot = getRootNode(nodeRootHost);
          nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
          attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
        }
      }
      return attached;
    };
    isZeroArea = function isZeroArea2(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    };
    isHidden = function isHidden2(node, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
        if (typeof getShadowRoot === "function") {
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              node = rootNode.host;
            } else {
              node = parentElement;
            }
          }
          node = originalNode;
        }
        if (isNodeAttached(node)) {
          return !node.getClientRects().length;
        }
        if (displayCheck !== "legacy-full") {
          return true;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node);
      }
      return false;
    };
    isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i2 = 0; i2 < parentNode.children.length; i2++) {
              var child = parentNode.children.item(i2);
              if (child.tagName === "LEGEND") {
                return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    };
    isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options2, node) {
      if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
      //  because we're limited in the type of selectors we can use in JSDom (see related
      //  note related to `candidateSelectors`)
      isInert(node) || isHiddenInput(node) || isHidden(node, options2) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    };
    isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options2, node) {
      if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options2, node)) {
        return false;
      }
      return true;
    };
    isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
      var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
      if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
      }
      return false;
    };
    sortByOrder = function sortByOrder2(candidates) {
      var regularTabbables = [];
      var orderedTabbables = [];
      candidates.forEach(function(item, i2) {
        var isScope = !!item.scopeParent;
        var element = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element, isScope);
        var elements = isScope ? sortByOrder2(item.candidates) : element;
        if (candidateTabindex === 0) {
          isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
        } else {
          orderedTabbables.push({
            documentOrder: i2,
            tabIndex: candidateTabindex,
            item,
            isScope,
            content: elements
          });
        }
      });
      return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
      }, []).concat(regularTabbables);
    };
    tabbable = function tabbable2(container, options2) {
      options2 = options2 || {};
      var candidates;
      if (options2.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options2.includeContainer, {
          filter: isNodeMatchingSelectorTabbable.bind(null, options2),
          flatten: false,
          getShadowRoot: options2.getShadowRoot,
          shadowRootFilter: isValidShadowRootTabbable
        });
      } else {
        candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options2));
      }
      return sortByOrder(candidates);
    };
    focusable = function focusable2(container, options2) {
      options2 = options2 || {};
      var candidates;
      if (options2.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options2.includeContainer, {
          filter: isNodeMatchingSelectorFocusable.bind(null, options2),
          flatten: true,
          getShadowRoot: options2.getShadowRoot
        });
      } else {
        candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options2));
      }
      return candidates;
    };
    isTabbable = function isTabbable2(node, options2) {
      options2 = options2 || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options2, node);
    };
    focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
    isFocusable = function isFocusable2(node, options2) {
      options2 = options2 || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options2, node);
    };
    activeFocusTraps = {
      activateTrap: function activateTrap(trapStack, trap) {
        if (trapStack.length > 0) {
          var activeTrap = trapStack[trapStack.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex === -1) {
          trapStack.push(trap);
        } else {
          trapStack.splice(trapIndex, 1);
          trapStack.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trapStack, trap) {
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex !== -1) {
          trapStack.splice(trapIndex, 1);
        }
        if (trapStack.length > 0) {
          trapStack[trapStack.length - 1].unpause();
        }
      }
    };
    isSelectableInput = function isSelectableInput2(node) {
      return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
    };
    isEscapeEvent = function isEscapeEvent2(e) {
      return (e === null || e === void 0 ? void 0 : e.key) === "Escape" || (e === null || e === void 0 ? void 0 : e.key) === "Esc" || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
    };
    isTabEvent = function isTabEvent2(e) {
      return (e === null || e === void 0 ? void 0 : e.key) === "Tab" || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
    };
    isKeyForward = function isKeyForward2(e) {
      return isTabEvent(e) && !e.shiftKey;
    };
    isKeyBackward = function isKeyBackward2(e) {
      return isTabEvent(e) && e.shiftKey;
    };
    delay = function delay2(fn) {
      return setTimeout(fn, 0);
    };
    findIndex = function findIndex2(arr, fn) {
      var idx = -1;
      arr.every(function(value, i2) {
        if (fn(value)) {
          idx = i2;
          return false;
        }
        return true;
      });
      return idx;
    };
    valueOrHandler = function valueOrHandler2(value) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      return typeof value === "function" ? value.apply(void 0, params) : value;
    };
    getActualTarget = function getActualTarget2(event) {
      return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
    };
    internalTrapStack = [];
    createFocusTrap$1 = function createFocusTrap(elements, userOptions) {
      var doc3 = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
      var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
      var config = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true,
        isKeyForward,
        isKeyBackward
      }, userOptions);
      var state = {
        // containers given to createFocusTrap()
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying tabbable nodes in `containers` in the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{
        //   container: HTMLElement,
        //   tabbableNodes: Array<HTMLElement>, // empty if none
        //   focusableNodes: Array<HTMLElement>, // empty if none
        //   posTabIndexesFound: boolean,
        //   firstTabbableNode: HTMLElement|undefined,
        //   lastTabbableNode: HTMLElement|undefined,
        //   firstDomTabbableNode: HTMLElement|undefined,
        //   lastDomTabbableNode: HTMLElement|undefined,
        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
        // }>}
        containerGroups: [],
        // same order/length as `containers` list
        // references to objects in `containerGroups`, but only those that actually have
        //  tabbable nodes in them
        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
        //  the same length
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        // timer ID for when delayInitialFocus is true and initial focus in this trap
        //  has been delayed during activation
        delayInitialFocusTimer: void 0,
        // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
        recentNavEvent: void 0
      };
      var trap;
      var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
      };
      var findContainerIndex = function findContainerIndex2(element, event) {
        var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
        return state.containerGroups.findIndex(function(_ref) {
          var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
          return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
          //  web components if the `tabbableOptions.getShadowRoot` option was used for
          //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
          //  look inside web components even if open)
          (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
            return node === element;
          });
        });
      };
      var getNodeForOption = function getNodeForOption2(optionName) {
        var optionValue = config[optionName];
        if (typeof optionValue === "function") {
          for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            params[_key2 - 1] = arguments[_key2];
          }
          optionValue = optionValue.apply(void 0, params);
        }
        if (optionValue === true) {
          optionValue = void 0;
        }
        if (!optionValue) {
          if (optionValue === void 0 || optionValue === false) {
            return optionValue;
          }
          throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue;
        if (typeof optionValue === "string") {
          node = doc3.querySelector(optionValue);
          if (!node) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
        return node;
      };
      var getInitialFocusNode = function getInitialFocusNode2() {
        var node = getNodeForOption("initialFocus");
        if (node === false) {
          return false;
        }
        if (node === void 0 || !isFocusable(node, config.tabbableOptions)) {
          if (findContainerIndex(doc3.activeElement) >= 0) {
            node = doc3.activeElement;
          } else {
            var firstTabbableGroup = state.tabbableGroups[0];
            var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
            node = firstTabbableNode || getNodeForOption("fallbackFocus");
          }
        }
        if (!node) {
          throw new Error("Your focus-trap needs to have at least one focusable element");
        }
        return node;
      };
      var updateTabbableNodes = function updateTabbableNodes2() {
        state.containerGroups = state.containers.map(function(container) {
          var tabbableNodes = tabbable(container, config.tabbableOptions);
          var focusableNodes = focusable(container, config.tabbableOptions);
          var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
          var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
          var firstDomTabbableNode = focusableNodes.find(function(node) {
            return isTabbable(node);
          });
          var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
            return isTabbable(node);
          });
          var posTabIndexesFound = !!tabbableNodes.find(function(node) {
            return getTabIndex(node) > 0;
          });
          return {
            container,
            tabbableNodes,
            focusableNodes,
            /** True if at least one node with positive `tabindex` was found in this container. */
            posTabIndexesFound,
            /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
            firstTabbableNode,
            /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
            lastTabbableNode,
            // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
            //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
            //  because that API doesn't work with Shadow DOM as well as it should (@see
            //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
            //  to address an edge case related to positive tabindex support, this seems like a much easier,
            //  "close enough most of the time" alternative for positive tabindexes which should generally
            //  be avoided anyway...
            /** First tabbable node in container, __DOM__ order; `undefined` if none. */
            firstDomTabbableNode,
            /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
            lastDomTabbableNode,
            /**
             * Finds the __tabbable__ node that follows the given node in the specified direction,
             *  in this container, if any.
             * @param {HTMLElement} node
             * @param {boolean} [forward] True if going in forward tab order; false if going
             *  in reverse.
             * @returns {HTMLElement|undefined} The next tabbable node, if any.
             */
            nextTabbableNode: function nextTabbableNode(node) {
              var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var nodeIdx = tabbableNodes.indexOf(node);
              if (nodeIdx < 0) {
                if (forward) {
                  return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                    return isTabbable(el);
                  });
                }
                return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                  return isTabbable(el);
                });
              }
              return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
            }
          };
        });
        state.tabbableGroups = state.containerGroups.filter(function(group) {
          return group.tabbableNodes.length > 0;
        });
        if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
          throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
        }
        if (state.containerGroups.find(function(g2) {
          return g2.posTabIndexesFound;
        }) && state.containerGroups.length > 1) {
          throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
        }
      };
      var tryFocus = function tryFocus2(node) {
        if (node === false) {
          return;
        }
        if (node === doc3.activeElement) {
          return;
        }
        if (!node || !node.focus) {
          tryFocus2(getInitialFocusNode());
          return;
        }
        node.focus({
          preventScroll: !!config.preventScroll
        });
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      };
      var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
        var node = getNodeForOption("setReturnFocus", previousActiveElement);
        return node ? node : node === false ? false : previousActiveElement;
      };
      var findNextNavNode = function findNextNavNode2(_ref2) {
        var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
        target = target || getActualTarget(event);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
          var containerIndex = findContainerIndex(target, event);
          var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
          if (containerIndex < 0) {
            if (isBackward) {
              destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
            } else {
              destinationNode = state.tabbableGroups[0].firstTabbableNode;
            }
          } else if (isBackward) {
            var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
              var firstTabbableNode = _ref3.firstTabbableNode;
              return target === firstTabbableNode;
            });
            if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
              startOfGroupIndex = containerIndex;
            }
            if (startOfGroupIndex >= 0) {
              var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
              var destinationGroup = state.tabbableGroups[destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target, false);
            }
          } else {
            var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
              var lastTabbableNode = _ref4.lastTabbableNode;
              return target === lastTabbableNode;
            });
            if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
              lastOfGroupIndex = containerIndex;
            }
            if (lastOfGroupIndex >= 0) {
              var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
              var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target);
            }
          }
        } else {
          destinationNode = getNodeForOption("fallbackFocus");
        }
        return destinationNode;
      };
      var checkPointerDown = function checkPointerDown2(e) {
        var target = getActualTarget(e);
        if (findContainerIndex(target, e) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e)) {
          trap.deactivate({
            // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
            //  which will result in the outside click setting focus to the node
            //  that was clicked (and if not focusable, to "nothing"); by setting
            //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
            //  on activation (or the configured `setReturnFocus` node), whether the
            //  outside click was on a focusable node or not
            returnFocus: config.returnFocusOnDeactivate
          });
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e)) {
          return;
        }
        e.preventDefault();
      };
      var checkFocusIn = function checkFocusIn2(event) {
        var target = getActualTarget(event);
        var targetContained = findContainerIndex(target, event) >= 0;
        if (targetContained || target instanceof Document) {
          if (targetContained) {
            state.mostRecentlyFocusedNode = target;
          }
        } else {
          event.stopImmediatePropagation();
          var nextNode;
          var navAcrossContainers = true;
          if (state.mostRecentlyFocusedNode) {
            if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
              var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
              var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
              if (tabbableNodes.length > 0) {
                var mruTabIdx = tabbableNodes.findIndex(function(node) {
                  return node === state.mostRecentlyFocusedNode;
                });
                if (mruTabIdx >= 0) {
                  if (config.isKeyForward(state.recentNavEvent)) {
                    if (mruTabIdx + 1 < tabbableNodes.length) {
                      nextNode = tabbableNodes[mruTabIdx + 1];
                      navAcrossContainers = false;
                    }
                  } else {
                    if (mruTabIdx - 1 >= 0) {
                      nextNode = tabbableNodes[mruTabIdx - 1];
                      navAcrossContainers = false;
                    }
                  }
                }
              }
            } else {
              if (!state.containerGroups.some(function(g2) {
                return g2.tabbableNodes.some(function(n) {
                  return getTabIndex(n) > 0;
                });
              })) {
                navAcrossContainers = false;
              }
            }
          } else {
            navAcrossContainers = false;
          }
          if (navAcrossContainers) {
            nextNode = findNextNavNode({
              // move FROM the MRU node, not event-related node (which will be the node that is
              //  outside the trap causing the focus escape we're trying to fix)
              target: state.mostRecentlyFocusedNode,
              isBackward: config.isKeyBackward(state.recentNavEvent)
            });
          }
          if (nextNode) {
            tryFocus(nextNode);
          } else {
            tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
          }
        }
        state.recentNavEvent = void 0;
      };
      var checkKeyNav = function checkKeyNav2(event) {
        var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        state.recentNavEvent = event;
        var destinationNode = findNextNavNode({
          event,
          isBackward
        });
        if (destinationNode) {
          if (isTabEvent(event)) {
            event.preventDefault();
          }
          tryFocus(destinationNode);
        }
      };
      var checkKey = function checkKey2(event) {
        if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
          event.preventDefault();
          trap.deactivate();
          return;
        }
        if (config.isKeyForward(event) || config.isKeyBackward(event)) {
          checkKeyNav(event, config.isKeyBackward(event));
        }
      };
      var checkClick = function checkClick2(e) {
        var target = getActualTarget(e);
        if (findContainerIndex(target, e) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e)) {
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e)) {
          return;
        }
        e.preventDefault();
        e.stopImmediatePropagation();
      };
      var addListeners = function addListeners2() {
        if (!state.active) {
          return;
        }
        activeFocusTraps.activateTrap(trapStack, trap);
        state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
          tryFocus(getInitialFocusNode());
        }) : tryFocus(getInitialFocusNode());
        doc3.addEventListener("focusin", checkFocusIn, true);
        doc3.addEventListener("mousedown", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc3.addEventListener("touchstart", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc3.addEventListener("click", checkClick, {
          capture: true,
          passive: false
        });
        doc3.addEventListener("keydown", checkKey, {
          capture: true,
          passive: false
        });
        return trap;
      };
      var removeListeners = function removeListeners2() {
        if (!state.active) {
          return;
        }
        doc3.removeEventListener("focusin", checkFocusIn, true);
        doc3.removeEventListener("mousedown", checkPointerDown, true);
        doc3.removeEventListener("touchstart", checkPointerDown, true);
        doc3.removeEventListener("click", checkClick, true);
        doc3.removeEventListener("keydown", checkKey, true);
        return trap;
      };
      var checkDomRemoval = function checkDomRemoval2(mutations) {
        var isFocusedNodeRemoved = mutations.some(function(mutation) {
          var removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some(function(node) {
            return node === state.mostRecentlyFocusedNode;
          });
        });
        if (isFocusedNodeRemoved) {
          tryFocus(getInitialFocusNode());
        }
      };
      var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
      var updateObservedNodes = function updateObservedNodes2() {
        if (!mutationObserver) {
          return;
        }
        mutationObserver.disconnect();
        if (state.active && !state.paused) {
          state.containers.map(function(container) {
            mutationObserver.observe(container, {
              subtree: true,
              childList: true
            });
          });
        }
      };
      trap = {
        get active() {
          return state.active;
        },
        get paused() {
          return state.paused;
        },
        activate: function activate(activateOptions) {
          if (state.active) {
            return this;
          }
          var onActivate = getOption(activateOptions, "onActivate");
          var onPostActivate = getOption(activateOptions, "onPostActivate");
          var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
          if (!checkCanFocusTrap) {
            updateTabbableNodes();
          }
          state.active = true;
          state.paused = false;
          state.nodeFocusedBeforeActivation = doc3.activeElement;
          onActivate === null || onActivate === void 0 ? void 0 : onActivate();
          var finishActivation = function finishActivation2() {
            if (checkCanFocusTrap) {
              updateTabbableNodes();
            }
            addListeners();
            updateObservedNodes();
            onPostActivate === null || onPostActivate === void 0 ? void 0 : onPostActivate();
          };
          if (checkCanFocusTrap) {
            checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
            return this;
          }
          finishActivation();
          return this;
        },
        deactivate: function deactivate(deactivateOptions) {
          if (!state.active) {
            return this;
          }
          var options2 = _objectSpread2({
            onDeactivate: config.onDeactivate,
            onPostDeactivate: config.onPostDeactivate,
            checkCanReturnFocus: config.checkCanReturnFocus
          }, deactivateOptions);
          clearTimeout(state.delayInitialFocusTimer);
          state.delayInitialFocusTimer = void 0;
          removeListeners();
          state.active = false;
          state.paused = false;
          updateObservedNodes();
          activeFocusTraps.deactivateTrap(trapStack, trap);
          var onDeactivate = getOption(options2, "onDeactivate");
          var onPostDeactivate = getOption(options2, "onPostDeactivate");
          var checkCanReturnFocus = getOption(options2, "checkCanReturnFocus");
          var returnFocus = getOption(options2, "returnFocus", "returnFocusOnDeactivate");
          onDeactivate === null || onDeactivate === void 0 ? void 0 : onDeactivate();
          var finishDeactivation = function finishDeactivation2() {
            delay(function() {
              if (returnFocus) {
                tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
              }
              onPostDeactivate === null || onPostDeactivate === void 0 ? void 0 : onPostDeactivate();
            });
          };
          if (returnFocus && checkCanReturnFocus) {
            checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
            return this;
          }
          finishDeactivation();
          return this;
        },
        pause: function pause(pauseOptions) {
          if (state.paused || !state.active) {
            return this;
          }
          var onPause = getOption(pauseOptions, "onPause");
          var onPostPause = getOption(pauseOptions, "onPostPause");
          state.paused = true;
          onPause === null || onPause === void 0 ? void 0 : onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 ? void 0 : onPostPause();
          return this;
        },
        unpause: function unpause(unpauseOptions) {
          if (!state.paused || !state.active) {
            return this;
          }
          var onUnpause = getOption(unpauseOptions, "onUnpause");
          var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
          state.paused = false;
          onUnpause === null || onUnpause === void 0 ? void 0 : onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 ? void 0 : onPostUnpause();
          return this;
        },
        updateContainerElements: function updateContainerElements(containerElements) {
          var elementsAsArray = [].concat(containerElements).filter(Boolean);
          state.containers = elementsAsArray.map(function(element) {
            return typeof element === "string" ? doc3.querySelector(element) : element;
          });
          if (state.active) {
            updateTabbableNodes();
          }
          updateObservedNodes();
          return this;
        }
      };
      trap.updateContainerElements(elements);
      return trap;
    };
    defaultConfig = {
      floating: {},
      focusTrap: {},
      clickOutside: {},
      escapeKeydown: {},
      portal: "body"
    };
    usePopper = (popperElement, args) => {
      popperElement.dataset.escapee = "";
      const { anchorElement, open, options: options2 } = args;
      if (!anchorElement || !open || !options2) {
        return { destroy: noop2 };
      }
      const opts = { ...defaultConfig, ...options2 };
      const callbacks = [];
      if (opts.portal !== null) {
        const portal = usePortal(popperElement, opts.portal);
        if (portal?.destroy) {
          callbacks.push(portal.destroy);
        }
      }
      callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);
      if (opts.focusTrap !== null) {
        const { useFocusTrap } = createFocusTrap2({
          immediate: true,
          escapeDeactivates: false,
          allowOutsideClick: true,
          returnFocusOnDeactivate: false,
          fallbackFocus: popperElement,
          ...opts.focusTrap
        });
        const usedFocusTrap = useFocusTrap(popperElement);
        if (usedFocusTrap?.destroy) {
          callbacks.push(usedFocusTrap.destroy);
        }
      }
      if (opts.clickOutside !== null) {
        callbacks.push(useClickOutside(popperElement, {
          enabled: open,
          handler: (e) => {
            if (e.defaultPrevented)
              return;
            if (isHTMLElement$1(anchorElement) && !anchorElement.contains(e.target)) {
              open.set(false);
              anchorElement.focus();
            }
          },
          ...opts.clickOutside
        }).destroy);
      }
      if (opts.escapeKeydown !== null) {
        callbacks.push(useEscapeKeydown(popperElement, {
          enabled: open,
          handler: (e) => {
            if (e.defaultPrevented)
              return;
            open.set(false);
          },
          ...opts.escapeKeydown
        }).destroy);
      }
      const unsubscribe = executeCallbacks(...callbacks);
      return {
        destroy() {
          unsubscribe();
        }
      };
    };
    usePortal = (el, target = "body") => {
      let targetEl;
      if (!isHTMLElement$1(target) && typeof target !== "string") {
        return {
          destroy: noop2
        };
      }
      async function update2(newTarget) {
        target = newTarget;
        if (typeof target === "string") {
          targetEl = document.querySelector(target);
          if (targetEl === null) {
            await tick();
            targetEl = document.querySelector(target);
          }
          if (targetEl === null) {
            throw new Error(`No element found matching css selector: "${target}"`);
          }
        } else if (target instanceof HTMLElement) {
          targetEl = target;
        } else {
          throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
        }
        el.dataset.portal = "";
        targetEl.appendChild(el);
        el.hidden = false;
      }
      function destroy() {
        el.remove();
      }
      update2(target);
      return {
        update: update2,
        destroy
      };
    };
    SUB_OPEN_KEYS = {
      ltr: [...SELECTION_KEYS, kbd.ARROW_RIGHT],
      rtl: [...SELECTION_KEYS, kbd.ARROW_LEFT]
    };
    SUB_CLOSE_KEYS = {
      ltr: [kbd.ARROW_LEFT],
      rtl: [kbd.ARROW_RIGHT]
    };
    defaults$5 = {
      arrowSize: 8,
      positioning: {
        placement: "bottom"
      },
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      portal: "body",
      loop: false,
      dir: "ltr",
      defaultOpen: false,
      typeahead: true
    };
    defaults$4 = {
      arrowSize: 8,
      positioning: {
        placement: "bottom-start"
      },
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      portal: void 0,
      loop: false,
      dir: "ltr",
      defaultOpen: false,
      forceVisible: false,
      typeahead: true
    };
    ({ name: name$2, selector } = createElHelpers("context-menu"));
    ({ name: name$1 } = createElHelpers("dialog"));
    defaults$3 = {
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      role: "dialog",
      defaultOpen: false,
      portal: "body",
      forceVisible: false
    };
    openDialogIds = writable([]);
    defaults$2 = {
      arrowSize: 8,
      positioning: {
        placement: "bottom"
      },
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      portal: void 0,
      loop: false,
      dir: "ltr",
      defaultOpen: false,
      forceVisible: false,
      typeahead: true
    };
    defaults$1 = {
      orientation: "horizontal",
      decorative: false
    };
    createSeparator = (props) => {
      const withDefaults = { ...defaults$1, ...props };
      const options2 = toWritableStores(withDefaults);
      const { orientation, decorative } = options2;
      const root = builder("separator", {
        stores: [orientation, decorative],
        returned: ([$orientation, $decorative]) => {
          const ariaOrientation = $orientation === "vertical" ? $orientation : void 0;
          return {
            role: $decorative ? "none" : "separator",
            "aria-orientation": ariaOrientation,
            "aria-hidden": $decorative,
            "data-orientation": $orientation
          };
        }
      });
      return {
        elements: {
          root
        },
        options: options2
      };
    };
    defaults = {
      positioning: {
        placement: "bottom"
      },
      arrowSize: 8,
      defaultOpen: false,
      closeOnPointerDown: true,
      openDelay: 1e3,
      closeDelay: 0,
      forceVisible: false,
      portal: "body",
      closeOnEscape: true
    };
    ({ name: name2 } = createElHelpers("tooltip"));
    isBrowser = typeof document !== "undefined";
    NAME$4 = "AlertDialog";
    ctx$5 = {
      set: set$4,
      get: get$4
    };
    AlertDialog = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $transitionTimes, $$unsubscribe_transitionTimes;
      let $tOpen, $$unsubscribe_tOpen;
      let { preventScroll = void 0 } = $$props;
      let { closeOnEscape = void 0 } = $$props;
      let { closeOnOutsideClick = false } = $$props;
      let { portal = void 0 } = $$props;
      let { forceVisible = true } = $$props;
      let { open = void 0 } = $$props;
      let { onOpenChange = void 0 } = $$props;
      const transitionTimes = writable({});
      $$unsubscribe_transitionTimes = subscribe(transitionTimes, (value) => $transitionTimes = value);
      const tOpen = writable(open);
      $$unsubscribe_tOpen = subscribe(tOpen, (value) => $tOpen = value);
      let timeout = 0;
      const { states: { open: localOpen }, updateOption } = ctx$5.set({
        closeOnEscape,
        preventScroll,
        closeOnOutsideClick,
        portal,
        forceVisible,
        defaultOpen: open,
        transitionTimes,
        tOpen,
        onOpenChange: ({ next }) => {
          if (open !== next) {
            onOpenChange?.(next);
          }
          if (next !== $tOpen) {
            tOpen.set(next);
            if (!next) {
              window.clearTimeout(timeout);
              timeout = window.setTimeout(
                () => {
                  localOpen.set(next);
                },
                $transitionTimes.out ? $transitionTimes.out * 0.6 : 0
              );
              open = !next;
              return !next;
            } else {
              open = next;
              return next;
            }
          }
          open = next;
          return next;
        }
      });
      onDestroy(() => {
        if (isBrowser) {
          window.clearTimeout(timeout);
        }
      });
      if ($$props.preventScroll === void 0 && $$bindings.preventScroll && preventScroll !== void 0)
        $$bindings.preventScroll(preventScroll);
      if ($$props.closeOnEscape === void 0 && $$bindings.closeOnEscape && closeOnEscape !== void 0)
        $$bindings.closeOnEscape(closeOnEscape);
      if ($$props.closeOnOutsideClick === void 0 && $$bindings.closeOnOutsideClick && closeOnOutsideClick !== void 0)
        $$bindings.closeOnOutsideClick(closeOnOutsideClick);
      if ($$props.portal === void 0 && $$bindings.portal && portal !== void 0)
        $$bindings.portal(portal);
      if ($$props.forceVisible === void 0 && $$bindings.forceVisible && forceVisible !== void 0)
        $$bindings.forceVisible(forceVisible);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.onOpenChange === void 0 && $$bindings.onOpenChange && onOpenChange !== void 0)
        $$bindings.onOpenChange(onOpenChange);
      open !== void 0 && localOpen.set(open);
      {
        updateOption("preventScroll", preventScroll);
      }
      {
        updateOption("closeOnEscape", closeOnEscape);
      }
      {
        updateOption("closeOnOutsideClick", closeOnOutsideClick);
      }
      {
        updateOption("portal", portal);
      }
      {
        updateOption("forceVisible", forceVisible);
      }
      $$unsubscribe_transitionTimes();
      $$unsubscribe_tOpen();
      return `${slots.default ? slots.default({}) : ``}`;
    });
    AlertDialogTitle = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["level", "asChild"]);
      let $title, $$unsubscribe_title;
      let { level = "h2" } = $$props;
      let { asChild = false } = $$props;
      const title = ctx$5.get().elements.title;
      $$unsubscribe_title = subscribe(title, (value) => $title = value);
      if ($$props.level === void 0 && $$bindings.level && level !== void 0)
        $$bindings.level(level);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_title();
      return `${asChild ? `${slots.default ? slots.default({ builder: $title }) : ``}` : (() => {
        let builder2 = $title;
        return ` ${((tag) => {
          return tag ? `<${level}${spread([escape_object(builder2), escape_object($$restProps)], {})}>${is_void(tag) ? "" : `${slots.default ? slots.default({ builder: builder2 }) : ``}`}${is_void(tag) ? "" : `</${tag}>`}` : "";
        })(level)}`;
      })()}`;
    });
    AlertDialogAction = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $close, $$unsubscribe_close;
      let { asChild = false } = $$props;
      const { elements: { close: close2 } } = ctx$5.get();
      $$unsubscribe_close = subscribe(close2, (value) => $close = value);
      createDispatcher();
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_close();
      return `${asChild ? `${slots.default ? slots.default({ builder: $close }) : ``}` : (() => {
        let builder2 = $close;
        return ` <button${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</button>`;
      })()}`;
    });
    AlertDialogCancel = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $close, $$unsubscribe_close;
      let { asChild = false } = $$props;
      const { elements: { close: close2 } } = ctx$5.get();
      $$unsubscribe_close = subscribe(close2, (value) => $close = value);
      createDispatcher();
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_close();
      return `${asChild ? `${slots.default ? slots.default({ builder: $close }) : ``}` : (() => {
        let builder2 = $close;
        return ` <button${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</button>`;
      })()}`;
    });
    AlertDialogPortal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $portalled, $$unsubscribe_portalled;
      let { asChild = false } = $$props;
      const { elements: { portalled }, states: { open } } = ctx$5.get();
      $$unsubscribe_portalled = subscribe(portalled, (value) => $portalled = value);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_portalled();
      return `${asChild ? (() => {
        let builder2 = $portalled;
        return ` ${slots.default ? slots.default({ builder: builder2 }) : ``}`;
      })() : (() => {
        let builder2 = $portalled;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })()}`;
    });
    AlertDialogContent = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild"
      ]);
      let $tOpen, $$unsubscribe_tOpen;
      let $content, $$unsubscribe_content;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      const { elements: { content }, transitionTimes, tOpen } = ctx$5.get();
      $$unsubscribe_content = subscribe(content, (value) => $content = value);
      $$unsubscribe_tOpen = subscribe(tOpen, (value) => $tOpen = value);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      {
        setTransitionTimes(transitionTimes, {
          transition,
          transitionConfig,
          inTransition,
          inTransitionConfig,
          outTransition,
          outTransitionConfig
        });
      }
      $$unsubscribe_tOpen();
      $$unsubscribe_content();
      return `${asChild && $tOpen ? (() => {
        let builder2 = $content;
        return ` ${slots.default ? slots.default({ builder: builder2 }) : ``}`;
      })() : `${transition && $tOpen ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${inTransition && outTransition && $tOpen ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${inTransition && $tOpen ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${outTransition && $tOpen ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${$tOpen ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : ``}`}`}`}`}`}`;
    });
    AlertDialogOverlay = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild"
      ]);
      let $tOpen, $$unsubscribe_tOpen;
      let $overlay, $$unsubscribe_overlay;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      const { elements: { overlay }, tOpen } = ctx$5.get();
      $$unsubscribe_overlay = subscribe(overlay, (value) => $overlay = value);
      $$unsubscribe_tOpen = subscribe(tOpen, (value) => $tOpen = value);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_tOpen();
      $$unsubscribe_overlay();
      return `${asChild && $tOpen ? (() => {
        let builder2 = $overlay;
        return ` ${slots.default ? slots.default({ builder: builder2 }) : ``}`;
      })() : `${transition && $tOpen ? (() => {
        let builder2 = $overlay;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}></div>`;
      })() : `${inTransition && outTransition && $tOpen ? (() => {
        let builder2 = $overlay;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}></div>`;
      })() : `${inTransition && $tOpen ? (() => {
        let builder2 = $overlay;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}></div>`;
      })() : `${outTransition && $tOpen ? (() => {
        let builder2 = $overlay;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}></div>`;
      })() : `${$tOpen ? (() => {
        let builder2 = $overlay;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}></div>`;
      })() : ``}`}`}`}`}`}`;
    });
    AlertDialogDescription = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $description, $$unsubscribe_description;
      let { asChild = false } = $$props;
      const { elements: { description } } = ctx$5.get();
      $$unsubscribe_description = subscribe(description, (value) => $description = value);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_description();
      return `${asChild ? `${slots.default ? slots.default({ builder: $description }) : ``}` : (() => {
        let builder2 = $description;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })()}`;
    });
    Button$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["href", "type", "builders"]);
      let { href = void 0 } = $$props;
      let { type = void 0 } = $$props;
      let { builders = [] } = $$props;
      if ($$props.href === void 0 && $$bindings.href && href !== void 0)
        $$bindings.href(href);
      if ($$props.type === void 0 && $$bindings.type && type !== void 0)
        $$bindings.type(type);
      if ($$props.builders === void 0 && $$bindings.builders && builders !== void 0)
        $$bindings.builders(builders);
      return `${builders && builders.length ? ` ${((tag) => {
        return tag ? `<${href ? "a" : "button"}${spread(
          [
            {
              type: escape_attribute_value(href ? void 0 : type)
            },
            { href: escape_attribute_value(href) },
            { tabindex: "0" },
            escape_object(getAttrs(builders)),
            escape_object($$restProps)
          ],
          {}
        )}>${is_void(tag) ? "" : `${slots.default ? slots.default({}) : ``}`}${is_void(tag) ? "" : `</${tag}>`}` : "";
      })(href ? "a" : "button")}` : ` ${((tag) => {
        return tag ? `<${href ? "a" : "button"}${spread(
          [
            {
              type: escape_attribute_value(href ? void 0 : type)
            },
            { href: escape_attribute_value(href) },
            { tabindex: "0" },
            escape_object($$restProps)
          ],
          {}
        )}>${is_void(tag) ? "" : `${slots.default ? slots.default({}) : ``}`}${is_void(tag) ? "" : `</${tag}>`}` : "";
      })(href ? "a" : "button")}`}`;
    });
    NAME$3 = "ContextMenu";
    SUB_NAME$1 = "ContextSubmenu";
    RADIO_GROUP_NAME$1 = "ContextRadioGroup";
    CHECKBOX_ITEM_NAME$1 = "ContextCheckboxItem";
    RADIO_ITEM_NAME$1 = "ContextRadioItem";
    GROUP_NAME$1 = "ContextGroup";
    ctx$4 = {
      get: get$3,
      set: set$3,
      setSub: setSub$1,
      getSub,
      getContent: getContent$1,
      setRadioGroup: setRadioGroup$1,
      setRadioItem: setRadioItem$1,
      getSubTrigger: getSubTrigger$1,
      getSubContent: getSubContent$1,
      setCheckboxItem: setCheckboxItem$1,
      getCheckboxIndicator: getCheckboxIndicator$1,
      getRadioIndicator: getRadioIndicator$1,
      setGroup: setGroup$1,
      getGroupLabel: getGroupLabel$1,
      setArrow: setArrow$2
    };
    ContextMenu = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { closeOnOutsideClick = void 0 } = $$props;
      let { closeOnEscape = void 0 } = $$props;
      let { portal = void 0 } = $$props;
      let { forceVisible = true } = $$props;
      let { open = void 0 } = $$props;
      let { onOpenChange = void 0 } = $$props;
      let { preventScroll = void 0 } = $$props;
      let { arrowSize = void 0 } = $$props;
      let { positioning = void 0 } = $$props;
      let { loop = void 0 } = $$props;
      let { dir = void 0 } = $$props;
      const { states: { open: localOpen }, updateOption } = ctx$4.set({
        closeOnOutsideClick,
        closeOnEscape,
        portal,
        forceVisible,
        defaultOpen: open,
        preventScroll,
        arrowSize,
        positioning,
        loop,
        dir,
        onOpenChange: ({ next }) => {
          if (open !== next) {
            onOpenChange?.(next);
            open = next;
          }
          return next;
        }
      });
      if ($$props.closeOnOutsideClick === void 0 && $$bindings.closeOnOutsideClick && closeOnOutsideClick !== void 0)
        $$bindings.closeOnOutsideClick(closeOnOutsideClick);
      if ($$props.closeOnEscape === void 0 && $$bindings.closeOnEscape && closeOnEscape !== void 0)
        $$bindings.closeOnEscape(closeOnEscape);
      if ($$props.portal === void 0 && $$bindings.portal && portal !== void 0)
        $$bindings.portal(portal);
      if ($$props.forceVisible === void 0 && $$bindings.forceVisible && forceVisible !== void 0)
        $$bindings.forceVisible(forceVisible);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.onOpenChange === void 0 && $$bindings.onOpenChange && onOpenChange !== void 0)
        $$bindings.onOpenChange(onOpenChange);
      if ($$props.preventScroll === void 0 && $$bindings.preventScroll && preventScroll !== void 0)
        $$bindings.preventScroll(preventScroll);
      if ($$props.arrowSize === void 0 && $$bindings.arrowSize && arrowSize !== void 0)
        $$bindings.arrowSize(arrowSize);
      if ($$props.positioning === void 0 && $$bindings.positioning && positioning !== void 0)
        $$bindings.positioning(positioning);
      if ($$props.loop === void 0 && $$bindings.loop && loop !== void 0)
        $$bindings.loop(loop);
      if ($$props.dir === void 0 && $$bindings.dir && dir !== void 0)
        $$bindings.dir(dir);
      open !== void 0 && localOpen.set(open);
      {
        updateOption("closeOnOutsideClick", closeOnOutsideClick);
      }
      {
        updateOption("closeOnEscape", closeOnEscape);
      }
      {
        updateOption("portal", portal);
      }
      {
        updateOption("forceVisible", forceVisible);
      }
      {
        updateOption("preventScroll", preventScroll);
      }
      {
        updateOption("arrowSize", arrowSize);
      }
      {
        updateOption("positioning", positioning);
      }
      {
        updateOption("loop", loop);
      }
      {
        updateOption("dir", dir);
      }
      return `${slots.default ? slots.default({}) : ``}`;
    });
    ContextMenuItem = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild", "disabled"]);
      let $item, $$unsubscribe_item;
      let { asChild = false } = $$props;
      let { disabled = false } = $$props;
      const { elements: { item } } = ctx$4.get();
      $$unsubscribe_item = subscribe(item, (value) => $item = value);
      createDispatcher();
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      $$unsubscribe_item();
      return ` ${asChild ? `${slots.default ? slots.default({ builder: $item }) : ``}` : (() => {
        let builder2 = $item;
        return ` <div${spread(
          [
            escape_object(builder2),
            escape_object($$restProps),
            escape_object(disabledAttrs(disabled))
          ],
          {}
        )}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })()}`;
    });
    ContextMenuContent = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "sideOffset",
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild"
      ]);
      let $open, $$unsubscribe_open;
      let $menu, $$unsubscribe_menu;
      let { sideOffset = 5 } = $$props;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      const { elements: { menu }, states: { open } } = ctx$4.getContent(sideOffset);
      $$unsubscribe_menu = subscribe(menu, (value) => $menu = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      createDispatcher();
      if ($$props.sideOffset === void 0 && $$bindings.sideOffset && sideOffset !== void 0)
        $$bindings.sideOffset(sideOffset);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_open();
      $$unsubscribe_menu();
      return `${asChild && $open ? (() => {
        let builder2 = $menu;
        return ` ${slots.default ? slots.default({ builder: builder2 }) : ``}`;
      })() : `${transition && $open ? (() => {
        let builder2 = $menu;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${inTransition && outTransition && $open ? (() => {
        let builder2 = $menu;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${inTransition && $open ? (() => {
        let builder2 = $menu;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${outTransition && $open ? (() => {
        let builder2 = $menu;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${$open ? (() => {
        let builder2 = $menu;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : ``}`}`}`}`}`}`;
    });
    ContextMenuTrigger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $trigger, $$unsubscribe_trigger;
      let { asChild = false } = $$props;
      const { elements: { trigger } } = ctx$4.get();
      $$unsubscribe_trigger = subscribe(trigger, (value) => $trigger = value);
      createDispatcher();
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_trigger();
      return ` ${asChild ? `${slots.default ? slots.default({ builder: $trigger }) : ``}` : (() => {
        let builder2 = $trigger;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })()}`;
    });
    ContextMenuSeparator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $separator, $$unsubscribe_separator;
      let { asChild = false } = $$props;
      const separator = ctx$4.get().elements.separator;
      $$unsubscribe_separator = subscribe(separator, (value) => $separator = value);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_separator();
      return `${asChild ? `${slots.default ? slots.default({ builder: $separator }) : ``}` : `<div${spread([escape_object($separator), escape_object($$restProps)], {})}></div>`}`;
    });
    NAME$2 = "Dialog";
    ctx$3 = {
      set: set$2,
      get: get$2
    };
    Dialog = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $transitionTimes, $$unsubscribe_transitionTimes;
      let $tOpen, $$unsubscribe_tOpen;
      let { preventScroll = void 0 } = $$props;
      let { closeOnEscape = void 0 } = $$props;
      let { closeOnOutsideClick = void 0 } = $$props;
      let { portal = void 0 } = $$props;
      let { forceVisible = true } = $$props;
      let { open = void 0 } = $$props;
      let { onOpenChange = void 0 } = $$props;
      const transitionTimes = writable({});
      $$unsubscribe_transitionTimes = subscribe(transitionTimes, (value) => $transitionTimes = value);
      const tOpen = writable(open);
      $$unsubscribe_tOpen = subscribe(tOpen, (value) => $tOpen = value);
      let timeout = 0;
      const { states: { open: localOpen }, updateOption } = ctx$3.set({
        closeOnEscape,
        preventScroll,
        closeOnOutsideClick,
        portal,
        forceVisible,
        defaultOpen: open,
        transitionTimes,
        tOpen,
        onOpenChange: ({ next }) => {
          if (!isBrowser) {
            return next;
          }
          window.clearTimeout(timeout);
          if (open !== next) {
            onOpenChange?.(next);
          }
          if (next !== $tOpen) {
            tOpen.set(next);
            if (!next) {
              timeout = window.setTimeout(
                () => {
                  localOpen.set(next);
                },
                $transitionTimes.out ? $transitionTimes.out * 0.6 : 0
              );
              open = !next;
              return !next;
            } else {
              open = next;
              return next;
            }
          }
          open = next;
          return next;
        }
      });
      onDestroy(() => {
        if (isBrowser) {
          window.clearTimeout(timeout);
        }
      });
      if ($$props.preventScroll === void 0 && $$bindings.preventScroll && preventScroll !== void 0)
        $$bindings.preventScroll(preventScroll);
      if ($$props.closeOnEscape === void 0 && $$bindings.closeOnEscape && closeOnEscape !== void 0)
        $$bindings.closeOnEscape(closeOnEscape);
      if ($$props.closeOnOutsideClick === void 0 && $$bindings.closeOnOutsideClick && closeOnOutsideClick !== void 0)
        $$bindings.closeOnOutsideClick(closeOnOutsideClick);
      if ($$props.portal === void 0 && $$bindings.portal && portal !== void 0)
        $$bindings.portal(portal);
      if ($$props.forceVisible === void 0 && $$bindings.forceVisible && forceVisible !== void 0)
        $$bindings.forceVisible(forceVisible);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.onOpenChange === void 0 && $$bindings.onOpenChange && onOpenChange !== void 0)
        $$bindings.onOpenChange(onOpenChange);
      open !== void 0 && localOpen.set(open);
      {
        updateOption("preventScroll", preventScroll);
      }
      {
        updateOption("closeOnEscape", closeOnEscape);
      }
      {
        updateOption("closeOnOutsideClick", closeOnOutsideClick);
      }
      {
        updateOption("portal", portal);
      }
      {
        updateOption("forceVisible", forceVisible);
      }
      $$unsubscribe_transitionTimes();
      $$unsubscribe_tOpen();
      return `${slots.default ? slots.default({}) : ``}`;
    });
    DialogTitle = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["level", "asChild"]);
      let $title, $$unsubscribe_title;
      let { level = "h2" } = $$props;
      let { asChild = false } = $$props;
      const title = ctx$3.get().elements.title;
      $$unsubscribe_title = subscribe(title, (value) => $title = value);
      if ($$props.level === void 0 && $$bindings.level && level !== void 0)
        $$bindings.level(level);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_title();
      return `${asChild ? `${slots.default ? slots.default({ builder: $title }) : ``}` : (() => {
        let builder2 = $title;
        return ` ${((tag) => {
          return tag ? `<${level}${spread([escape_object(builder2), escape_object($$restProps)], {})}>${is_void(tag) ? "" : `${slots.default ? slots.default({ builder: builder2 }) : ``}`}${is_void(tag) ? "" : `</${tag}>`}` : "";
        })(level)}`;
      })()}`;
    });
    DialogPortal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $portalled, $$unsubscribe_portalled;
      let { asChild = false } = $$props;
      const { elements: { portalled }, states: { open } } = ctx$3.get();
      $$unsubscribe_portalled = subscribe(portalled, (value) => $portalled = value);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_portalled();
      return `${asChild ? (() => {
        let builder2 = $portalled;
        return ` ${slots.default ? slots.default({ builder: builder2 }) : ``}`;
      })() : (() => {
        let builder2 = $portalled;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })()}`;
    });
    DialogContent = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild"
      ]);
      let $tOpen, $$unsubscribe_tOpen;
      let $content, $$unsubscribe_content;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      const { elements: { content }, transitionTimes, tOpen } = ctx$3.get();
      $$unsubscribe_content = subscribe(content, (value) => $content = value);
      $$unsubscribe_tOpen = subscribe(tOpen, (value) => $tOpen = value);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      {
        setTransitionTimes(transitionTimes, {
          transition,
          transitionConfig,
          inTransition,
          inTransitionConfig,
          outTransition,
          outTransitionConfig
        });
      }
      $$unsubscribe_tOpen();
      $$unsubscribe_content();
      return `${asChild && $tOpen ? (() => {
        let builder2 = $content;
        return ` ${slots.default ? slots.default({ builder: builder2 }) : ``}`;
      })() : `${transition && $tOpen ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${inTransition && outTransition && $tOpen ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${inTransition && $tOpen ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${outTransition && $tOpen ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${$tOpen ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : ``}`}`}`}`}`}`;
    });
    DialogOverlay = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild"
      ]);
      let $tOpen, $$unsubscribe_tOpen;
      let $overlay, $$unsubscribe_overlay;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      const { elements: { overlay }, tOpen } = ctx$3.get();
      $$unsubscribe_overlay = subscribe(overlay, (value) => $overlay = value);
      $$unsubscribe_tOpen = subscribe(tOpen, (value) => $tOpen = value);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_tOpen();
      $$unsubscribe_overlay();
      return `${asChild && $tOpen ? (() => {
        let builder2 = $overlay;
        return ` ${slots.default ? slots.default({ builder: builder2 }) : ``}`;
      })() : `${transition && $tOpen ? (() => {
        let builder2 = $overlay;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}></div>`;
      })() : `${inTransition && outTransition && $tOpen ? (() => {
        let builder2 = $overlay;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}></div>`;
      })() : `${inTransition && $tOpen ? (() => {
        let builder2 = $overlay;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}></div>`;
      })() : `${outTransition && $tOpen ? (() => {
        let builder2 = $overlay;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}></div>`;
      })() : `${$tOpen ? (() => {
        let builder2 = $overlay;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}></div>`;
      })() : ``}`}`}`}`}`}`;
    });
    NAME$1 = "DropdownMenu";
    SUB_NAME = "DropdownSubmenu";
    RADIO_GROUP_NAME = "DropdownRadioGroup";
    CHECKBOX_ITEM_NAME = "DropdownCheckboxItem";
    RADIO_ITEM_NAME = "DropdownRadioItem";
    GROUP_NAME = "DropdownGroup";
    ctx$2 = {
      get: get$1,
      set: set$1,
      setSub,
      getContent,
      setRadioGroup,
      setRadioItem,
      getSubTrigger,
      getSubContent,
      setCheckboxItem,
      getCheckboxIndicator,
      getRadioIndicator,
      setGroup,
      getGroupLabel,
      setArrow: setArrow$1
    };
    DropdownMenu = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { closeOnOutsideClick = void 0 } = $$props;
      let { closeOnEscape = void 0 } = $$props;
      let { portal = void 0 } = $$props;
      let { forceVisible = void 0 } = $$props;
      let { open = void 0 } = $$props;
      let { onOpenChange = void 0 } = $$props;
      let { preventScroll = void 0 } = $$props;
      let { arrowSize = void 0 } = $$props;
      let { positioning = void 0 } = $$props;
      let { loop = void 0 } = $$props;
      let { dir = void 0 } = $$props;
      const { states: { open: localOpen }, updateOption } = ctx$2.set({
        closeOnOutsideClick,
        closeOnEscape,
        portal,
        forceVisible,
        defaultOpen: open,
        preventScroll,
        arrowSize,
        positioning,
        loop,
        dir,
        onOpenChange: ({ next }) => {
          if (open !== next) {
            onOpenChange?.(next);
            open = next;
          }
          return next;
        }
      });
      if ($$props.closeOnOutsideClick === void 0 && $$bindings.closeOnOutsideClick && closeOnOutsideClick !== void 0)
        $$bindings.closeOnOutsideClick(closeOnOutsideClick);
      if ($$props.closeOnEscape === void 0 && $$bindings.closeOnEscape && closeOnEscape !== void 0)
        $$bindings.closeOnEscape(closeOnEscape);
      if ($$props.portal === void 0 && $$bindings.portal && portal !== void 0)
        $$bindings.portal(portal);
      if ($$props.forceVisible === void 0 && $$bindings.forceVisible && forceVisible !== void 0)
        $$bindings.forceVisible(forceVisible);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.onOpenChange === void 0 && $$bindings.onOpenChange && onOpenChange !== void 0)
        $$bindings.onOpenChange(onOpenChange);
      if ($$props.preventScroll === void 0 && $$bindings.preventScroll && preventScroll !== void 0)
        $$bindings.preventScroll(preventScroll);
      if ($$props.arrowSize === void 0 && $$bindings.arrowSize && arrowSize !== void 0)
        $$bindings.arrowSize(arrowSize);
      if ($$props.positioning === void 0 && $$bindings.positioning && positioning !== void 0)
        $$bindings.positioning(positioning);
      if ($$props.loop === void 0 && $$bindings.loop && loop !== void 0)
        $$bindings.loop(loop);
      if ($$props.dir === void 0 && $$bindings.dir && dir !== void 0)
        $$bindings.dir(dir);
      open !== void 0 && localOpen.set(open);
      {
        updateOption("closeOnOutsideClick", closeOnOutsideClick);
      }
      {
        updateOption("closeOnEscape", closeOnEscape);
      }
      {
        updateOption("portal", portal);
      }
      {
        updateOption("forceVisible", forceVisible);
      }
      {
        updateOption("preventScroll", preventScroll);
      }
      {
        updateOption("arrowSize", arrowSize);
      }
      {
        updateOption("positioning", positioning);
      }
      {
        updateOption("loop", loop);
      }
      {
        updateOption("dir", dir);
      }
      return `${slots.default ? slots.default({}) : ``}`;
    });
    DropdownMenuItem = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild", "disabled"]);
      let $item, $$unsubscribe_item;
      let { asChild = false } = $$props;
      let { disabled = false } = $$props;
      const { elements: { item } } = ctx$2.get();
      $$unsubscribe_item = subscribe(item, (value) => $item = value);
      createDispatcher();
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      $$unsubscribe_item();
      return ` ${asChild ? `${slots.default ? slots.default({ builder: $item }) : ``}` : (() => {
        let builder2 = $item;
        return ` <div${spread(
          [
            escape_object(builder2),
            escape_object($$restProps),
            escape_object(disabledAttrs(disabled))
          ],
          {}
        )}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })()}`;
    });
    DropdownMenuGroup = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $group, $$unsubscribe_group;
      let { asChild = false } = $$props;
      const { group, id } = ctx$2.setGroup();
      $$unsubscribe_group = subscribe(group, (value) => $group = value);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_group();
      return `${asChild ? `${slots.default ? slots.default({ builder: $group(id) }) : ``}` : (() => {
        let builder2 = $group(id);
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })()}`;
    });
    DropdownMenuContent = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "sideOffset",
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild"
      ]);
      let $open, $$unsubscribe_open;
      let $menu, $$unsubscribe_menu;
      let { sideOffset = 5 } = $$props;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      const { elements: { menu }, states: { open } } = ctx$2.getContent(sideOffset);
      $$unsubscribe_menu = subscribe(menu, (value) => $menu = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      createDispatcher();
      if ($$props.sideOffset === void 0 && $$bindings.sideOffset && sideOffset !== void 0)
        $$bindings.sideOffset(sideOffset);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_open();
      $$unsubscribe_menu();
      return ` ${asChild && $open ? (() => {
        let builder2 = $menu;
        return ` ${slots.default ? slots.default({ builder: builder2 }) : ``}`;
      })() : `${transition && $open ? (() => {
        let builder2 = $menu;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${inTransition && outTransition && $open ? (() => {
        let builder2 = $menu;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${inTransition && $open ? (() => {
        let builder2 = $menu;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${outTransition && $open ? (() => {
        let builder2 = $menu;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${$open ? (() => {
        let builder2 = $menu;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : ``}`}`}`}`}`}`;
    });
    DropdownMenuTrigger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $trigger, $$unsubscribe_trigger;
      let { asChild = false } = $$props;
      const { elements: { trigger } } = ctx$2.get();
      $$unsubscribe_trigger = subscribe(trigger, (value) => $trigger = value);
      createDispatcher();
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_trigger();
      return `${asChild ? `${slots.default ? slots.default({ builder: $trigger }) : ``}` : (() => {
        let builder2 = $trigger;
        return ` <button${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</button>`;
      })()}`;
    });
    DropdownMenuSeparator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $separator, $$unsubscribe_separator;
      let { asChild = false } = $$props;
      const separator = ctx$2.get().elements.separator;
      $$unsubscribe_separator = subscribe(separator, (value) => $separator = value);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_separator();
      return `${asChild ? `${slots.default ? slots.default({ builder: $separator }) : ``}` : `<div${spread([escape_object($separator), escape_object($$restProps)], {})}></div>`}`;
    });
    ctx$1 = {
      get: () => createLabel()
    };
    Label$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $root, $$unsubscribe_root;
      let { asChild = false } = $$props;
      const { elements: { root } } = ctx$1.get();
      $$unsubscribe_root = subscribe(root, (value) => $root = value);
      createDispatcher();
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_root();
      return ` ${asChild ? `${slots.default ? slots.default({ builder: $root }) : ``}` : (() => {
        let builder2 = $root;
        return ` <label${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</label>`;
      })()}`;
    });
    NAME = "Tooltip";
    ctx = {
      set,
      get: get2,
      setArrow
    };
    Tooltip = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { positioning = void 0 } = $$props;
      let { arrowSize = void 0 } = $$props;
      let { closeOnEscape = void 0 } = $$props;
      let { portal = void 0 } = $$props;
      let { closeOnPointerDown = void 0 } = $$props;
      let { openDelay = void 0 } = $$props;
      let { closeDelay = void 0 } = $$props;
      let { open = void 0 } = $$props;
      let { onOpenChange = void 0 } = $$props;
      let { forceVisible = true } = $$props;
      const { states: { open: localOpen }, updateOption } = ctx.set({
        positioning,
        arrowSize,
        closeOnEscape,
        portal,
        closeOnPointerDown,
        openDelay,
        closeDelay,
        forceVisible,
        defaultOpen: open,
        onOpenChange: ({ next }) => {
          if (open !== next) {
            onOpenChange?.(next);
            open = next;
          }
          return next;
        }
      });
      if ($$props.positioning === void 0 && $$bindings.positioning && positioning !== void 0)
        $$bindings.positioning(positioning);
      if ($$props.arrowSize === void 0 && $$bindings.arrowSize && arrowSize !== void 0)
        $$bindings.arrowSize(arrowSize);
      if ($$props.closeOnEscape === void 0 && $$bindings.closeOnEscape && closeOnEscape !== void 0)
        $$bindings.closeOnEscape(closeOnEscape);
      if ($$props.portal === void 0 && $$bindings.portal && portal !== void 0)
        $$bindings.portal(portal);
      if ($$props.closeOnPointerDown === void 0 && $$bindings.closeOnPointerDown && closeOnPointerDown !== void 0)
        $$bindings.closeOnPointerDown(closeOnPointerDown);
      if ($$props.openDelay === void 0 && $$bindings.openDelay && openDelay !== void 0)
        $$bindings.openDelay(openDelay);
      if ($$props.closeDelay === void 0 && $$bindings.closeDelay && closeDelay !== void 0)
        $$bindings.closeDelay(closeDelay);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.onOpenChange === void 0 && $$bindings.onOpenChange && onOpenChange !== void 0)
        $$bindings.onOpenChange(onOpenChange);
      if ($$props.forceVisible === void 0 && $$bindings.forceVisible && forceVisible !== void 0)
        $$bindings.forceVisible(forceVisible);
      open !== void 0 && localOpen.set(open);
      {
        updateOption("positioning", positioning);
      }
      {
        updateOption("arrowSize", arrowSize);
      }
      {
        updateOption("closeOnEscape", closeOnEscape);
      }
      {
        updateOption("portal", portal);
      }
      {
        updateOption("closeOnPointerDown", closeOnPointerDown);
      }
      {
        updateOption("openDelay", openDelay);
      }
      {
        updateOption("closeDelay", closeDelay);
      }
      {
        updateOption("forceVisible", forceVisible);
      }
      return `${slots.default ? slots.default({}) : ``}`;
    });
    TooltipContent = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild",
        "sideOffset"
      ]);
      let $open, $$unsubscribe_open;
      let $content, $$unsubscribe_content;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      let { sideOffset = 4 } = $$props;
      const { elements: { content }, states: { open } } = ctx.get(sideOffset);
      $$unsubscribe_content = subscribe(content, (value) => $content = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      createDispatcher();
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.sideOffset === void 0 && $$bindings.sideOffset && sideOffset !== void 0)
        $$bindings.sideOffset(sideOffset);
      $$unsubscribe_open();
      $$unsubscribe_content();
      return `${asChild && $open ? (() => {
        let builder2 = $content;
        return ` ${slots.default ? slots.default({ builder: builder2 }) : ``}`;
      })() : `${transition && $open ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${inTransition && outTransition && $open ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${inTransition && $open ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${outTransition && $open ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : `${$open ? (() => {
        let builder2 = $content;
        return ` <div${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</div>`;
      })() : ``}`}`}`}`}`}`;
    });
    TooltipTrigger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild"]);
      let $trigger, $$unsubscribe_trigger;
      let { asChild = false } = $$props;
      const trigger = ctx.get().elements.trigger;
      $$unsubscribe_trigger = subscribe(trigger, (value) => $trigger = value);
      createDispatcher();
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_trigger();
      return `${asChild ? `${slots.default ? slots.default({ builder: $trigger }) : ``}` : (() => {
        let builder2 = $trigger;
        return ` <button${spread([escape_object(builder2), escape_object($$restProps)], {})}>${slots.default ? slots.default({ builder: builder2 }) : ``}</button>`;
      })()}`;
    });
    flyAndScale = (node, params = { y: -8, x: 0, start: 0.95, duration: 150 }) => {
      const style = getComputedStyle(node);
      const transform = style.transform === "none" ? "" : style.transform;
      const scaleConversion = (valueA, scaleA, scaleB) => {
        const [minA, maxA] = scaleA;
        const [minB, maxB] = scaleB;
        const percentage = (valueA - minA) / (maxA - minA);
        const valueB = percentage * (maxB - minB) + minB;
        return valueB;
      };
      const styleToString2 = (style2) => {
        return Object.keys(style2).reduce((str, key3) => {
          if (style2[key3] === void 0)
            return str;
          return str + `${key3}:${style2[key3]};`;
        }, "");
      };
      return {
        duration: params.duration ?? 200,
        delay: 0,
        css: (t) => {
          const y2 = scaleConversion(t, [0, 1], [params.y ?? 5, 0]);
          const x2 = scaleConversion(t, [0, 1], [params.x ?? 0, 0]);
          const scale = scaleConversion(t, [0, 1], [params.start ?? 0.95, 1]);
          return styleToString2({
            transform: `${transform} translate3d(${x2}px, ${y2}px, 0) scale(${scale})`,
            opacity: t
          });
        },
        easing: cubicOut
      };
    };
    Alert_dialog_title = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "level"]);
      let { class: className = void 0 } = $$props;
      let { level = "h3" } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.level === void 0 && $$bindings.level && level !== void 0)
        $$bindings.level(level);
      return `${validate_component(AlertDialogTitle, "AlertDialogPrimitive.Title").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("text-lg font-semibold", className)
          },
          { level },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Button = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "variant", "size", "builders"]);
      let { class: className = void 0 } = $$props;
      let { variant = "default" } = $$props;
      let { size: size2 = "default" } = $$props;
      let { builders = [] } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
        $$bindings.variant(variant);
      if ($$props.size === void 0 && $$bindings.size && size2 !== void 0)
        $$bindings.size(size2);
      if ($$props.builders === void 0 && $$bindings.builders && builders !== void 0)
        $$bindings.builders(builders);
      return `${validate_component(Button$1, "ButtonPrimitive.Root").$$render(
        $$result,
        Object.assign(
          {},
          { builders },
          {
            class: cn(buttonVariants({ variant, size: size2, className }))
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    buttonVariants = ce({
      base: "inline-flex items-center justify-center rounded-md text-sm font-medium whitespace-nowrap transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
          destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
          outline: "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground",
          secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground",
          link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
          default: "h-9 px-4 py-2",
          sm: "h-8 rounded-md px-3 text-xs",
          lg: "h-10 rounded-md px-8",
          icon: "h-9 w-9",
          xs: "h-6 px-2 py-1 text-xs"
        }
      },
      defaultVariants: {
        variant: "default",
        size: "default"
      }
    });
    Alert_dialog_action = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(AlertDialogAction, "AlertDialogPrimitive.Action").$$render($$result, Object.assign({}, { class: cn(buttonVariants(), className) }, $$restProps), {}, {
        default: ({ builder: builder2 }) => {
          return `${slots.default ? slots.default({ builder: builder2 }) : ``}`;
        }
      })}`;
    });
    Alert_dialog_cancel = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(AlertDialogCancel, "AlertDialogPrimitive.Cancel").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn(buttonVariants({ variant: "outline" }), "mt-2 sm:mt-0", className)
          },
          $$restProps
        ),
        {},
        {
          default: ({ builder: builder2 }) => {
            return `${slots.default ? slots.default({ builder: builder2 }) : ``}`;
          }
        }
      )}`;
    });
    Alert_dialog_portal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `${validate_component(AlertDialogPortal, "AlertDialogPrimitive.Portal").$$render($$result, Object.assign({}, $$restProps), {}, {
        default: () => {
          return `${slots.default ? slots.default({}) : ``}`;
        }
      })}`;
    });
    Alert_dialog_footer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<div${spread(
        [
          {
            class: escape_attribute_value(cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</div>`;
    });
    Alert_dialog_header = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<div${spread(
        [
          {
            class: escape_attribute_value(cn("flex flex-col space-y-2 text-center sm:text-left", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</div>`;
    });
    Alert_dialog_overlay = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = fade } = $$props;
      let { transitionConfig = { duration: 150 } } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(AlertDialogOverlay, "AlertDialogPrimitive.Overlay").$$render(
        $$result,
        Object.assign(
          {},
          { transition },
          { transitionConfig },
          {
            class: cn("fixed inset-0 z-50 bg-background/80 backdrop-blur-sm", className)
          },
          $$restProps
        ),
        {},
        {}
      )}`;
    });
    Alert_dialog_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = flyAndScale } = $$props;
      let { transitionConfig = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(Alert_dialog_portal, "AlertDialog.Portal").$$render($$result, {}, {}, {
        default: () => {
          return `${validate_component(Alert_dialog_overlay, "AlertDialog.Overlay").$$render($$result, {}, {}, {})} ${validate_component(AlertDialogContent, "AlertDialogPrimitive.Content").$$render(
            $$result,
            Object.assign(
              {},
              { transition },
              { transitionConfig },
              {
                class: cn("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg  sm:rounded-lg md:w-full", className)
              },
              $$restProps
            ),
            {},
            {
              default: () => {
                return `${slots.default ? slots.default({}) : ``}`;
              }
            }
          )}`;
        }
      })}`;
    });
    Alert_dialog_description = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(AlertDialogDescription, "AlertDialogPrimitive.Description").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("text-sm text-muted-foreground", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Root$5 = AlertDialog;
    alertDialogDeleteItemId = writable(null);
    DeleteItemAlertDialog = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $alertDialogDeleteItemId, $$unsubscribe_alertDialogDeleteItemId;
      let $$unsubscribe_page;
      $$unsubscribe_alertDialogDeleteItemId = subscribe(alertDialogDeleteItemId, (value) => $alertDialogDeleteItemId = value);
      $$unsubscribe_page = subscribe(page, (value) => value);
      let open = false;
      let loading = false;
      alertDialogDeleteItemId.subscribe((value) => {
        open = !!value;
      });
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(Root$5, "AlertDialog.Root").$$render(
          $$result,
          { open },
          {
            open: ($$value) => {
              open = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `${validate_component(Alert_dialog_content, "AlertDialog.Content").$$render($$result, {}, {}, {
                default: () => {
                  return `${validate_component(Alert_dialog_header, "AlertDialog.Header").$$render($$result, {}, {}, {
                    default: () => {
                      return `${validate_component(Alert_dialog_title, "AlertDialog.Title").$$render($$result, {}, {}, {
                        default: () => {
                          return `Are you absolutely sure?`;
                        }
                      })} ${validate_component(Alert_dialog_description, "AlertDialog.Description").$$render($$result, {}, {}, {
                        default: () => {
                          return `This action cannot be undone. This will permanently delete the item and all the nested
				items.`;
                        }
                      })}`;
                    }
                  })} ${validate_component(Alert_dialog_footer, "AlertDialog.Footer").$$render($$result, {}, {}, {
                    default: () => {
                      return `${validate_component(Alert_dialog_cancel, "AlertDialog.Cancel").$$render($$result, {}, {}, {
                        default: () => {
                          return `Cancel`;
                        }
                      })} <form method="POST" action="/?/delete-item"><input type="hidden"${add_attribute("value", $alertDialogDeleteItemId, 0)} name="itemId"> ${validate_component(Alert_dialog_action, "AlertDialog.Action").$$render($$result, { type: "submit", disabled: loading }, {}, {
                        default: () => {
                          return `Continue`;
                        }
                      })}</form>`;
                    }
                  })}`;
                }
              })}`;
            }
          }
        )}`;
      } while (!$$settled);
      $$unsubscribe_alertDialogDeleteItemId();
      $$unsubscribe_page();
      return $$rendered;
    });
    Dialog_title = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(DialogTitle, "DialogPrimitive.Title").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("text-lg font-semibold leading-none tracking-tight", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Dialog_portal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `${validate_component(DialogPortal, "DialogPrimitive.Portal").$$render($$result, Object.assign({}, $$restProps), {}, {
        default: () => {
          return `${slots.default ? slots.default({}) : ``}`;
        }
      })}`;
    });
    Dialog_footer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<div${spread(
        [
          {
            class: escape_attribute_value(cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</div>`;
    });
    Dialog_header = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<div${spread(
        [
          {
            class: escape_attribute_value(cn("flex flex-col space-y-1.5 text-center sm:text-left", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</div>`;
    });
    Dialog_overlay = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = fade } = $$props;
      let { transitionConfig = { duration: 150 } } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(DialogOverlay, "DialogPrimitive.Overlay").$$render(
        $$result,
        Object.assign(
          {},
          { transition },
          { transitionConfig },
          {
            class: cn("fixed inset-0 z-50 bg-background/80 backdrop-blur-sm ", className)
          },
          $$restProps
        ),
        {},
        {}
      )}`;
    });
    Dialog_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = flyAndScale } = $$props;
      let { transitionConfig = { duration: 200 } } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(Dialog_portal, "Dialog.Portal").$$render($$result, {}, {}, {
        default: () => {
          return `${validate_component(Dialog_overlay, "Dialog.Overlay").$$render($$result, {}, {}, {})} ${validate_component(DialogContent, "DialogPrimitive.Content").$$render(
            $$result,
            Object.assign(
              {},
              { transition },
              { transitionConfig },
              {
                class: cn("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg sm:rounded-lg md:w-full", className)
              },
              $$restProps
            ),
            {},
            {
              default: () => {
                return `${slots.default ? slots.default({}) : ``}`;
              }
            }
          )}`;
        }
      })}`;
    });
    Root$4 = Dialog;
    Input = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "value"]);
      let { class: className = void 0 } = $$props;
      let { value = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      return `<input${spread(
        [
          {
            class: escape_attribute_value(cn("flex h-9 w-full rounded-md border border-input bg-background px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}${add_attribute("value", value, 0)}>`;
    });
    Label = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(Label$1, "LabelPrimitive.Root").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    dialogRenameItem = writable(null);
    RenameItemDialog = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$unsubscribe_dialogRenameItem;
      $$unsubscribe_dialogRenameItem = subscribe(dialogRenameItem, (value) => value);
      let open = false;
      let name22;
      dialogRenameItem.subscribe((value) => {
        open = !!value;
        name22 = value?.name ?? "";
      });
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(Root$4, "Dialog.Root").$$render(
          $$result,
          { open },
          {
            open: ($$value) => {
              open = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `${validate_component(Dialog_content, "Dialog.Content").$$render($$result, { class: "sm:max-w-[425px]" }, {}, {
                default: () => {
                  return `${validate_component(Dialog_header, "Dialog.Header").$$render($$result, {}, {}, {
                    default: () => {
                      return `${validate_component(Dialog_title, "Dialog.Title").$$render($$result, {}, {}, {
                        default: () => {
                          return `Rename Item`;
                        }
                      })}`;
                    }
                  })} <div class="grid gap-4 py-4"><div class="grid grid-cols-4 items-center gap-4">${validate_component(Label, "Label").$$render($$result, { class: "text-right" }, {}, {
                    default: () => {
                      return `Name`;
                    }
                  })} ${validate_component(Input, "Input").$$render(
                    $$result,
                    {
                      id: "name",
                      class: "col-span-3",
                      value: name22
                    },
                    {
                      value: ($$value) => {
                        name22 = $$value;
                        $$settled = false;
                      }
                    },
                    {}
                  )}</div></div> ${validate_component(Dialog_footer, "Dialog.Footer").$$render($$result, {}, {}, {
                    default: () => {
                      return `${validate_component(Button, "Button").$$render($$result, {}, {}, {
                        default: () => {
                          return `Save changes`;
                        }
                      })}`;
                    }
                  })}`;
                }
              })}`;
            }
          }
        )}`;
      } while (!$$settled);
      $$unsubscribe_dialogRenameItem();
      return $$rendered;
    });
    searchDialogOpen = writable(false);
    SearchCommand = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let filteredItems;
      let $searchDialogOpen, $$unsubscribe_searchDialogOpen;
      $$unsubscribe_searchDialogOpen = subscribe(searchDialogOpen, (value) => $searchDialogOpen = value);
      let { items = [] } = $$props;
      let query = "";
      if ($$props.items === void 0 && $$bindings.items && items !== void 0)
        $$bindings.items(items);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        filteredItems = items.filter((item) => {
          if (item.type === "folder")
            return false;
          return true;
        });
        $$rendered = `${validate_component(Root$4, "Dialog.Root").$$render(
          $$result,
          { open: $searchDialogOpen },
          {
            open: ($$value) => {
              $searchDialogOpen = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `${validate_component(Dialog_content, "Dialog.Content").$$render(
                $$result,
                {
                  class: "md:w-[56vw] w-[80vw] p-0 rounded-md"
                },
                {},
                {
                  default: () => {
                    return `<input type="text" class="bg-transparent outline-none px-4 text-lg py-2.5 w-full border-b border-b-accent" placeholder="Search through your notes..."${add_attribute("value", query, 0)}> <div class="md:h-[250px] h-[50vh] w-full px-4 overflow-y-scroll pb-1">${filteredItems.length === 0 ? `<div class="flex items-center justify-center w-full h-full" data-svelte-h="svelte-1kmyor1"><p class="text-center text-popover-foreground">No results found.</p></div>` : `${each(filteredItems, (item) => {
                      return `<a href="${"/" + escape(item.id, true)}"><div class="px-2 py-1.5 hover:bg-accent hover:bg-opacity-10 rounded-md"><span class="block text-popover-foreground">${escape(item.name)}</span></div> </a>`;
                    })}`}</div>`;
                  }
                }
              )}`;
            }
          }
        )}`;
      } while (!$$settled);
      $$unsubscribe_searchDialogOpen();
      return $$rendered;
    });
    Sheet_portal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(DialogPortal, "SheetPrimitive.Portal").$$render($$result, Object.assign({}, { class: cn(className) }, $$restProps), {}, {
        default: () => {
          return `${slots.default ? slots.default({}) : ``}`;
        }
      })}`;
    });
    Sheet_overlay = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = fade } = $$props;
      let { transitionConfig = { duration: 150 } } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(DialogOverlay, "SheetPrimitive.Overlay").$$render(
        $$result,
        Object.assign(
          {},
          { transition },
          { transitionConfig },
          {
            class: cn("fixed inset-0 z-50 bg-background/80 backdrop-blur-sm", className)
          },
          $$restProps
        ),
        {},
        {}
      )}`;
    });
    Sheet_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "class",
        "side",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig"
      ]);
      let { class: className = void 0 } = $$props;
      let { side = "right" } = $$props;
      let { inTransition = fly } = $$props;
      let { inTransitionConfig = sheetTransitions[side ? side : "right"]["in"] } = $$props;
      let { outTransition = fly } = $$props;
      let { outTransitionConfig = sheetTransitions[side ? side : "right"]["out"] } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.side === void 0 && $$bindings.side && side !== void 0)
        $$bindings.side(side);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      return `${validate_component(Sheet_portal, "SheetPortal").$$render($$result, {}, {}, {
        default: () => {
          return `${validate_component(Sheet_overlay, "SheetOverlay").$$render($$result, {}, {}, {})} ${validate_component(DialogContent, "SheetPrimitive.Content").$$render(
            $$result,
            Object.assign(
              {},
              { inTransition },
              { inTransitionConfig },
              { outTransition },
              { outTransitionConfig },
              {
                class: cn(sheetVariants({ side }), className)
              },
              $$restProps
            ),
            {},
            {
              default: () => {
                return `${slots.default ? slots.default({}) : ``} `;
              }
            }
          )}`;
        }
      })}`;
    });
    Root$3 = Dialog;
    sheetVariants = ce({
      base: "fixed z-50 gap-4 bg-background p-6 shadow-lg",
      variants: {
        side: {
          top: "inset-x-0 top-0 border-b ",
          bottom: "inset-x-0 bottom-0 border-t",
          left: "inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          right: "inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm"
        }
      },
      defaultVariants: {
        side: "right"
      }
    });
    sheetTransitions = {
      top: {
        in: {
          y: "-100%",
          duration: 500,
          opacity: 1
        },
        out: {
          y: "-100%",
          duration: 300,
          opacity: 1
        }
      },
      bottom: {
        in: {
          y: "100%",
          duration: 500,
          opacity: 1
        },
        out: {
          y: "100%",
          duration: 300,
          opacity: 1
        }
      },
      left: {
        in: {
          x: "-100%",
          duration: 500,
          opacity: 1
        },
        out: {
          x: "-100%",
          duration: 300,
          opacity: 1
        }
      },
      right: {
        in: {
          x: "100%",
          duration: 500,
          opacity: 1
        },
        out: {
          x: "100%",
          duration: 300,
          opacity: 1
        }
      }
    };
    sortOrder = writable("name_asc");
    Tooltip_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "sideOffset", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { sideOffset = 4 } = $$props;
      let { transition = flyAndScale } = $$props;
      let { transitionConfig = { y: 2, duration: 150 } } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.sideOffset === void 0 && $$bindings.sideOffset && sideOffset !== void 0)
        $$bindings.sideOffset(sideOffset);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(TooltipContent, "TooltipPrimitive.Content").$$render(
        $$result,
        Object.assign(
          {},
          { sideOffset },
          { transition },
          { transitionConfig },
          {
            class: cn("z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Root$2 = Tooltip;
    Trigger$2 = TooltipTrigger;
    SidebarNewFolderButton = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let loading = false;
      return `${validate_component(Root$2, "Tooltip.Root").$$render($$result, {}, {}, {
        default: () => {
          return `${validate_component(Trigger$2, "Tooltip.Trigger").$$render($$result, {}, {}, {
            default: () => {
              return `<form method="POST" action="/?/create-item"><input type="hidden" value="folder" name="type"> ${validate_component(Button, "Button").$$render(
                $$result,
                {
                  size: "xs",
                  variant: "outline",
                  disabled: loading,
                  type: "submit",
                  class: "py-2 px-1.5 rounded-md md:hidden hover:bg-white/5"
                },
                {},
                {
                  default: () => {
                    return `New Folder`;
                  }
                }
              )} <button ${""} type="submit" class="py-2 px-1.5 rounded-md hidden md:block hover:bg-white/5"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-folder-plus"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"></path><line x1="12" x2="12" y1="10" y2="16"></line><line x1="9" x2="15" y1="13" y2="13"></line></svg></button></form>`;
            }
          })} ${validate_component(Tooltip_content, "Tooltip.Content").$$render($$result, {}, {}, {
            default: () => {
              return `<p data-svelte-h="svelte-wqdoh6">New Folder</p>`;
            }
          })}`;
        }
      })}`;
    });
    SidebarNewNoteButton = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let loading = false;
      return `${validate_component(Root$2, "Tooltip.Root").$$render($$result, {}, {}, {
        default: () => {
          return `${validate_component(Trigger$2, "Tooltip.Trigger").$$render($$result, {}, {}, {
            default: () => {
              return `<form method="POST" action="/?/create-item"><input type="hidden" value="file" name="type"> ${validate_component(Button, "Button").$$render(
                $$result,
                {
                  size: "xs",
                  disabled: loading,
                  type: "submit",
                  class: "py-2 px-1.5 rounded-md hover:bg-white/5 md:hidden"
                },
                {},
                {
                  default: () => {
                    return `New Note`;
                  }
                }
              )} <button ${""} type="submit" class="py-2 px-1.5 rounded-md hover:bg-white/5 hidden md:block" id="create-new-note-form-submit"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-edit"><path d="M4 13.5V4a2 2 0 0 1 2-2h8.5L20 7.5V20a2 2 0 0 1-2 2h-5.5"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M10.42 12.61a2.1 2.1 0 1 1 2.97 2.97L7.95 21 4 22l.99-3.95 5.43-5.44Z"></path></svg></button></form>`;
            }
          })} ${validate_component(Tooltip_content, "Tooltip.Content").$$render($$result, {}, {}, {
            default: () => {
              return `<p data-svelte-h="svelte-8wuyqi">New Note</p>`;
            }
          })}`;
        }
      })}`;
    });
    SidebarSearchButton = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Root$2, "Tooltip.Root").$$render($$result, {}, {}, {
        default: () => {
          return `${validate_component(Trigger$2, "Tooltip.Trigger").$$render($$result, {}, {}, {
            default: () => {
              return `<button class="py-2 px-1.5 rounded-md hover:bg-white/5" data-svelte-h="svelte-sqryf9"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg></button>`;
            }
          })} ${validate_component(Tooltip_content, "Tooltip.Content").$$render($$result, {}, {}, {
            default: () => {
              return `<p data-svelte-h="svelte-1a6y03c">Search</p>`;
            }
          })}`;
        }
      })}`;
    });
    Dropdown_menu_item = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "inset"]);
      let { class: className = void 0 } = $$props;
      let { inset = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.inset === void 0 && $$bindings.inset && inset !== void 0)
        $$bindings.inset(inset);
      return `${validate_component(DropdownMenuItem, "DropdownMenuPrimitive.Item").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-[0.8rem] outline-none data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", inset && "pl-8", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Dropdown_menu_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = flyAndScale } = $$props;
      let { transitionConfig = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(DropdownMenuContent, "DropdownMenuPrimitive.Content").$$render(
        $$result,
        Object.assign(
          {},
          { transition },
          { transitionConfig },
          {
            class: cn("z-50 min-w-[8rem] rounded-md border bg-popover p-1 text-popover-foreground shadow-md focus:outline-none", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Check3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size2 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size2 !== void 0)
        $$bindings.size(size2);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size2) },
          { height: escape_attribute_value(size2) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    Check$1 = Check3;
    ChevronRight = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size2 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size2 !== void 0)
        $$bindings.size(size2);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size2) },
          { height: escape_attribute_value(size2) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    ChevronRight$1 = ChevronRight;
    Pencil2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size2 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size2 !== void 0)
        $$bindings.size(size2);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size2) },
          { height: escape_attribute_value(size2) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M12.1464 1.14645C12.3417 0.951184 12.6583 0.951184 12.8535 1.14645L14.8535 3.14645C15.0488 3.34171 15.0488 3.65829 14.8535 3.85355L10.9109 7.79618C10.8349 7.87218 10.7471 7.93543 10.651 7.9835L6.72359 9.94721C6.53109 10.0435 6.29861 10.0057 6.14643 9.85355C5.99425 9.70137 5.95652 9.46889 6.05277 9.27639L8.01648 5.34897C8.06455 5.25283 8.1278 5.16507 8.2038 5.08907L12.1464 1.14645ZM12.5 2.20711L8.91091 5.79618L7.87266 7.87267L8.12731 8.12732L10.2038 7.08907L13.7929 3.5L12.5 2.20711ZM9.99998 2L8.99998 3H4.9C4.47171 3 4.18056 3.00039 3.95552 3.01877C3.73631 3.03668 3.62421 3.06915 3.54601 3.10899C3.35785 3.20487 3.20487 3.35785 3.10899 3.54601C3.06915 3.62421 3.03669 3.73631 3.01878 3.95552C3.00039 4.18056 3 4.47171 3 4.9V11.1C3 11.5283 3.00039 11.8194 3.01878 12.0445C3.03669 12.2637 3.06915 12.3758 3.10899 12.454C3.20487 12.6422 3.35785 12.7951 3.54601 12.891C3.62421 12.9309 3.73631 12.9633 3.95552 12.9812C4.18056 12.9996 4.47171 13 4.9 13H11.1C11.5283 13 11.8194 12.9996 12.0445 12.9812C12.2637 12.9633 12.3758 12.9309 12.454 12.891C12.6422 12.7951 12.7951 12.6422 12.891 12.454C12.9309 12.3758 12.9633 12.2637 12.9812 12.0445C12.9996 11.8194 13 11.5283 13 11.1V6.99998L14 5.99998V11.1V11.1207C14 11.5231 14 11.8553 13.9779 12.1259C13.9549 12.407 13.9057 12.6653 13.782 12.908C13.5903 13.2843 13.2843 13.5903 12.908 13.782C12.6653 13.9057 12.407 13.9549 12.1259 13.9779C11.8553 14 11.5231 14 11.1207 14H11.1H4.9H4.87934C4.47686 14 4.14468 14 3.87409 13.9779C3.59304 13.9549 3.33469 13.9057 3.09202 13.782C2.7157 13.5903 2.40973 13.2843 2.21799 12.908C2.09434 12.6653 2.04506 12.407 2.0221 12.1259C1.99999 11.8553 1.99999 11.5231 2 11.1207V11.1206V11.1V4.9V4.87935V4.87932V4.87931C1.99999 4.47685 1.99999 4.14468 2.0221 3.87409C2.04506 3.59304 2.09434 3.33469 2.21799 3.09202C2.40973 2.71569 2.7157 2.40973 3.09202 2.21799C3.33469 2.09434 3.59304 2.04506 3.87409 2.0221C4.14468 1.99999 4.47685 1.99999 4.87932 2H4.87935H4.9H9.99998Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    Pencil2$1 = Pencil2;
    Trash = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size2 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size2 !== void 0)
        $$bindings.size(size2);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size2) },
          { height: escape_attribute_value(size2) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 1C5.22386 1 5 1.22386 5 1.5C5 1.77614 5.22386 2 5.5 2H9.5C9.77614 2 10 1.77614 10 1.5C10 1.22386 9.77614 1 9.5 1H5.5ZM3 3.5C3 3.22386 3.22386 3 3.5 3H5H10H11.5C11.7761 3 12 3.22386 12 3.5C12 3.77614 11.7761 4 11.5 4H11V12C11 12.5523 10.5523 13 10 13H5C4.44772 13 4 12.5523 4 12V4L3.5 4C3.22386 4 3 3.77614 3 3.5ZM5 4H10V12H5V4Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    Trash$1 = Trash;
    Dropdown_menu_separator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(DropdownMenuSeparator, "DropdownMenuPrimitive.Separator").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("-mx-1 my-1 h-px bg-neutral-700", className)
          },
          $$restProps
        ),
        {},
        {}
      )}`;
    });
    Root$1 = DropdownMenu;
    Trigger$1 = DropdownMenuTrigger;
    Group = DropdownMenuGroup;
    SidebarSortButton = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $sortOrder, $$unsubscribe_sortOrder;
      $$unsubscribe_sortOrder = subscribe(sortOrder, (value) => $sortOrder = value);
      let open = false;
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(Root$1, "DropdownMenu.Root").$$render(
          $$result,
          { open },
          {
            open: ($$value) => {
              open = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `${validate_component(Trigger$1, "DropdownMenu.Trigger").$$render($$result, { asChild: true }, {}, {
                default: ({ builder: builder2 }) => {
                  return `${validate_component(Root$2, "Tooltip.Root").$$render($$result, {}, {}, {
                    default: () => {
                      return `${validate_component(Trigger$2, "Tooltip.Trigger").$$render($$result, {}, {}, {
                        default: () => {
                          return `${validate_component(Button, "Button").$$render(
                            $$result,
                            {
                              builders: [builder2],
                              size: "icon",
                              class: "px-1.5 py-2 w-auto h-auto",
                              variant: "ghost"
                            },
                            {},
                            {
                              default: () => {
                                return `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-up-narrow-wide"><path d="m3 8 4-4 4 4"></path><path d="M7 4v16"></path><path d="M11 12h4"></path><path d="M11 16h7"></path><path d="M11 20h10"></path></svg>`;
                              }
                            }
                          )}`;
                        }
                      })} ${validate_component(Tooltip_content, "Tooltip.Content").$$render($$result, {}, {}, {
                        default: () => {
                          return `<p data-svelte-h="svelte-1czr6x">Sort By</p>`;
                        }
                      })}`;
                    }
                  })}`;
                }
              })} ${validate_component(Dropdown_menu_content, "DropdownMenu.Content").$$render($$result, { class: "w-52" }, {}, {
                default: () => {
                  return `${validate_component(Group, "DropdownMenu.Group").$$render($$result, {}, {}, {
                    default: () => {
                      return `${validate_component(Dropdown_menu_item, "DropdownMenu.Item").$$render(
                        $$result,
                        {
                          class: "flex items-center justify-between"
                        },
                        {},
                        {
                          default: () => {
                            return `<span data-svelte-h="svelte-184uid8">File name (A to Z)</span> ${$sortOrder === "name_asc" ? `${validate_component(Check$1, "Check").$$render($$result, { size: 18 }, {}, {})}` : ``}`;
                          }
                        }
                      )} ${validate_component(Dropdown_menu_item, "DropdownMenu.Item").$$render($$result, {}, {}, {
                        default: () => {
                          return `<span data-svelte-h="svelte-14m5xq2">File name (Z to A)</span> ${$sortOrder === "name_desc" ? `${validate_component(Check$1, "Check").$$render($$result, { size: 18 }, {}, {})}` : ``}`;
                        }
                      })}`;
                    }
                  })} ${validate_component(Dropdown_menu_separator, "DropdownMenu.Separator").$$render($$result, {}, {}, {})} ${validate_component(Group, "DropdownMenu.Group").$$render($$result, {}, {}, {
                    default: () => {
                      return `${validate_component(Dropdown_menu_item, "DropdownMenu.Item").$$render($$result, {}, {}, {
                        default: () => {
                          return `<span data-svelte-h="svelte-1p43zu7">Modified time (new to old)</span> ${$sortOrder === "updated_at_asc" ? `${validate_component(Check$1, "Check").$$render($$result, { size: 18 }, {}, {})}` : ``}`;
                        }
                      })} ${validate_component(Dropdown_menu_item, "DropdownMenu.Item").$$render($$result, {}, {}, {
                        default: () => {
                          return `<span data-svelte-h="svelte-16xd4jt">Modified time (old to new)</span> ${$sortOrder === "updated_at_desc" ? `${validate_component(Check$1, "Check").$$render($$result, { size: 18 }, {}, {})}` : ``}`;
                        }
                      })}`;
                    }
                  })} ${validate_component(Dropdown_menu_separator, "DropdownMenu.Separator").$$render($$result, {}, {}, {})} ${validate_component(Group, "DropdownMenu.Group").$$render($$result, {}, {}, {
                    default: () => {
                      return `${validate_component(Dropdown_menu_item, "DropdownMenu.Item").$$render($$result, {}, {}, {
                        default: () => {
                          return `<span data-svelte-h="svelte-ilf1jk">Created time (new to old)</span> ${$sortOrder === "created_at_asc" ? `${validate_component(Check$1, "Check").$$render($$result, { size: 18 }, {}, {})}` : ``}`;
                        }
                      })} ${validate_component(Dropdown_menu_item, "DropdownMenu.Item").$$render($$result, {}, {}, {
                        default: () => {
                          return `<span data-svelte-h="svelte-obtjpa">Created time (old to new)</span> ${$sortOrder === "created_at_desc" ? `${validate_component(Check$1, "Check").$$render($$result, { size: 18 }, {}, {})}` : ``}`;
                        }
                      })}`;
                    }
                  })}`;
                }
              })}`;
            }
          }
        )}`;
      } while (!$$settled);
      $$unsubscribe_sortOrder();
      return $$rendered;
    });
    Context_menu_item = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "inset"]);
      let { class: className = void 0 } = $$props;
      let { inset = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.inset === void 0 && $$bindings.inset && inset !== void 0)
        $$bindings.inset(inset);
      return `${validate_component(ContextMenuItem, "ContextMenuPrimitive.Item").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", inset && "pl-8", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Context_menu_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = flyAndScale } = $$props;
      let { transitionConfig = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(ContextMenuContent, "ContextMenuPrimitive.Content").$$render(
        $$result,
        Object.assign(
          {},
          { transition },
          { transitionConfig },
          {
            class: cn("z-50 min-w-[8rem] rounded-md border bg-popover p-1 text-popover-foreground shadow-md focus:outline-none", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Context_menu_separator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(ContextMenuSeparator, "ContextMenuPrimitive.Separator").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("-mx-1 my-1 h-px bg-border", className)
          },
          $$restProps
        ),
        {},
        {}
      )}`;
    });
    Root2 = ContextMenu;
    Trigger = ContextMenuTrigger;
    TreeView = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let active;
      let $sortOrder, $$unsubscribe_sortOrder;
      let $page, $$unsubscribe_page;
      $$unsubscribe_sortOrder = subscribe(sortOrder, (value) => $sortOrder = value);
      $$unsubscribe_page = subscribe(page, (value) => $page = value);
      let { item } = $$props;
      let { isRoot = false } = $$props;
      if ($$props.item === void 0 && $$bindings.item && item !== void 0)
        $$bindings.item(item);
      if ($$props.isRoot === void 0 && $$bindings.isRoot && isRoot !== void 0)
        $$bindings.isRoot(isRoot);
      active = item.id === $page.params.itemId;
      item.children?.sort((a2, b) => {
        if (a2.type === "folder" && b.type === "file")
          return -1;
        if (a2.type === "file" && b.type === "folder")
          return 1;
        if ($sortOrder === "name_desc")
          return b.name.localeCompare(a2.name);
        else if ($sortOrder === "created_at_asc")
          return a2.createdAt.getTime() - b.createdAt.getTime();
        else if ($sortOrder === "created_at_desc")
          return b.createdAt.getTime() - a2.createdAt.getTime();
        else if ($sortOrder === "updated_at_asc")
          return a2.updatedAt.getTime() - b.updatedAt.getTime();
        else if ($sortOrder === "updated_at_desc")
          return b.updatedAt.getTime() - a2.updatedAt.getTime();
        return a2.name.localeCompare(b.name);
      }) ?? [];
      $$unsubscribe_sortOrder();
      $$unsubscribe_page();
      return `<ul class="${"m-0 list-none p-0 " + escape(isRoot ? "" : "pl-[1.2rem]", true) + " select-none text-sm text-neutral-300"}" style="margin-block-start: 0;"><li class="mb-0.5">  ${validate_component(Root2, "ContextMenu.Root").$$render($$result, {}, {}, {
        default: () => {
          return `${validate_component(Trigger, "ContextMenu.Trigger").$$render($$result, {}, {}, {
            default: () => {
              return `${item.type === "folder" ? `<div class="flex items-center gap-2 px-2 py-1.5 rounded-md hover:cursor-pointer hover:bg-white/5">${`${validate_component(ChevronRight$1, "ChevronRight").$$render($$result, { size: 16 }, {}, {})}`} ${escape(item.name)}</div>` : `<a class="${"flex items-center gap-2 px-2 py-1 rounded-md hover:cursor-pointer " + escape(active ? "bg-white/5" : "hover:bg-white/5", true)}" href="${"/" + escape(item.id, true)}"><div class="w-4 h-4"></div> ${escape(item.name)}</a>`}`;
            }
          })} ${validate_component(Context_menu_content, "ContextMenu.Content").$$render($$result, {}, {}, {
            default: () => {
              return `${item.type === "folder" ? `<form method="POST" action="/?/create-item"><input type="hidden" name="type" value="file"> <input type="hidden" name="parentId"${add_attribute("value", item.id, 0)}> <button type="submit" class="w-full" ${""}>${validate_component(Context_menu_item, "ContextMenu.Item").$$render($$result, { class: "flex items-center gap-2" }, {}, {
                default: () => {
                  return `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-edit"><path d="M4 13.5V4a2 2 0 0 1 2-2h8.5L20 7.5V20a2 2 0 0 1-2 2h-5.5"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M10.42 12.61a2.1 2.1 0 1 1 2.97 2.97L7.95 21 4 22l.99-3.95 5.43-5.44Z"></path></svg>
								New note`;
                }
              })}</button></form> <form method="POST" action="/?/create-item"><input type="hidden" name="type" value="folder"> <input type="hidden" name="parentId"${add_attribute("value", item.id, 0)}> <button type="submit" class="w-full" ${""}>${validate_component(Context_menu_item, "ContextMenu.Item").$$render($$result, { class: "flex items-center gap-2" }, {}, {
                default: () => {
                  return `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-folder-plus"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"></path><line x1="12" x2="12" y1="10" y2="16"></line><line x1="9" x2="15" y1="13" y2="13"></line></svg>
								New folder`;
                }
              })}</button></form> ${validate_component(Context_menu_separator, "ContextMenu.Separator").$$render($$result, {}, {}, {})}` : ``} <button class="w-full">${validate_component(Context_menu_item, "ContextMenu.Item").$$render($$result, { class: "flex items-center gap-2" }, {}, {
                default: () => {
                  return `${validate_component(Pencil2$1, "Pencil2").$$render($$result, { size: 16 }, {}, {})}
						Rename`;
                }
              })}</button> <button class="w-full">${validate_component(Context_menu_item, "ContextMenu.Item").$$render(
                $$result,
                {
                  class: "flex items-center gap-2 hover:!text-red-500"
                },
                {},
                {
                  default: () => {
                    return `${validate_component(Trash$1, "Trash").$$render($$result, { size: 18 }, {}, {})}
						Delete`;
                  }
                }
              )}</button>`;
            }
          })}`;
        }
      })} ${``}</li></ul>`;
    });
    Sidebar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let sortedItems;
      let $sortOrder, $$unsubscribe_sortOrder;
      $$unsubscribe_sortOrder = subscribe(sortOrder, (value) => $sortOrder = value);
      let { items } = $$props;
      let sheetOpen = false;
      afterNavigate(() => {
        sheetOpen = false;
        searchDialogOpen.set(false);
      });
      if ($$props.items === void 0 && $$bindings.items && items !== void 0)
        $$bindings.items(items);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        sortedItems = items.sort((a2, b) => {
          if (a2.type === "folder" && b.type === "file")
            return -1;
          if (a2.type === "file" && b.type === "folder")
            return 1;
          if ($sortOrder === "name_desc")
            return b.name.localeCompare(a2.name);
          else if ($sortOrder === "created_at_asc")
            return a2.createdAt.getTime() - b.createdAt.getTime();
          else if ($sortOrder === "created_at_desc")
            return b.createdAt.getTime() - a2.createdAt.getTime();
          else if ($sortOrder === "updated_at_asc")
            return a2.updatedAt.getTime() - b.updatedAt.getTime();
          else if ($sortOrder === "updated_at_desc")
            return b.updatedAt.getTime() - a2.updatedAt.getTime();
          return a2.name.localeCompare(b.name);
        });
        $$rendered = `<aside class="w-72 bg-popover border-r border-r-[#313131] h-full fixed inset-0 hidden md:block"><div class="w-full p-4 h-full flex flex-col overflow-y-scroll"><div class="flex items-center justify-between"><a href="/" class="font-semibold text-xl text-white" data-svelte-h="svelte-160a0a6">Vault</a> <div class="flex items-center text-popover-foreground">${validate_component(SidebarSearchButton, "SidebarSearchButton").$$render($$result, {}, {}, {})} ${validate_component(SidebarNewNoteButton, "SidebarNewNoteButton").$$render($$result, {}, {}, {})} ${validate_component(SidebarNewFolderButton, "SidebarNewFolderButton").$$render($$result, {}, {}, {})} ${validate_component(SidebarSortButton, "SidebarSortButton").$$render($$result, {}, {}, {})}</div></div> <div class="flex flex-col mt-4">${each(sortedItems, (item) => {
          return `${validate_component(TreeView, "TreeView").$$render($$result, { isRoot: true, item }, {}, {})}`;
        })}</div></div></aside> <header class="md:hidden fixed top-0 left-0 w-screen h-12 px-4 flex items-center bg-popover justify-between">${validate_component(Button, "Button").$$render($$result, { variant: "ghost", size: "sm" }, {}, {
          default: () => {
            return `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg>`;
          }
        })} ${validate_component(Button, "Button").$$render($$result, { variant: "ghost", size: "sm" }, {}, {
          default: () => {
            return `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg>`;
          }
        })}</header> ${validate_component(Root$3, "Sheet.Root").$$render(
          $$result,
          { open: sheetOpen },
          {
            open: ($$value) => {
              sheetOpen = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `${validate_component(Sheet_content, "Sheet.Content").$$render(
                $$result,
                {
                  class: "h-[80vh] py-6 px-0 md:hidden",
                  side: "bottom"
                },
                {},
                {
                  default: () => {
                    return `<div class="w-full h-full flex flex-col overflow-y-scroll px-2.5"><div class="flex items-center justify-between"><a href="/" class="font-semibold text-xl text-white" data-svelte-h="svelte-160a0a6">Vault</a> <div class="flex items-center text-popover-foreground gap-2">${validate_component(SidebarNewNoteButton, "SidebarNewNoteButton").$$render($$result, {}, {}, {})} ${validate_component(SidebarNewFolderButton, "SidebarNewFolderButton").$$render($$result, {}, {}, {})}</div></div> <div class="flex flex-col mt-4">${each(sortedItems, (item) => {
                      return `${validate_component(TreeView, "TreeView").$$render($$result, { isRoot: true, item }, {}, {})}`;
                    })}</div></div>`;
                  }
                }
              )}`;
            }
          }
        )} ${validate_component(SearchCommand, "SearchCommand").$$render($$result, { items }, {}, {})} ${validate_component(DeleteItemAlertDialog, "DeleteItemAlertDialog").$$render($$result, {}, {}, {})} ${validate_component(RenameItemDialog, "RenameItemDialog").$$render($$result, {}, {}, {})} <form method="POST" action="/?/delete-item" class="hidden" data-svelte-h="svelte-1oeqcww"><input type="hidden" name="itemId" id="delete-item-id-input"> <button type="submit" id="delete-item-submit-button"></button></form>`;
      } while (!$$settled);
      $$unsubscribe_sortOrder();
      return $$rendered;
    });
    Layout2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data } = $$props;
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      return `${validate_component(Sidebar, "Sidebar").$$render($$result, { items: data.items }, {}, {})} <div class="md:ml-72 md:w-[calc(100vw-18rem)] md:mt-0 mt-12 w-screen h-full">${slots.default ? slots.default({}) : ``}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  server: () => layout_server_ts_exports,
  server_id: () => server_id,
  stylesheets: () => stylesheets3
});
var index3, component_cache3, component3, server_id, imports3, stylesheets3, fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_layout_server_ts();
    index3 = 2;
    component3 = async () => component_cache3 ?? (component_cache3 = (await Promise.resolve().then(() => (init_layout_svelte2(), layout_svelte_exports2))).default);
    server_id = "src/routes/(authed)/+layout.server.ts";
    imports3 = ["_app/immutable/nodes/2.47e542c7.js", "_app/immutable/chunks/scheduler.e51e3a72.js", "_app/immutable/chunks/index.70313ae9.js", "_app/immutable/chunks/each.ed497e26.js", "_app/immutable/chunks/forms.74b24cae.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.844f0d64.js", "_app/immutable/chunks/index.6cb2aa35.js", "_app/immutable/chunks/navigation.2b543295.js", "_app/immutable/chunks/stores.7848577e.js", "_app/immutable/chunks/Toaster.svelte_svelte_type_style_lang.7ad7c14e.js", "_app/immutable/chunks/spread.8a54911c.js", "_app/immutable/chunks/search.65bc8b44.js"];
    stylesheets3 = ["_app/immutable/assets/Toaster.37b6ac62.css"];
    fonts3 = [];
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes2(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes2;
    function hash2(hash3) {
      if (typeof hash3 !== "function" || typeof hash3.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash3.outputLen);
      number(hash3.blockLen);
    }
    exports.hash = hash2;
    function exists2(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists2;
    function output(out, instance) {
      bytes2(out);
      const min2 = instance.outputLen;
      if (out.length < min2) {
        throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes: bytes2, hash: hash2, exists: exists2, output };
    exports.default = assert;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split2(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i2 = 0; i2 < lst.length; i2++) {
        const { h, l: l2 } = fromBig(lst[i2], le);
        [Ah[i2], Al[i2]] = [h, l2];
      }
      return [Ah, Al];
    }
    exports.split = split2;
    var toBig = (h, l2) => BigInt(h >>> 0) << _32n | BigInt(l2 >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s2) => h >>> s2;
    exports.shrSH = shrSH;
    var shrSL = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
    exports.shrSL = shrSL;
    var rotrSH = (h, l2, s2) => h >>> s2 | l2 << 32 - s2;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l2, s2) => h << 64 - s2 | l2 >>> s2 - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l2, s2) => h >>> s2 - 32 | l2 << 64 - s2;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h2, l2) => l2;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l2, s2) => h << s2 | l2 >>> 32 - s2;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l2, s2) => l2 << s2 | h >>> 32 - s2;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l2, s2) => l2 << s2 - 32 | h >>> 64 - s2;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l2, s2) => h << s2 - 32 | l2 >>> 64 - s2;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l2 = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split: split2,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8a = (a2) => a2 instanceof Uint8Array;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u322;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift3) => word << 32 - shift3 | word >>> shift3;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex(bytes2) {
      if (!u8a(bytes2))
        throw new Error("Uint8Array expected");
      let hex2 = "";
      for (let i2 = 0; i2 < bytes2.length; i2++) {
        hex2 += hexes[bytes2[i2]];
      }
      return hex2;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex2) {
      if (typeof hex2 !== "string")
        throw new Error("hex string expected, got " + typeof hex2);
      const len = hex2.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array2 = new Uint8Array(len / 2);
      for (let i2 = 0; i2 < array2.length; i2++) {
        const j2 = i2 * 2;
        const hexByte = hex2.slice(j2, j2 + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array2[i2] = byte;
      }
      return array2;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick2 = async () => {
    };
    exports.nextTick = nextTick2;
    async function asyncLoop2(iters, tick2, cb) {
      let ts2 = Date.now();
      for (let i2 = 0; i2 < iters; i2++) {
        cb(i2);
        const diff = Date.now() - ts2;
        if (diff >= 0 && diff < tick2)
          continue;
        await (0, exports.nextTick)();
        ts2 += diff;
      }
    }
    exports.asyncLoop = asyncLoop2;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      const r2 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
      let pad = 0;
      arrays.forEach((a2) => {
        if (!u8a(a2))
          throw new Error("Uint8Array expected");
        r2.set(a2, pad);
        pad += a2.length;
      });
      return r2;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts2(defaults3, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults3, opts);
      return merged;
    }
    exports.checkOpts = checkOpts2;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = /* @__PURE__ */ BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    var _7n = /* @__PURE__ */ BigInt(7);
    var _256n = /* @__PURE__ */ BigInt(256);
    var _0x71n = /* @__PURE__ */ BigInt(113);
    for (let round2 = 0, R2 = _1n, x2 = 1, y2 = 0; round2 < 24; round2++) {
      [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
      SHA3_PI.push(2 * (5 * y2 + x2));
      SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
      let t = _0n;
      for (let j2 = 0; j2 < 7; j2++) {
        R2 = (R2 << _1n ^ (R2 >> _7n) * _0x71n) % _256n;
        if (R2 & _2n)
          t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j2)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l2, s2) => s2 > 32 ? (0, _u64_js_1.rotlBH)(h, l2, s2) : (0, _u64_js_1.rotlSH)(h, l2, s2);
    var rotlL = (h, l2, s2) => s2 > 32 ? (0, _u64_js_1.rotlBL)(h, l2, s2) : (0, _u64_js_1.rotlSL)(h, l2, s2);
    function keccakP(s2, rounds = 24) {
      const B2 = new Uint32Array(5 * 2);
      for (let round2 = 24 - rounds; round2 < 24; round2++) {
        for (let x2 = 0; x2 < 10; x2++)
          B2[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
        for (let x2 = 0; x2 < 10; x2 += 2) {
          const idx1 = (x2 + 8) % 10;
          const idx0 = (x2 + 2) % 10;
          const B0 = B2[idx0];
          const B1 = B2[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B2[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
          for (let y2 = 0; y2 < 50; y2 += 10) {
            s2[x2 + y2] ^= Th;
            s2[x2 + y2 + 1] ^= Tl;
          }
        }
        let curH = s2[2];
        let curL = s2[3];
        for (let t = 0; t < 24; t++) {
          const shift3 = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift3);
          const Tl = rotlL(curH, curL, shift3);
          const PI = SHA3_PI[t];
          curH = s2[PI];
          curL = s2[PI + 1];
          s2[PI] = Th;
          s2[PI + 1] = Tl;
        }
        for (let y2 = 0; y2 < 50; y2 += 10) {
          for (let x2 = 0; x2 < 10; x2++)
            B2[x2] = s2[y2 + x2];
          for (let x2 = 0; x2 < 10; x2++)
            s2[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
        }
        s2[0] ^= SHA3_IOTA_H[round2];
        s2[1] ^= SHA3_IOTA_L[round2];
      }
      B2.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i2 = 0; i2 < take; i2++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes2) {
        (0, _assert_js_1.number)(bytes2);
        return this.xofInto(new Uint8Array(bytes2));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/.pnpm/@paralleldrive+cuid2@2.2.2/node_modules/@paralleldrive/cuid2/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/@paralleldrive+cuid2@2.2.2/node_modules/@paralleldrive/cuid2/src/index.js"(exports, module) {
    var { sha3_512: sha3 } = require_sha3();
    var defaultLength = 24;
    var bigLength = 32;
    var createEntropy = (length = 4, random = Math.random) => {
      let entropy = "";
      while (entropy.length < length) {
        entropy = entropy + Math.floor(random() * 36).toString(36);
      }
      return entropy;
    };
    function bufToBigInt(buf) {
      let bits = 8n;
      let value = 0n;
      for (const i2 of buf.values()) {
        const bi = BigInt(i2);
        value = (value << bits) + bi;
      }
      return value;
    }
    var hash2 = (input = "") => {
      return bufToBigInt(sha3(input)).toString(36).slice(1);
    };
    var alphabet = Array.from(
      { length: 26 },
      (x2, i2) => String.fromCharCode(i2 + 97)
    );
    var randomLetter = (random) => alphabet[Math.floor(random() * alphabet.length)];
    var createFingerprint = ({
      globalObj = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {},
      random = Math.random
    } = {}) => {
      const globals = Object.keys(globalObj).toString();
      const sourceString = globals.length ? globals + createEntropy(bigLength, random) : createEntropy(bigLength, random);
      return hash2(sourceString).substring(0, bigLength);
    };
    var createCounter = (count) => () => {
      return count++;
    };
    var initialCountMax = 476782367;
    var init3 = ({
      // Fallback if the user does not pass in a CSPRNG. This should be OK
      // because we don't rely solely on the random number generator for entropy.
      // We also use the host fingerprint, current time, and a session counter.
      random = Math.random,
      counter = createCounter(Math.floor(random() * initialCountMax)),
      length = defaultLength,
      fingerprint = createFingerprint({ random })
    } = {}) => {
      return function cuid2() {
        const firstLetter = randomLetter(random);
        const time = Date.now().toString(36);
        const count = counter().toString(36);
        const salt = createEntropy(length, random);
        const hashInput = `${time + salt + count + fingerprint}`;
        return `${firstLetter + hash2(hashInput).substring(1, length)}`;
      };
    };
    var createId4 = init3();
    var isCuid = (id, { minLength = 2, maxLength = bigLength } = {}) => {
      const length = id.length;
      const regex = /^[0-9a-z]+$/;
      try {
        if (typeof id === "string" && length >= minLength && length <= maxLength && regex.test(id))
          return true;
      } finally {
      }
      return false;
    };
    module.exports.getConstants = () => ({ defaultLength, bigLength });
    module.exports.init = init3;
    module.exports.createId = createId4;
    module.exports.bufToBigInt = bufToBigInt;
    module.exports.createCounter = createCounter;
    module.exports.createFingerprint = createFingerprint;
    module.exports.isCuid = isCuid;
  }
});

// node_modules/.pnpm/@paralleldrive+cuid2@2.2.2/node_modules/@paralleldrive/cuid2/index.js
var require_cuid2 = __commonJS({
  "node_modules/.pnpm/@paralleldrive+cuid2@2.2.2/node_modules/@paralleldrive/cuid2/index.js"(exports, module) {
    var { createId: createId4, init: init3, getConstants, isCuid } = require_src();
    module.exports.createId = createId4;
    module.exports.init = init3;
    module.exports.getConstants = getConstants;
    module.exports.isCuid = isCuid;
  }
});

// node_modules/.pnpm/zod@3.22.2/node_modules/zod/lib/index.mjs
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx2, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx2.data,
    path: ctx2.path,
    errorMaps: [
      ctx2.common.contextualErrorMap,
      ctx2.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx2.common.issues.push(issue);
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx2) => {
    if (iss.code !== "invalid_type")
      return { message: ctx2.defaultError };
    if (typeof ctx2.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx2.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx2.defaultError };
  };
  return { errorMap: customMap, description };
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema3) {
  if (schema3 instanceof ZodObject) {
    const newShape = {};
    for (const key3 in schema3.shape) {
      const fieldSchema = schema3.shape[key3];
      newShape[key3] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema3._def,
      shape: () => newShape
    });
  } else if (schema3 instanceof ZodArray) {
    return new ZodArray({
      ...schema3._def,
      type: deepPartialify(schema3.element)
    });
  } else if (schema3 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodTuple) {
    return ZodTuple.create(schema3.items.map((item) => deepPartialify(item)));
  } else {
    return schema3;
  }
}
function mergeValues(a2, b) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b);
  if (a2 === b) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a2).filter((key3) => bKeys.indexOf(key3) !== -1);
    const newObj = { ...a2, ...b };
    for (const key3 of sharedKeys) {
      const sharedValue = mergeValues(a2[key3], b[key3]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key3] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index8 = 0; index8 < a2.length; index8++) {
      const itemA = a2[index8];
      const itemB = b[index8];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var util, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, ZodError, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, emailRegex, emojiRegex, ipv4Regex, ipv6Regex, datetimeRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, custom, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER, z;
var init_lib = __esm({
  "node_modules/.pnpm/zod@3.22.2/node_modules/zod/lib/index.mjs"() {
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys2 = [];
        for (const key3 in object) {
          if (Object.prototype.hasOwnProperty.call(object, key3)) {
            keys2.push(key3);
          }
        }
        return keys2;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array2, separator = " | ") {
        return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first2, second) => {
        return {
          ...first2,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json2 = JSON.stringify(obj, null, 2);
      return json2.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error3) => {
          for (const issue of error3.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i2 = 0;
              while (i2 < issue.path.length) {
                const el = issue.path[i2];
                const terminal = i2 === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i2++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error3 = new ZodError(issues);
      return error3;
    };
    errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    };
    overrideErrorMap = errorMap;
    makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map2 of maps) {
        errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s2 of results) {
          if (s2.status === "aborted")
            return INVALID;
          if (s2.status === "dirty")
            status.dirty();
          arrayValue.push(s2.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key: key3, value } = pair;
          if (key3.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key3.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key3.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key3.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x2) => x2.status === "aborted";
    isDirty = (x2) => x2.status === "dirty";
    isValid = (x2) => x2.status === "valid";
    isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = class {
      constructor(parent, value, path, key3) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key3;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx2, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx2.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error3 = new ZodError(ctx2.common.issues);
            this._error = error3;
            return this._error;
          }
        };
      }
    };
    ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx2) {
        return ctx2 || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a178;
        const ctx2 = {
          common: {
            issues: [],
            async: (_a178 = params === null || params === void 0 ? void 0 : params.async) !== null && _a178 !== void 0 ? _a178 : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx2.path, parent: ctx2 });
        return handleResult(ctx2, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx2 = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx2.path, parent: ctx2 });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx2, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx2) => {
          const result = check(val);
          const setError = () => ctx2.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx2) => {
          if (!check(val)) {
            ctx2.addIssue(typeof refinementData === "function" ? refinementData(val, ctx2) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[a-z][a-z0-9]*$/;
    ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    emailRegex = /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
    ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    datetimeRegex = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    ZodString = class _ZodString extends ZodType {
      constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () => new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
        this.toLowerCase = () => new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
        this.toUpperCase = () => new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx3 = this._getOrReturnCtx(input);
          addIssueToContext(
            ctx3,
            {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx3.parsedType
            }
            //
          );
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx2 = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              if (tooBig) {
                addIssueToContext(ctx2, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx2, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex.test(input.data)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a178) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      ip(options2) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
      }
      datetime(options2) {
        var _a178;
        if (typeof options2 === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options2
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
          offset: (_a178 = options2 === null || options2 === void 0 ? void 0 : options2.offset) !== null && _a178 !== void 0 ? _a178 : false,
          ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options2) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options2 === null || options2 === void 0 ? void 0 : options2.position,
          ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get minLength() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxLength() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    };
    ZodString.create = (params) => {
      var _a178;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a178 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a178 !== void 0 ? _a178 : false,
        ...processCreateParams(params)
      });
    };
    ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx3 = this._getOrReturnCtx(input);
          addIssueToContext(ctx3, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx3.parsedType
          });
          return INVALID;
        }
        let ctx2 = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max2 = null, min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          } else if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return Number.isFinite(min2) && Number.isFinite(max2);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          const ctx3 = this._getOrReturnCtx(input);
          addIssueToContext(ctx3, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx3.parsedType
          });
          return INVALID;
        }
        let ctx2 = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    };
    ZodBigInt.create = (params) => {
      var _a178;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a178 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a178 !== void 0 ? _a178 : false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx3 = this._getOrReturnCtx(input);
          addIssueToContext(ctx3, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx3.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx3 = this._getOrReturnCtx(input);
          addIssueToContext(ctx3, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx2 = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx2 = this._getOrReturnCtx(input, ctx2);
              addIssueToContext(ctx2, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2 != null ? new Date(min2) : null;
      }
      get maxDate() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2 != null ? new Date(max2) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx2.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx: ctx2, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx2.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx2.data.length > def.exactLength.value;
          const tooSmall = ctx2.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx2, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx2.data.length < def.minLength.value) {
            addIssueToContext(ctx2, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx2.data.length > def.maxLength.value) {
            addIssueToContext(ctx2, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx2.common.async) {
          return Promise.all([...ctx2.data].map((item, i2) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx2, item, ctx2.path, i2));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx2.data].map((item, i2) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx2, item, ctx2.path, i2));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema3, params) => {
      return new ZodArray({
        type: schema3,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys2 = util.objectKeys(shape);
        return this._cached = { shape, keys: keys2 };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx3 = this._getOrReturnCtx(input);
          addIssueToContext(ctx3, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx3.parsedType
          });
          return INVALID;
        }
        const { status, ctx: ctx2 } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key3 in ctx2.data) {
            if (!shapeKeys.includes(key3)) {
              extraKeys.push(key3);
            }
          }
        }
        const pairs = [];
        for (const key3 of shapeKeys) {
          const keyValidator = shape[key3];
          const value = ctx2.data[key3];
          pairs.push({
            key: { status: "valid", value: key3 },
            value: keyValidator._parse(new ParseInputLazyPath(ctx2, value, ctx2.path, key3)),
            alwaysSet: key3 in ctx2.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key3 of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key3 },
                value: { status: "valid", value: ctx2.data[key3] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx2, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip")
            ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key3 of extraKeys) {
            const value = ctx2.data[key3];
            pairs.push({
              key: { status: "valid", value: key3 },
              value: catchall._parse(
                new ParseInputLazyPath(ctx2, value, ctx2.path, key3)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key3 in ctx2.data
            });
          }
        }
        if (ctx2.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key3 = await pair.key;
              syncPairs.push({
                key: key3,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx2) => {
              var _a178, _b10, _c4, _d3;
              const defaultError = (_c4 = (_b10 = (_a178 = this._def).errorMap) === null || _b10 === void 0 ? void 0 : _b10.call(_a178, issue, ctx2).message) !== null && _c4 !== void 0 ? _c4 : ctx2.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d3 = errorUtil.errToObj(message).message) !== null && _d3 !== void 0 ? _d3 : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key3, schema3) {
        return this.augment({ [key3]: schema3 });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index8) {
        return new _ZodObject({
          ...this._def,
          catchall: index8
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key3) => {
          if (mask[key3] && this.shape[key3]) {
            shape[key3] = this.shape[key3];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key3) => {
          if (!mask[key3]) {
            shape[key3] = this.shape[key3];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key3) => {
          const fieldSchema = this.shape[key3];
          if (mask && !mask[key3]) {
            newShape[key3] = fieldSchema;
          } else {
            newShape[key3] = fieldSchema.optional();
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key3) => {
          if (mask && !mask[key3]) {
            newShape[key3] = this.shape[key3];
          } else {
            const fieldSchema = this.shape[key3];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key3] = newField;
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx: ctx2 } = this._processInputParams(input);
        const options2 = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx2.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx2.common.async) {
          return Promise.all(options2.map(async (option) => {
            const childCtx = {
              ...ctx2,
              common: {
                ...ctx2.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx2.data,
                path: ctx2.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options2) {
            const childCtx = {
              ...ctx2,
              common: {
                ...ctx2.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx2.data,
              path: ctx2.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx2.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else {
        return null;
      }
    };
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx: ctx2 } = this._processInputParams(input);
        if (ctx2.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx2.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx2.common.async) {
          return option._parseAsync({
            data: ctx2.data,
            path: ctx2.path,
            parent: ctx2
          });
        } else {
          return option._parseSync({
            data: ctx2.data,
            path: ctx2.path,
            parent: ctx2
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options2, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options2) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options: options2,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx: ctx2 } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx2.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx2.data,
              path: ctx2.path,
              parent: ctx2
            }),
            this._def.right._parseAsync({
              data: ctx2.data,
              path: ctx2.path,
              parent: ctx2
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx2.data,
            path: ctx2.path,
            parent: ctx2
          }), this._def.right._parseSync({
            data: ctx2.data,
            path: ctx2.path,
            parent: ctx2
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx: ctx2 } = this._processInputParams(input);
        if (ctx2.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (ctx2.data.length < this._def.items.length) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx2.data.length > this._def.items.length) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx2.data].map((item, itemIndex) => {
          const schema3 = this._def.items[itemIndex] || this._def.rest;
          if (!schema3)
            return null;
          return schema3._parse(new ParseInputLazyPath(ctx2, item, ctx2.path, itemIndex));
        }).filter((x2) => !!x2);
        if (ctx2.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx: ctx2 } = this._processInputParams(input);
        if (ctx2.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key3 in ctx2.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx2, key3, ctx2.path, key3)),
            value: valueType._parse(new ParseInputLazyPath(ctx2, ctx2.data[key3], ctx2.path, key3))
          });
        }
        if (ctx2.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first2, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first2,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first2,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx: ctx2 } = this._processInputParams(input);
        if (ctx2.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx2.data.entries()].map(([key3, value], index8) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx2, key3, ctx2.path, [index8, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx2, value, ctx2.path, [index8, "value"]))
          };
        });
        if (ctx2.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key3 = await pair.key;
              const value = await pair.value;
              if (key3.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key3.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key3.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key3 = pair.key;
            const value = pair.value;
            if (key3.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key3.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key3.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx: ctx2 } = this._processInputParams(input);
        if (ctx2.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx2.data.size < def.minSize.value) {
            addIssueToContext(ctx2, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx2.data.size > def.maxSize.value) {
            addIssueToContext(ctx2, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx2.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx2, item, ctx2.path, i2)));
        if (ctx2.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size2, message) {
        return this.min(size2, message).max(size2, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx: ctx2 } = this._processInputParams(input);
        if (ctx2.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error3) {
          return makeIssue({
            data: args,
            path: ctx2.path,
            errorMaps: [
              ctx2.common.contextualErrorMap,
              ctx2.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x2) => !!x2),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error3
            }
          });
        }
        function makeReturnsIssue(returns, error3) {
          return makeIssue({
            data: returns,
            path: ctx2.path,
            errorMaps: [
              ctx2.common.contextualErrorMap,
              ctx2.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x2) => !!x2),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error3
            }
          });
        }
        const params = { errorMap: ctx2.common.contextualErrorMap };
        const fn = ctx2.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error3 = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error3.addIssue(makeArgsIssue(args, e));
              throw error3;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error3.addIssue(makeReturnsIssue(result, e));
              throw error3;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx: ctx2 } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx2.data, path: ctx2.path, parent: ctx2 });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            received: ctx2.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx2 = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx2, {
            expected: util.joinValues(expectedValues),
            received: ctx2.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx2 = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx2, {
            received: ctx2.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values) {
        return _ZodEnum.create(values);
      }
      exclude(values) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx2 = this._getOrReturnCtx(input);
        if (ctx2.parsedType !== ZodParsedType.string && ctx2.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx2, {
            expected: util.joinValues(expectedValues),
            received: ctx2.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx2, {
            received: ctx2.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx: ctx2 } = this._processInputParams(input);
        if (ctx2.parsedType !== ZodParsedType.promise && ctx2.common.async === false) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const promisified = ctx2.parsedType === ZodParsedType.promise ? ctx2.data : Promise.resolve(ctx2.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx2.path,
            errorMap: ctx2.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema3, params) => {
      return new ZodPromise({
        type: schema3,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx: ctx2 } = this._processInputParams(input);
        const effect2 = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx2, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx2.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect2.type === "preprocess") {
          const processed = effect2.transform(ctx2.data, checkCtx);
          if (ctx2.common.issues.length) {
            return {
              status: "dirty",
              value: ctx2.data
            };
          }
          if (ctx2.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx2.path,
                parent: ctx2
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx2.path,
              parent: ctx2
            });
          }
        }
        if (effect2.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect2.refinement(acc, checkCtx);
            if (ctx2.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx2.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx2.data,
              path: ctx2.path,
              parent: ctx2
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx2.data, path: ctx2.path, parent: ctx2 }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect2.type === "transform") {
          if (ctx2.common.async === false) {
            const base3 = this._def.schema._parseSync({
              data: ctx2.data,
              path: ctx2.path,
              parent: ctx2
            });
            if (!isValid(base3))
              return base3;
            const result = effect2.transform(base3.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx2.data, path: ctx2.path, parent: ctx2 }).then((base3) => {
              if (!isValid(base3))
                return base3;
              return Promise.resolve(effect2.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect2);
      }
    };
    ZodEffects.create = (schema3, effect2, params) => {
      return new ZodEffects({
        schema: schema3,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: effect2,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema3, params) => {
      return new ZodEffects({
        schema: schema3,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx: ctx2 } = this._processInputParams(input);
        let data = ctx2.data;
        if (ctx2.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx2.path,
          parent: ctx2
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx: ctx2 } = this._processInputParams(input);
        const newCtx = {
          ...ctx2,
          common: {
            ...ctx2.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx: ctx2 } = this._processInputParams(input);
        const data = ctx2.data;
        return this._def.type._parse({
          data,
          path: ctx2.path,
          parent: ctx2
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx: ctx2 } = this._processInputParams(input);
        if (ctx2.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx2.data,
              path: ctx2.path,
              parent: ctx2
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx2.path,
                parent: ctx2
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx2.data,
            path: ctx2.path,
            parent: ctx2
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx2.path,
              parent: ctx2
            });
          }
        }
      }
      static create(a2, b) {
        return new _ZodPipeline({
          in: a2,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        if (isValid(result)) {
          result.value = Object.freeze(result.value);
        }
        return result;
      }
    };
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    custom = (check, params = {}, fatal) => {
      if (check)
        return ZodAny.create().superRefine((data, ctx2) => {
          var _a178, _b10;
          if (!check(data)) {
            const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
            const _fatal = (_b10 = (_a178 = p2.fatal) !== null && _a178 !== void 0 ? _a178 : fatal) !== null && _b10 !== void 0 ? _b10 : true;
            const p22 = typeof p2 === "string" ? { message: p2 } : p2;
            ctx2.addIssue({ code: "custom", ...p22, fatal: _fatal });
          }
        });
      return ZodAny.create();
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    NEVER = INVALID;
    z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY,
      OK,
      isAborted,
      isDirty,
      isValid,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      ZodReadonly,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
  }
});

// .svelte-kit/output/server/entries/pages/(authed)/_page.server.ts.js
var page_server_ts_exports = {};
__export(page_server_ts_exports, {
  actions: () => actions
});
function getChildrenIdsFromRootId(items, rootId) {
  const childrenIds = [rootId];
  let added = 1;
  while (added > 0) {
    added = 0;
    for (const item of items) {
      if (item.parentId && childrenIds.includes(item.parentId) && !childrenIds.includes(item.id)) {
        childrenIds.push(item.id);
        added++;
      }
    }
  }
  return childrenIds;
}
var import_cuid2, createItemSchema, deleteItemSchema, actions;
var init_page_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/(authed)/_page.server.ts.js"() {
    init_index3();
    import_cuid2 = __toESM(require_cuid2(), 1);
    init_chunks();
    init_drizzle_orm();
    init_lib();
    createItemSchema = z.object({
      type: z.enum(["file", "folder"]),
      parentId: z.string().optional()
    });
    deleteItemSchema = z.object({
      itemId: z.string().min(1)
    });
    actions = {
      "create-item": async ({ locals, request }) => {
        const session2 = await locals.auth.validate();
        if (!session2)
          throw error(401, "Unauthorized");
        const userId = session2.user.userId;
        const body = Object.fromEntries(await request.formData());
        const parsedBody = createItemSchema.safeParse(body);
        if (!parsedBody.success) {
          throw error(400, parsedBody.error.message);
        }
        const itemId = (0, import_cuid2.createId)();
        await db.insert(itemsTable).values({
          id: itemId,
          type: parsedBody.data.type,
          userId,
          parentId: parsedBody.data.parentId,
          name: parsedBody.data.type === "folder" ? "Untitled Folder" : "Untitled Note"
        });
        return {
          itemId
        };
      },
      "delete-item": async ({ locals, request }) => {
        const session2 = await locals.auth.validate();
        if (!session2)
          throw error(401, "Unauthorized");
        const userId = session2.user.userId;
        const body = Object.fromEntries(await request.formData());
        const parsedBody = deleteItemSchema.safeParse(body);
        if (!parsedBody.success) {
          throw error(400, parsedBody.error.message);
        }
        const items = await db.query.itemsTable.findMany({
          where: (table, { eq: eq2 }) => eq2(table.userId, userId)
        });
        const item = items.find((item2) => item2.id === parsedBody.data.itemId);
        if (!item)
          throw error(400, "Item does not exist");
        if (item.type === "file")
          await Promise.all([
            db.delete(itemsTable).where(and(eq(itemsTable.id, parsedBody.data.itemId), eq(itemsTable.userId, userId))),
            db.delete(filesTable).where(eq(filesTable.itemId, parsedBody.data.itemId))
          ]);
        else {
          const childrenIds = getChildrenIdsFromRootId(items, parsedBody.data.itemId);
          await Promise.all([
            db.delete(itemsTable).where(and(inArray(itemsTable.id, childrenIds), eq(itemsTable.userId, userId))),
            db.delete(filesTable).where(inArray(filesTable.itemId, childrenIds))
          ]);
        }
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/(authed)/_page.svelte.js
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => Page
});
var Page;
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/(authed)/_page.svelte.js"() {
    init_ssr();
    Page = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<div class="w-full h-screen flex items-center justify-center flex-col gap-5"><h2 class="font-bold" data-svelte-h="svelte-1tb4jtj">No File is Open</h2> <div class="flex flex-col gap-2 items-center text-purple-400"><button data-svelte-h="svelte-1s9jr7d">Create new file (Ctrl + J)</button> <button data-svelte-h="svelte-jg5bek">Search Files (Ctrl + O)</button></div></div> ${$$result.head += `<!-- HEAD_svelte-1fbok04_START -->${$$result.title = `<title>Vault</title>`, ""}<!-- HEAD_svelte-1fbok04_END -->`, ""}`;
    });
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  server: () => page_server_ts_exports,
  server_id: () => server_id2,
  stylesheets: () => stylesheets4
});
var index4, component_cache4, component4, server_id2, imports4, stylesheets4, fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    init_page_server_ts();
    index4 = 3;
    component4 = async () => component_cache4 ?? (component_cache4 = (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default);
    server_id2 = "src/routes/(authed)/+page.server.ts";
    imports4 = ["_app/immutable/nodes/3.784b143d.js", "_app/immutable/chunks/scheduler.e51e3a72.js", "_app/immutable/chunks/index.70313ae9.js", "_app/immutable/chunks/search.65bc8b44.js", "_app/immutable/chunks/index.6cb2aa35.js"];
    stylesheets4 = [];
    fonts4 = [];
  }
});

// .svelte-kit/output/server/entries/pages/(authed)/_itemId_/_page.server.ts.js
var page_server_ts_exports2 = {};
__export(page_server_ts_exports2, {
  load: () => load2
});
var load2;
var init_page_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/pages/(authed)/_itemId_/_page.server.ts.js"() {
    init_index3();
    init_chunks();
    load2 = async ({ locals, params }) => {
      if (!params.itemId)
        throw redirect(302, "/");
      const session2 = await locals.auth.validate();
      if (!session2)
        throw redirect(302, "/signin");
      const note = await db.query.itemsTable.findFirst({
        where: (table, { eq: eq2, and: and2 }) => and2(eq2(table.userId, session2.user.userId), eq2(table.id, params.itemId)),
        with: {
          file: true
        }
      });
      if (!note)
        throw redirect(302, "/");
      return {
        note
      };
    };
  }
});

// node_modules/.pnpm/prosemirror-model@1.19.3/node_modules/prosemirror-model/dist/index.js
function findDiffStart(a2, b, pos) {
  for (let i2 = 0; ; i2++) {
    if (i2 == a2.childCount || i2 == b.childCount)
      return a2.childCount == b.childCount ? null : pos;
    let childA = a2.child(i2), childB = b.child(i2);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j2 = 0; childA.text[j2] == childB.text[j2]; j2++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a2, b, posA, posB) {
  for (let iA = a2.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a2.child(--iA), childB = b.child(--iB), size2 = childA.nodeSize;
    if (childA == childB) {
      posA -= size2;
      posB -= size2;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size2;
    posB -= size2;
  }
}
function retIndex(index8, offset2) {
  found.index = index8;
  found.offset = offset2;
  return found;
}
function compareDeep(a2, b) {
  if (a2 === b)
    return true;
  if (!(a2 && typeof a2 == "object") || !(b && typeof b == "object"))
    return false;
  let array2 = Array.isArray(a2);
  if (Array.isArray(b) != array2)
    return false;
  if (array2) {
    if (a2.length != b.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++)
      if (!compareDeep(a2[i2], b[i2]))
        return false;
  } else {
    for (let p2 in a2)
      if (!(p2 in b) || !compareDeep(a2[p2], b[p2]))
        return false;
    for (let p2 in b)
      if (!(p2 in a2))
        return false;
  }
  return true;
}
function removeRange(content, from2, to) {
  let { index: index8, offset: offset2 } = content.findIndex(from2), child = content.maybeChild(index8);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset2 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index8 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index8, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index: index8, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index8);
  if (offset2 == dist || child.isText) {
    if (parent && !parent.canReplace(index8, index8, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset2 - 1, insert);
  return inner && content.replaceChild(index8, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index8 = $from.index(depth), node = $from.node(depth);
  if (index8 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index8, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last2 = target.length - 1;
  if (last2 >= 0 && child.isText && child.sameMarkup(target[last2]))
    target[last2] = child.withText(target[last2].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i2 = startIndex; i2 < endIndex; i2++)
    addNode(node.child(i2), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i2 = extra - 1; i2 >= 0; i2--)
    node = $along.node(i2).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
function wrapMarks(marks, str) {
  for (let i2 = marks.length - 1; i2 >= 0; i2--)
    str = marks[i2].type.name + "(" + str + ")";
  return str;
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name3) {
  let types = stream.nodeTypes, type = types[name3];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.groups.indexOf(name3) > -1)
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name3 + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect2(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect2(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i2 = 0; ; i2++) {
        let next = compile(expr2.exprs[i2], from2);
        if (i2 == expr2.exprs.length - 1)
          return next;
        connect2(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect2(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect2(compile(expr2.expr, from2), loop);
      connect2(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i2 = 0; i2 < expr2.min; i2++) {
        let next = node();
        connect2(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect2(compile(expr2.expr, cur), cur);
      } else {
        for (let i2 = expr2.min; i2 < expr2.max; i2++) {
          let next = node();
          edge(cur, next);
          connect2(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a2, b) {
  return b - a2;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i2 = 0; i2 < edges.length; i2++) {
      let { term, to } = edges[i2];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set2;
        for (let i2 = 0; i2 < out.length; i2++)
          if (out[i2][0] == term)
            set2 = out[i2][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set2)
            out.push([term, set2 = []]);
          if (set2.indexOf(node2) == -1)
            set2.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i2 = 0; i2 < out.length; i2++) {
      let states2 = out[i2][1].sort(cmp);
      state.next.push({ type: out[i2][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i2 = 0, work = [match]; i2 < work.length; i2++) {
    let state = work[i2], dead = !state.validEnd, nodes = [];
    for (let j2 = 0; j2 < state.next.length; j2++) {
      let { type, next } = state.next[j2];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults3 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults3[attrName] = attr.default;
  }
  return defaults3;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name3 in attrs) {
    let given = value && value[name3];
    if (given === void 0) {
      let attr = attrs[name3];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name3);
    }
    built[name3] = given;
  }
  return built;
}
function initAttrs(attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name3 in attrs)
      result[name3] = new Attribute(attrs[name3]);
  return result;
}
function wsOptionsFor(type, preserveWhitespace, base3) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base3 & ~OPT_OPEN_LEFT;
}
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name3 = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name3 && listTags.hasOwnProperty(name3) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name3 == "li") {
      prevItem = child;
    } else if (name3) {
      prevItem = null;
    }
  }
}
function matches2(dom, selector2) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector2);
}
function parseStyles(style) {
  let re3 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re3.exec(style))
    result.push(m[1], m[2].trim());
  return result;
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name3 in nodes) {
    let parent = nodes[name3];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i2 = 0; i2 < match.edgeCount; i2++) {
        let { type, next } = match.edge(i2);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
function findSameMarkInSet(mark, set2) {
  for (let i2 = 0; i2 < set2.length; i2++) {
    if (mark.eq(set2[i2]))
      return set2[i2];
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name3 in obj) {
    let toDOM = obj[name3].spec.toDOM;
    if (toDOM)
      result[name3] = toDOM;
  }
  return result;
}
function doc(options2) {
  return options2.document || window.document;
}
var Fragment, found, Mark, ReplaceError, Slice, ResolvedPos, resolveCache, resolveCachePos, resolveCacheSize, NodeRange, emptyAttrs, Node2, ContentMatch, TokenStream, Attribute, MarkType, DOMParser, blockTags, ignoreTags, listTags, OPT_PRESERVE_WS, OPT_PRESERVE_WS_FULL, OPT_OPEN_LEFT, NodeContext, ParseContext, DOMSerializer;
var init_dist4 = __esm({
  "node_modules/.pnpm/prosemirror-model@1.19.3/node_modules/prosemirror-model/dist/index.js"() {
    Fragment = class _Fragment {
      /**
      @internal
      */
      constructor(content, size2) {
        this.content = content;
        this.size = size2 || 0;
        if (size2 == null)
          for (let i2 = 0; i2 < content.length; i2++)
            this.size += content[i2].nodeSize;
      }
      /**
      Invoke a callback for all descendant nodes between the given two
      positions (relative to start of this fragment). Doesn't descend
      into a node when the callback returns `false`.
      */
      nodesBetween(from2, to, f, nodeStart = 0, parent) {
        for (let i2 = 0, pos = 0; pos < to; i2++) {
          let child = this.content[i2], end = pos + child.nodeSize;
          if (end > from2 && f(child, nodeStart + pos, parent || null, i2) !== false && child.content.size) {
            let start = pos + 1;
            child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to - start), f, nodeStart + start);
          }
          pos = end;
        }
      }
      /**
      Call the given callback for every descendant node. `pos` will be
      relative to the start of the fragment. The callback may return
      `false` to prevent traversal of a given node's children.
      */
      descendants(f) {
        this.nodesBetween(0, this.size, f);
      }
      /**
      Extract the text between `from` and `to`. See the same method on
      [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
      */
      textBetween(from2, to, blockSeparator, leafText) {
        let text3 = "", separated = true;
        this.nodesBetween(from2, to, (node, pos) => {
          if (node.isText) {
            text3 += node.text.slice(Math.max(from2, pos) - pos, to - pos);
            separated = !blockSeparator;
          } else if (node.isLeaf) {
            if (leafText) {
              text3 += typeof leafText === "function" ? leafText(node) : leafText;
            } else if (node.type.spec.leafText) {
              text3 += node.type.spec.leafText(node);
            }
            separated = !blockSeparator;
          } else if (!separated && node.isBlock) {
            text3 += blockSeparator;
            separated = true;
          }
        }, 0);
        return text3;
      }
      /**
      Create a new fragment containing the combined content of this
      fragment and the other.
      */
      append(other) {
        if (!other.size)
          return this;
        if (!this.size)
          return other;
        let last2 = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i2 = 0;
        if (last2.isText && last2.sameMarkup(first2)) {
          content[content.length - 1] = last2.withText(last2.text + first2.text);
          i2 = 1;
        }
        for (; i2 < other.content.length; i2++)
          content.push(other.content[i2]);
        return new _Fragment(content, this.size + other.size);
      }
      /**
      Cut out the sub-fragment between the two given positions.
      */
      cut(from2, to = this.size) {
        if (from2 == 0 && to == this.size)
          return this;
        let result = [], size2 = 0;
        if (to > from2)
          for (let i2 = 0, pos = 0; pos < to; i2++) {
            let child = this.content[i2], end = pos + child.nodeSize;
            if (end > from2) {
              if (pos < from2 || end > to) {
                if (child.isText)
                  child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
                else
                  child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
              }
              result.push(child);
              size2 += child.nodeSize;
            }
            pos = end;
          }
        return new _Fragment(result, size2);
      }
      /**
      @internal
      */
      cutByIndex(from2, to) {
        if (from2 == to)
          return _Fragment.empty;
        if (from2 == 0 && to == this.content.length)
          return this;
        return new _Fragment(this.content.slice(from2, to));
      }
      /**
      Create a new fragment in which the node at the given index is
      replaced by the given node.
      */
      replaceChild(index8, node) {
        let current = this.content[index8];
        if (current == node)
          return this;
        let copy2 = this.content.slice();
        let size2 = this.size + node.nodeSize - current.nodeSize;
        copy2[index8] = node;
        return new _Fragment(copy2, size2);
      }
      /**
      Create a new fragment by prepending the given node to this
      fragment.
      */
      addToStart(node) {
        return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
      }
      /**
      Create a new fragment by appending the given node to this
      fragment.
      */
      addToEnd(node) {
        return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
      }
      /**
      Compare this fragment to another one.
      */
      eq(other) {
        if (this.content.length != other.content.length)
          return false;
        for (let i2 = 0; i2 < this.content.length; i2++)
          if (!this.content[i2].eq(other.content[i2]))
            return false;
        return true;
      }
      /**
      The first child of the fragment, or `null` if it is empty.
      */
      get firstChild() {
        return this.content.length ? this.content[0] : null;
      }
      /**
      The last child of the fragment, or `null` if it is empty.
      */
      get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
      /**
      The number of child nodes in this fragment.
      */
      get childCount() {
        return this.content.length;
      }
      /**
      Get the child node at the given index. Raise an error when the
      index is out of range.
      */
      child(index8) {
        let found2 = this.content[index8];
        if (!found2)
          throw new RangeError("Index " + index8 + " out of range for " + this);
        return found2;
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(index8) {
        return this.content[index8] || null;
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(f) {
        for (let i2 = 0, p2 = 0; i2 < this.content.length; i2++) {
          let child = this.content[i2];
          f(child, p2, i2);
          p2 += child.nodeSize;
        }
      }
      /**
      Find the first position at which this fragment and another
      fragment differ, or `null` if they are the same.
      */
      findDiffStart(other, pos = 0) {
        return findDiffStart(this, other, pos);
      }
      /**
      Find the first position, searching from the end, at which this
      fragment and the given fragment differ, or `null` if they are
      the same. Since this position will not be the same in both
      nodes, an object with two separate positions is returned.
      */
      findDiffEnd(other, pos = this.size, otherPos = other.size) {
        return findDiffEnd(this, other, pos, otherPos);
      }
      /**
      Find the index and inner offset corresponding to a given relative
      position in this fragment. The result object will be reused
      (overwritten) the next time the function is called. (Not public.)
      */
      findIndex(pos, round2 = -1) {
        if (pos == 0)
          return retIndex(0, pos);
        if (pos == this.size)
          return retIndex(this.content.length, pos);
        if (pos > this.size || pos < 0)
          throw new RangeError(`Position ${pos} outside of fragment (${this})`);
        for (let i2 = 0, curPos = 0; ; i2++) {
          let cur = this.child(i2), end = curPos + cur.nodeSize;
          if (end >= pos) {
            if (end == pos || round2 > 0)
              return retIndex(i2 + 1, end);
            return retIndex(i2, curPos);
          }
          curPos = end;
        }
      }
      /**
      Return a debugging string that describes this fragment.
      */
      toString() {
        return "<" + this.toStringInner() + ">";
      }
      /**
      @internal
      */
      toStringInner() {
        return this.content.join(", ");
      }
      /**
      Create a JSON-serializeable representation of this fragment.
      */
      toJSON() {
        return this.content.length ? this.content.map((n) => n.toJSON()) : null;
      }
      /**
      Deserialize a fragment from its JSON representation.
      */
      static fromJSON(schema3, value) {
        if (!value)
          return _Fragment.empty;
        if (!Array.isArray(value))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new _Fragment(value.map(schema3.nodeFromJSON));
      }
      /**
      Build a fragment from an array of nodes. Ensures that adjacent
      text nodes with the same marks are joined together.
      */
      static fromArray(array2) {
        if (!array2.length)
          return _Fragment.empty;
        let joined, size2 = 0;
        for (let i2 = 0; i2 < array2.length; i2++) {
          let node = array2[i2];
          size2 += node.nodeSize;
          if (i2 && node.isText && array2[i2 - 1].sameMarkup(node)) {
            if (!joined)
              joined = array2.slice(0, i2);
            joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
          } else if (joined) {
            joined.push(node);
          }
        }
        return new _Fragment(joined || array2, size2);
      }
      /**
      Create a fragment from something that can be interpreted as a
      set of nodes. For `null`, it returns the empty fragment. For a
      fragment, the fragment itself. For a node or array of nodes, a
      fragment containing those nodes.
      */
      static from(nodes) {
        if (!nodes)
          return _Fragment.empty;
        if (nodes instanceof _Fragment)
          return nodes;
        if (Array.isArray(nodes))
          return this.fromArray(nodes);
        if (nodes.attrs)
          return new _Fragment([nodes], nodes.nodeSize);
        throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    };
    Fragment.empty = new Fragment([], 0);
    found = { index: 0, offset: 0 };
    Mark = class _Mark {
      /**
      @internal
      */
      constructor(type, attrs) {
        this.type = type;
        this.attrs = attrs;
      }
      /**
      Given a set of marks, create a new set which contains this one as
      well, in the right position. If this mark is already in the set,
      the set itself is returned. If any marks that are set to be
      [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
      those are replaced by this one.
      */
      addToSet(set2) {
        let copy2, placed = false;
        for (let i2 = 0; i2 < set2.length; i2++) {
          let other = set2[i2];
          if (this.eq(other))
            return set2;
          if (this.type.excludes(other.type)) {
            if (!copy2)
              copy2 = set2.slice(0, i2);
          } else if (other.type.excludes(this.type)) {
            return set2;
          } else {
            if (!placed && other.type.rank > this.type.rank) {
              if (!copy2)
                copy2 = set2.slice(0, i2);
              copy2.push(this);
              placed = true;
            }
            if (copy2)
              copy2.push(other);
          }
        }
        if (!copy2)
          copy2 = set2.slice();
        if (!placed)
          copy2.push(this);
        return copy2;
      }
      /**
      Remove this mark from the given set, returning a new set. If this
      mark is not in the set, the set itself is returned.
      */
      removeFromSet(set2) {
        for (let i2 = 0; i2 < set2.length; i2++)
          if (this.eq(set2[i2]))
            return set2.slice(0, i2).concat(set2.slice(i2 + 1));
        return set2;
      }
      /**
      Test whether this mark is in the given set of marks.
      */
      isInSet(set2) {
        for (let i2 = 0; i2 < set2.length; i2++)
          if (this.eq(set2[i2]))
            return true;
        return false;
      }
      /**
      Test whether this mark has the same type and attributes as
      another mark.
      */
      eq(other) {
        return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
      }
      /**
      Convert this mark to a JSON-serializeable representation.
      */
      toJSON() {
        let obj = { type: this.type.name };
        for (let _ in this.attrs) {
          obj.attrs = this.attrs;
          break;
        }
        return obj;
      }
      /**
      Deserialize a mark from JSON.
      */
      static fromJSON(schema3, json2) {
        if (!json2)
          throw new RangeError("Invalid input for Mark.fromJSON");
        let type = schema3.marks[json2.type];
        if (!type)
          throw new RangeError(`There is no mark type ${json2.type} in this schema`);
        return type.create(json2.attrs);
      }
      /**
      Test whether two sets of marks are identical.
      */
      static sameSet(a2, b) {
        if (a2 == b)
          return true;
        if (a2.length != b.length)
          return false;
        for (let i2 = 0; i2 < a2.length; i2++)
          if (!a2[i2].eq(b[i2]))
            return false;
        return true;
      }
      /**
      Create a properly sorted mark set from null, a single mark, or an
      unsorted array of marks.
      */
      static setFrom(marks) {
        if (!marks || Array.isArray(marks) && marks.length == 0)
          return _Mark.none;
        if (marks instanceof _Mark)
          return [marks];
        let copy2 = marks.slice();
        copy2.sort((a2, b) => a2.type.rank - b.type.rank);
        return copy2;
      }
    };
    Mark.none = [];
    ReplaceError = class extends Error {
    };
    Slice = class _Slice {
      /**
      Create a slice. When specifying a non-zero open depth, you must
      make sure that there are nodes of at least that depth at the
      appropriate side of the fragment—i.e. if the fragment is an
      empty paragraph node, `openStart` and `openEnd` can't be greater
      than 1.
      
      It is not necessary for the content of open nodes to conform to
      the schema's content constraints, though it should be a valid
      start/end/middle for such a node, depending on which sides are
      open.
      */
      constructor(content, openStart, openEnd) {
        this.content = content;
        this.openStart = openStart;
        this.openEnd = openEnd;
      }
      /**
      The size this slice would add when inserted into a document.
      */
      get size() {
        return this.content.size - this.openStart - this.openEnd;
      }
      /**
      @internal
      */
      insertAt(pos, fragment) {
        let content = insertInto(this.content, pos + this.openStart, fragment);
        return content && new _Slice(content, this.openStart, this.openEnd);
      }
      /**
      @internal
      */
      removeBetween(from2, to) {
        return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
      }
      /**
      Tests whether this slice is equal to another slice.
      */
      eq(other) {
        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
      }
      /**
      @internal
      */
      toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
      /**
      Convert a slice to a JSON-serializable representation.
      */
      toJSON() {
        if (!this.content.size)
          return null;
        let json2 = { content: this.content.toJSON() };
        if (this.openStart > 0)
          json2.openStart = this.openStart;
        if (this.openEnd > 0)
          json2.openEnd = this.openEnd;
        return json2;
      }
      /**
      Deserialize a slice from its JSON representation.
      */
      static fromJSON(schema3, json2) {
        if (!json2)
          return _Slice.empty;
        let openStart = json2.openStart || 0, openEnd = json2.openEnd || 0;
        if (typeof openStart != "number" || typeof openEnd != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new _Slice(Fragment.fromJSON(schema3, json2.content), openStart, openEnd);
      }
      /**
      Create a slice from a fragment by taking the maximum possible
      open value on both side of the fragment.
      */
      static maxOpen(fragment, openIsolating = true) {
        let openStart = 0, openEnd = 0;
        for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
          openStart++;
        for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
          openEnd++;
        return new _Slice(fragment, openStart, openEnd);
      }
    };
    Slice.empty = new Slice(Fragment.empty, 0, 0);
    ResolvedPos = class _ResolvedPos {
      /**
      @internal
      */
      constructor(pos, path, parentOffset) {
        this.pos = pos;
        this.path = path;
        this.parentOffset = parentOffset;
        this.depth = path.length / 3 - 1;
      }
      /**
      @internal
      */
      resolveDepth(val) {
        if (val == null)
          return this.depth;
        if (val < 0)
          return this.depth + val;
        return val;
      }
      /**
      The parent node that the position points into. Note that even if
      a position points into a text node, that node is not considered
      the parent—text nodes are ‘flat’ in this model, and have no content.
      */
      get parent() {
        return this.node(this.depth);
      }
      /**
      The root node in which the position was resolved.
      */
      get doc() {
        return this.node(0);
      }
      /**
      The ancestor node at the given level. `p.node(p.depth)` is the
      same as `p.parent`.
      */
      node(depth) {
        return this.path[this.resolveDepth(depth) * 3];
      }
      /**
      The index into the ancestor at the given level. If this points
      at the 3rd node in the 2nd paragraph on the top level, for
      example, `p.index(0)` is 1 and `p.index(1)` is 2.
      */
      index(depth) {
        return this.path[this.resolveDepth(depth) * 3 + 1];
      }
      /**
      The index pointing after this position into the ancestor at the
      given level.
      */
      indexAfter(depth) {
        depth = this.resolveDepth(depth);
        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
      }
      /**
      The (absolute) position at the start of the node at the given
      level.
      */
      start(depth) {
        depth = this.resolveDepth(depth);
        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      }
      /**
      The (absolute) position at the end of the node at the given
      level.
      */
      end(depth) {
        depth = this.resolveDepth(depth);
        return this.start(depth) + this.node(depth).content.size;
      }
      /**
      The (absolute) position directly before the wrapping node at the
      given level, or, when `depth` is `this.depth + 1`, the original
      position.
      */
      before(depth) {
        depth = this.resolveDepth(depth);
        if (!depth)
          throw new RangeError("There is no position before the top-level node");
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
      }
      /**
      The (absolute) position directly after the wrapping node at the
      given level, or the original position when `depth` is `this.depth + 1`.
      */
      after(depth) {
        depth = this.resolveDepth(depth);
        if (!depth)
          throw new RangeError("There is no position after the top-level node");
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
      }
      /**
      When this position points into a text node, this returns the
      distance between the position and the start of the text node.
      Will be zero for positions that point between nodes.
      */
      get textOffset() {
        return this.pos - this.path[this.path.length - 1];
      }
      /**
      Get the node directly after the position, if any. If the position
      points into a text node, only the part of that node after the
      position is returned.
      */
      get nodeAfter() {
        let parent = this.parent, index8 = this.index(this.depth);
        if (index8 == parent.childCount)
          return null;
        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index8);
        return dOff ? parent.child(index8).cut(dOff) : child;
      }
      /**
      Get the node directly before the position, if any. If the
      position points into a text node, only the part of that node
      before the position is returned.
      */
      get nodeBefore() {
        let index8 = this.index(this.depth);
        let dOff = this.pos - this.path[this.path.length - 1];
        if (dOff)
          return this.parent.child(index8).cut(0, dOff);
        return index8 == 0 ? null : this.parent.child(index8 - 1);
      }
      /**
      Get the position at the given index in the parent node at the
      given depth (which defaults to `this.depth`).
      */
      posAtIndex(index8, depth) {
        depth = this.resolveDepth(depth);
        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
        for (let i2 = 0; i2 < index8; i2++)
          pos += node.child(i2).nodeSize;
        return pos;
      }
      /**
      Get the marks at this position, factoring in the surrounding
      marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
      position is at the start of a non-empty node, the marks of the
      node after it (if any) are returned.
      */
      marks() {
        let parent = this.parent, index8 = this.index();
        if (parent.content.size == 0)
          return Mark.none;
        if (this.textOffset)
          return parent.child(index8).marks;
        let main = parent.maybeChild(index8 - 1), other = parent.maybeChild(index8);
        if (!main) {
          let tmp = main;
          main = other;
          other = tmp;
        }
        let marks = main.marks;
        for (var i2 = 0; i2 < marks.length; i2++)
          if (marks[i2].type.spec.inclusive === false && (!other || !marks[i2].isInSet(other.marks)))
            marks = marks[i2--].removeFromSet(marks);
        return marks;
      }
      /**
      Get the marks after the current position, if any, except those
      that are non-inclusive and not present at position `$end`. This
      is mostly useful for getting the set of marks to preserve after a
      deletion. Will return `null` if this position is at the end of
      its parent node or its parent node isn't a textblock (in which
      case no marks should be preserved).
      */
      marksAcross($end) {
        let after = this.parent.maybeChild(this.index());
        if (!after || !after.isInline)
          return null;
        let marks = after.marks, next = $end.parent.maybeChild($end.index());
        for (var i2 = 0; i2 < marks.length; i2++)
          if (marks[i2].type.spec.inclusive === false && (!next || !marks[i2].isInSet(next.marks)))
            marks = marks[i2--].removeFromSet(marks);
        return marks;
      }
      /**
      The depth up to which this position and the given (non-resolved)
      position share the same parent nodes.
      */
      sharedDepth(pos) {
        for (let depth = this.depth; depth > 0; depth--)
          if (this.start(depth) <= pos && this.end(depth) >= pos)
            return depth;
        return 0;
      }
      /**
      Returns a range based on the place where this position and the
      given position diverge around block content. If both point into
      the same textblock, for example, a range around that textblock
      will be returned. If they point into different blocks, the range
      around those blocks in their shared ancestor is returned. You can
      pass in an optional predicate that will be called with a parent
      node to see if a range into that parent is acceptable.
      */
      blockRange(other = this, pred) {
        if (other.pos < this.pos)
          return other.blockRange(this);
        for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
          if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
            return new NodeRange(this, other, d);
        return null;
      }
      /**
      Query whether the given position shares the same parent node.
      */
      sameParent(other) {
        return this.pos - this.parentOffset == other.pos - other.parentOffset;
      }
      /**
      Return the greater of this and the given position.
      */
      max(other) {
        return other.pos > this.pos ? other : this;
      }
      /**
      Return the smaller of this and the given position.
      */
      min(other) {
        return other.pos < this.pos ? other : this;
      }
      /**
      @internal
      */
      toString() {
        let str = "";
        for (let i2 = 1; i2 <= this.depth; i2++)
          str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
        return str + ":" + this.parentOffset;
      }
      /**
      @internal
      */
      static resolve(doc3, pos) {
        if (!(pos >= 0 && pos <= doc3.content.size))
          throw new RangeError("Position " + pos + " out of range");
        let path = [];
        let start = 0, parentOffset = pos;
        for (let node = doc3; ; ) {
          let { index: index8, offset: offset2 } = node.content.findIndex(parentOffset);
          let rem = parentOffset - offset2;
          path.push(node, index8, start + offset2);
          if (!rem)
            break;
          node = node.child(index8);
          if (node.isText)
            break;
          parentOffset = rem - 1;
          start += offset2 + 1;
        }
        return new _ResolvedPos(pos, path, parentOffset);
      }
      /**
      @internal
      */
      static resolveCached(doc3, pos) {
        for (let i2 = 0; i2 < resolveCache.length; i2++) {
          let cached = resolveCache[i2];
          if (cached.pos == pos && cached.doc == doc3)
            return cached;
        }
        let result = resolveCache[resolveCachePos] = _ResolvedPos.resolve(doc3, pos);
        resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
        return result;
      }
    };
    resolveCache = [];
    resolveCachePos = 0;
    resolveCacheSize = 12;
    NodeRange = class {
      /**
      Construct a node range. `$from` and `$to` should point into the
      same node until at least the given `depth`, since a node range
      denotes an adjacent set of nodes in a single parent node.
      */
      constructor($from, $to, depth) {
        this.$from = $from;
        this.$to = $to;
        this.depth = depth;
      }
      /**
      The position at the start of the range.
      */
      get start() {
        return this.$from.before(this.depth + 1);
      }
      /**
      The position at the end of the range.
      */
      get end() {
        return this.$to.after(this.depth + 1);
      }
      /**
      The parent node that the range points into.
      */
      get parent() {
        return this.$from.node(this.depth);
      }
      /**
      The start index of the range in the parent node.
      */
      get startIndex() {
        return this.$from.index(this.depth);
      }
      /**
      The end index of the range in the parent node.
      */
      get endIndex() {
        return this.$to.indexAfter(this.depth);
      }
    };
    emptyAttrs = /* @__PURE__ */ Object.create(null);
    Node2 = class _Node {
      /**
      @internal
      */
      constructor(type, attrs, content, marks = Mark.none) {
        this.type = type;
        this.attrs = attrs;
        this.marks = marks;
        this.content = content || Fragment.empty;
      }
      /**
      The size of this node, as defined by the integer-based [indexing
      scheme](/docs/guide/#doc.indexing). For text nodes, this is the
      amount of characters. For other leaf nodes, it is one. For
      non-leaf nodes, it is the size of the content plus two (the
      start and end token).
      */
      get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
      /**
      The number of children that the node has.
      */
      get childCount() {
        return this.content.childCount;
      }
      /**
      Get the child node at the given index. Raises an error when the
      index is out of range.
      */
      child(index8) {
        return this.content.child(index8);
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(index8) {
        return this.content.maybeChild(index8);
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(f) {
        this.content.forEach(f);
      }
      /**
      Invoke a callback for all descendant nodes recursively between
      the given two positions that are relative to start of this
      node's content. The callback is invoked with the node, its
      position relative to the original node (method receiver),
      its parent node, and its child index. When the callback returns
      false for a given node, that node's children will not be
      recursed over. The last parameter can be used to specify a
      starting position to count from.
      */
      nodesBetween(from2, to, f, startPos = 0) {
        this.content.nodesBetween(from2, to, f, startPos, this);
      }
      /**
      Call the given callback for every descendant node. Doesn't
      descend into a node when the callback returns `false`.
      */
      descendants(f) {
        this.nodesBetween(0, this.content.size, f);
      }
      /**
      Concatenates all the text nodes found in this fragment and its
      children.
      */
      get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
      /**
      Get all text between positions `from` and `to`. When
      `blockSeparator` is given, it will be inserted to separate text
      from different block nodes. If `leafText` is given, it'll be
      inserted for every non-text leaf node encountered, otherwise
      [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
      */
      textBetween(from2, to, blockSeparator, leafText) {
        return this.content.textBetween(from2, to, blockSeparator, leafText);
      }
      /**
      Returns this node's first child, or `null` if there are no
      children.
      */
      get firstChild() {
        return this.content.firstChild;
      }
      /**
      Returns this node's last child, or `null` if there are no
      children.
      */
      get lastChild() {
        return this.content.lastChild;
      }
      /**
      Test whether two nodes represent the same piece of document.
      */
      eq(other) {
        return this == other || this.sameMarkup(other) && this.content.eq(other.content);
      }
      /**
      Compare the markup (type, attributes, and marks) of this node to
      those of another. Returns `true` if both have the same markup.
      */
      sameMarkup(other) {
        return this.hasMarkup(other.type, other.attrs, other.marks);
      }
      /**
      Check whether this node's markup correspond to the given type,
      attributes, and marks.
      */
      hasMarkup(type, attrs, marks) {
        return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
      }
      /**
      Create a new node with the same markup as this node, containing
      the given content (or empty, if no content is given).
      */
      copy(content = null) {
        if (content == this.content)
          return this;
        return new _Node(this.type, this.attrs, content, this.marks);
      }
      /**
      Create a copy of this node, with the given set of marks instead
      of the node's own marks.
      */
      mark(marks) {
        return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
      }
      /**
      Create a copy of this node with only the content between the
      given positions. If `to` is not given, it defaults to the end of
      the node.
      */
      cut(from2, to = this.content.size) {
        if (from2 == 0 && to == this.content.size)
          return this;
        return this.copy(this.content.cut(from2, to));
      }
      /**
      Cut out the part of the document between the given positions, and
      return it as a `Slice` object.
      */
      slice(from2, to = this.content.size, includeParents = false) {
        if (from2 == to)
          return Slice.empty;
        let $from = this.resolve(from2), $to = this.resolve(to);
        let depth = includeParents ? 0 : $from.sharedDepth(to);
        let start = $from.start(depth), node = $from.node(depth);
        let content = node.content.cut($from.pos - start, $to.pos - start);
        return new Slice(content, $from.depth - depth, $to.depth - depth);
      }
      /**
      Replace the part of the document between the given positions with
      the given slice. The slice must 'fit', meaning its open sides
      must be able to connect to the surrounding content, and its
      content nodes must be valid children for the node they are placed
      into. If any of this is violated, an error of type
      [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
      */
      replace(from2, to, slice2) {
        return replace(this.resolve(from2), this.resolve(to), slice2);
      }
      /**
      Find the node directly after the given position.
      */
      nodeAt(pos) {
        for (let node = this; ; ) {
          let { index: index8, offset: offset2 } = node.content.findIndex(pos);
          node = node.maybeChild(index8);
          if (!node)
            return null;
          if (offset2 == pos || node.isText)
            return node;
          pos -= offset2 + 1;
        }
      }
      /**
      Find the (direct) child node after the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childAfter(pos) {
        let { index: index8, offset: offset2 } = this.content.findIndex(pos);
        return { node: this.content.maybeChild(index8), index: index8, offset: offset2 };
      }
      /**
      Find the (direct) child node before the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childBefore(pos) {
        if (pos == 0)
          return { node: null, index: 0, offset: 0 };
        let { index: index8, offset: offset2 } = this.content.findIndex(pos);
        if (offset2 < pos)
          return { node: this.content.child(index8), index: index8, offset: offset2 };
        let node = this.content.child(index8 - 1);
        return { node, index: index8 - 1, offset: offset2 - node.nodeSize };
      }
      /**
      Resolve the given position in the document, returning an
      [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
      */
      resolve(pos) {
        return ResolvedPos.resolveCached(this, pos);
      }
      /**
      @internal
      */
      resolveNoCache(pos) {
        return ResolvedPos.resolve(this, pos);
      }
      /**
      Test whether a given mark or mark type occurs in this document
      between the two given positions.
      */
      rangeHasMark(from2, to, type) {
        let found2 = false;
        if (to > from2)
          this.nodesBetween(from2, to, (node) => {
            if (type.isInSet(node.marks))
              found2 = true;
            return !found2;
          });
        return found2;
      }
      /**
      True when this is a block (non-inline node)
      */
      get isBlock() {
        return this.type.isBlock;
      }
      /**
      True when this is a textblock node, a block node with inline
      content.
      */
      get isTextblock() {
        return this.type.isTextblock;
      }
      /**
      True when this node allows inline content.
      */
      get inlineContent() {
        return this.type.inlineContent;
      }
      /**
      True when this is an inline node (a text node or a node that can
      appear among text).
      */
      get isInline() {
        return this.type.isInline;
      }
      /**
      True when this is a text node.
      */
      get isText() {
        return this.type.isText;
      }
      /**
      True when this is a leaf node.
      */
      get isLeaf() {
        return this.type.isLeaf;
      }
      /**
      True when this is an atom, i.e. when it does not have directly
      editable content. This is usually the same as `isLeaf`, but can
      be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
      on a node's spec (typically used when the node is displayed as
      an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
      */
      get isAtom() {
        return this.type.isAtom;
      }
      /**
      Return a string representation of this node for debugging
      purposes.
      */
      toString() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        let name3 = this.type.name;
        if (this.content.size)
          name3 += "(" + this.content.toStringInner() + ")";
        return wrapMarks(this.marks, name3);
      }
      /**
      Get the content match in this node at the given index.
      */
      contentMatchAt(index8) {
        let match = this.type.contentMatch.matchFragment(this.content, 0, index8);
        if (!match)
          throw new Error("Called contentMatchAt on a node with invalid content");
        return match;
      }
      /**
      Test whether replacing the range between `from` and `to` (by
      child index) with the given replacement fragment (which defaults
      to the empty fragment) would leave the node's content valid. You
      can optionally pass `start` and `end` indices into the
      replacement fragment.
      */
      canReplace(from2, to, replacement2 = Fragment.empty, start = 0, end = replacement2.childCount) {
        let one = this.contentMatchAt(from2).matchFragment(replacement2, start, end);
        let two = one && one.matchFragment(this.content, to);
        if (!two || !two.validEnd)
          return false;
        for (let i2 = start; i2 < end; i2++)
          if (!this.type.allowsMarks(replacement2.child(i2).marks))
            return false;
        return true;
      }
      /**
      Test whether replacing the range `from` to `to` (by index) with
      a node of the given type would leave the node's content valid.
      */
      canReplaceWith(from2, to, type, marks) {
        if (marks && !this.type.allowsMarks(marks))
          return false;
        let start = this.contentMatchAt(from2).matchType(type);
        let end = start && start.matchFragment(this.content, to);
        return end ? end.validEnd : false;
      }
      /**
      Test whether the given node's content could be appended to this
      node. If that node is empty, this will only return true if there
      is at least one node type that can appear in both nodes (to avoid
      merging completely incompatible nodes).
      */
      canAppend(other) {
        if (other.content.size)
          return this.canReplace(this.childCount, this.childCount, other.content);
        else
          return this.type.compatibleContent(other.type);
      }
      /**
      Check whether this node and its descendants conform to the
      schema, and raise error when they do not.
      */
      check() {
        this.type.checkContent(this.content);
        let copy2 = Mark.none;
        for (let i2 = 0; i2 < this.marks.length; i2++)
          copy2 = this.marks[i2].addToSet(copy2);
        if (!Mark.sameSet(copy2, this.marks))
          throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
        this.content.forEach((node) => node.check());
      }
      /**
      Return a JSON-serializeable representation of this node.
      */
      toJSON() {
        let obj = { type: this.type.name };
        for (let _ in this.attrs) {
          obj.attrs = this.attrs;
          break;
        }
        if (this.content.size)
          obj.content = this.content.toJSON();
        if (this.marks.length)
          obj.marks = this.marks.map((n) => n.toJSON());
        return obj;
      }
      /**
      Deserialize a node from its JSON representation.
      */
      static fromJSON(schema3, json2) {
        if (!json2)
          throw new RangeError("Invalid input for Node.fromJSON");
        let marks = null;
        if (json2.marks) {
          if (!Array.isArray(json2.marks))
            throw new RangeError("Invalid mark data for Node.fromJSON");
          marks = json2.marks.map(schema3.markFromJSON);
        }
        if (json2.type == "text") {
          if (typeof json2.text != "string")
            throw new RangeError("Invalid text node in JSON");
          return schema3.text(json2.text, marks);
        }
        let content = Fragment.fromJSON(schema3, json2.content);
        return schema3.nodeType(json2.type).create(json2.attrs, content, marks);
      }
    };
    Node2.prototype.text = void 0;
    ContentMatch = class _ContentMatch {
      /**
      @internal
      */
      constructor(validEnd) {
        this.validEnd = validEnd;
        this.next = [];
        this.wrapCache = [];
      }
      /**
      @internal
      */
      static parse(string, nodeTypes) {
        let stream = new TokenStream(string, nodeTypes);
        if (stream.next == null)
          return _ContentMatch.empty;
        let expr = parseExpr(stream);
        if (stream.next)
          stream.err("Unexpected trailing text");
        let match = dfa(nfa(expr));
        checkForDeadEnds(match, stream);
        return match;
      }
      /**
      Match a node type, returning a match after that node if
      successful.
      */
      matchType(type) {
        for (let i2 = 0; i2 < this.next.length; i2++)
          if (this.next[i2].type == type)
            return this.next[i2].next;
        return null;
      }
      /**
      Try to match a fragment. Returns the resulting match when
      successful.
      */
      matchFragment(frag, start = 0, end = frag.childCount) {
        let cur = this;
        for (let i2 = start; cur && i2 < end; i2++)
          cur = cur.matchType(frag.child(i2).type);
        return cur;
      }
      /**
      @internal
      */
      get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
      /**
      Get the first matching node type at this match position that can
      be generated.
      */
      get defaultType() {
        for (let i2 = 0; i2 < this.next.length; i2++) {
          let { type } = this.next[i2];
          if (!(type.isText || type.hasRequiredAttrs()))
            return type;
        }
        return null;
      }
      /**
      @internal
      */
      compatible(other) {
        for (let i2 = 0; i2 < this.next.length; i2++)
          for (let j2 = 0; j2 < other.next.length; j2++)
            if (this.next[i2].type == other.next[j2].type)
              return true;
        return false;
      }
      /**
      Try to match the given fragment, and if that fails, see if it can
      be made to match by inserting nodes in front of it. When
      successful, return a fragment of inserted nodes (which may be
      empty if nothing had to be inserted). When `toEnd` is true, only
      return a fragment if the resulting match goes to the end of the
      content expression.
      */
      fillBefore(after, toEnd = false, startIndex = 0) {
        let seen = [this];
        function search(match, types) {
          let finished = match.matchFragment(after, startIndex);
          if (finished && (!toEnd || finished.validEnd))
            return Fragment.from(types.map((tp) => tp.createAndFill()));
          for (let i2 = 0; i2 < match.next.length; i2++) {
            let { type, next } = match.next[i2];
            if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
              seen.push(next);
              let found2 = search(next, types.concat(type));
              if (found2)
                return found2;
            }
          }
          return null;
        }
        return search(this, []);
      }
      /**
      Find a set of wrapping node types that would allow a node of the
      given type to appear at this position. The result may be empty
      (when it fits directly) and will be null when no such wrapping
      exists.
      */
      findWrapping(target) {
        for (let i2 = 0; i2 < this.wrapCache.length; i2 += 2)
          if (this.wrapCache[i2] == target)
            return this.wrapCache[i2 + 1];
        let computed = this.computeWrapping(target);
        this.wrapCache.push(target, computed);
        return computed;
      }
      /**
      @internal
      */
      computeWrapping(target) {
        let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
        while (active.length) {
          let current = active.shift(), match = current.match;
          if (match.matchType(target)) {
            let result = [];
            for (let obj = current; obj.type; obj = obj.via)
              result.push(obj.type);
            return result.reverse();
          }
          for (let i2 = 0; i2 < match.next.length; i2++) {
            let { type, next } = match.next[i2];
            if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
              active.push({ match: type.contentMatch, type, via: current });
              seen[type.name] = true;
            }
          }
        }
        return null;
      }
      /**
      The number of outgoing edges this node has in the finite
      automaton that describes the content expression.
      */
      get edgeCount() {
        return this.next.length;
      }
      /**
      Get the _n_​th outgoing edge from this node in the finite
      automaton that describes the content expression.
      */
      edge(n) {
        if (n >= this.next.length)
          throw new RangeError(`There's no ${n}th edge in this content match`);
        return this.next[n];
      }
      /**
      @internal
      */
      toString() {
        let seen = [];
        function scan(m) {
          seen.push(m);
          for (let i2 = 0; i2 < m.next.length; i2++)
            if (seen.indexOf(m.next[i2].next) == -1)
              scan(m.next[i2].next);
        }
        scan(this);
        return seen.map((m, i2) => {
          let out = i2 + (m.validEnd ? "*" : " ") + " ";
          for (let i3 = 0; i3 < m.next.length; i3++)
            out += (i3 ? ", " : "") + m.next[i3].type.name + "->" + seen.indexOf(m.next[i3].next);
          return out;
        }).join("\n");
      }
    };
    ContentMatch.empty = new ContentMatch(true);
    TokenStream = class {
      constructor(string, nodeTypes) {
        this.string = string;
        this.nodeTypes = nodeTypes;
        this.inline = null;
        this.pos = 0;
        this.tokens = string.split(/\s*(?=\b|\W|$)/);
        if (this.tokens[this.tokens.length - 1] == "")
          this.tokens.pop();
        if (this.tokens[0] == "")
          this.tokens.shift();
      }
      get next() {
        return this.tokens[this.pos];
      }
      eat(tok) {
        return this.next == tok && (this.pos++ || true);
      }
      err(str) {
        throw new SyntaxError(str + " (in content expression '" + this.string + "')");
      }
    };
    Attribute = class {
      constructor(options2) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(options2, "default");
        this.default = options2.default;
      }
      get isRequired() {
        return !this.hasDefault;
      }
    };
    MarkType = class _MarkType {
      /**
      @internal
      */
      constructor(name3, rank, schema3, spec) {
        this.name = name3;
        this.rank = rank;
        this.schema = schema3;
        this.spec = spec;
        this.attrs = initAttrs(spec.attrs);
        this.excluded = null;
        let defaults3 = defaultAttrs(this.attrs);
        this.instance = defaults3 ? new Mark(this, defaults3) : null;
      }
      /**
      Create a mark of this type. `attrs` may be `null` or an object
      containing only some of the mark's attributes. The others, if
      they have defaults, will be added.
      */
      create(attrs = null) {
        if (!attrs && this.instance)
          return this.instance;
        return new Mark(this, computeAttrs(this.attrs, attrs));
      }
      /**
      @internal
      */
      static compile(marks, schema3) {
        let result = /* @__PURE__ */ Object.create(null), rank = 0;
        marks.forEach((name3, spec) => result[name3] = new _MarkType(name3, rank++, schema3, spec));
        return result;
      }
      /**
      When there is a mark of this type in the given set, a new set
      without it is returned. Otherwise, the input set is returned.
      */
      removeFromSet(set2) {
        for (var i2 = 0; i2 < set2.length; i2++)
          if (set2[i2].type == this) {
            set2 = set2.slice(0, i2).concat(set2.slice(i2 + 1));
            i2--;
          }
        return set2;
      }
      /**
      Tests whether there is a mark of this type in the given set.
      */
      isInSet(set2) {
        for (let i2 = 0; i2 < set2.length; i2++)
          if (set2[i2].type == this)
            return set2[i2];
      }
      /**
      Queries whether a given mark type is
      [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
      */
      excludes(other) {
        return this.excluded.indexOf(other) > -1;
      }
    };
    DOMParser = class _DOMParser {
      /**
      Create a parser that targets the given schema, using the given
      parsing rules.
      */
      constructor(schema3, rules) {
        this.schema = schema3;
        this.rules = rules;
        this.tags = [];
        this.styles = [];
        rules.forEach((rule) => {
          if (rule.tag)
            this.tags.push(rule);
          else if (rule.style)
            this.styles.push(rule);
        });
        this.normalizeLists = !this.tags.some((r2) => {
          if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
            return false;
          let node = schema3.nodes[r2.node];
          return node.contentMatch.matchType(node);
        });
      }
      /**
      Parse a document from the content of a DOM node.
      */
      parse(dom, options2 = {}) {
        let context = new ParseContext(this, options2, false);
        context.addAll(dom, options2.from, options2.to);
        return context.finish();
      }
      /**
      Parses the content of the given DOM node, like
      [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
      options. But unlike that method, which produces a whole node,
      this one returns a slice that is open at the sides, meaning that
      the schema constraints aren't applied to the start of nodes to
      the left of the input and the end of nodes at the end.
      */
      parseSlice(dom, options2 = {}) {
        let context = new ParseContext(this, options2, true);
        context.addAll(dom, options2.from, options2.to);
        return Slice.maxOpen(context.finish());
      }
      /**
      @internal
      */
      matchTag(dom, context, after) {
        for (let i2 = after ? this.tags.indexOf(after) + 1 : 0; i2 < this.tags.length; i2++) {
          let rule = this.tags[i2];
          if (matches2(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
            if (rule.getAttrs) {
              let result = rule.getAttrs(dom);
              if (result === false)
                continue;
              rule.attrs = result || void 0;
            }
            return rule;
          }
        }
      }
      /**
      @internal
      */
      matchStyle(prop, value, context, after) {
        for (let i2 = after ? this.styles.indexOf(after) + 1 : 0; i2 < this.styles.length; i2++) {
          let rule = this.styles[i2], style = rule.style;
          if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))
            continue;
          if (rule.getAttrs) {
            let result = rule.getAttrs(value);
            if (result === false)
              continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
      /**
      @internal
      */
      static schemaRules(schema3) {
        let result = [];
        function insert(rule) {
          let priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
          for (; i2 < result.length; i2++) {
            let next = result[i2], nextPriority = next.priority == null ? 50 : next.priority;
            if (nextPriority < priority)
              break;
          }
          result.splice(i2, 0, rule);
        }
        for (let name3 in schema3.marks) {
          let rules = schema3.marks[name3].spec.parseDOM;
          if (rules)
            rules.forEach((rule) => {
              insert(rule = copy(rule));
              if (!(rule.mark || rule.ignore || rule.clearMark))
                rule.mark = name3;
            });
        }
        for (let name3 in schema3.nodes) {
          let rules = schema3.nodes[name3].spec.parseDOM;
          if (rules)
            rules.forEach((rule) => {
              insert(rule = copy(rule));
              if (!(rule.node || rule.ignore || rule.mark))
                rule.node = name3;
            });
        }
        return result;
      }
      /**
      Construct a DOM parser using the parsing rules listed in a
      schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
      [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
      */
      static fromSchema(schema3) {
        return schema3.cached.domParser || (schema3.cached.domParser = new _DOMParser(schema3, _DOMParser.schemaRules(schema3)));
      }
    };
    blockTags = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    };
    ignoreTags = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    };
    listTags = { ol: true, ul: true };
    OPT_PRESERVE_WS = 1;
    OPT_PRESERVE_WS_FULL = 2;
    OPT_OPEN_LEFT = 4;
    NodeContext = class {
      constructor(type, attrs, marks, pendingMarks, solid, match, options2) {
        this.type = type;
        this.attrs = attrs;
        this.marks = marks;
        this.pendingMarks = pendingMarks;
        this.solid = solid;
        this.options = options2;
        this.content = [];
        this.activeMarks = Mark.none;
        this.stashMarks = [];
        this.match = match || (options2 & OPT_OPEN_LEFT ? null : type.contentMatch);
      }
      findWrapping(node) {
        if (!this.match) {
          if (!this.type)
            return [];
          let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
          if (fill) {
            this.match = this.type.contentMatch.matchFragment(fill);
          } else {
            let start = this.type.contentMatch, wrap2;
            if (wrap2 = start.findWrapping(node.type)) {
              this.match = start;
              return wrap2;
            } else {
              return null;
            }
          }
        }
        return this.match.findWrapping(node.type);
      }
      finish(openEnd) {
        if (!(this.options & OPT_PRESERVE_WS)) {
          let last2 = this.content[this.content.length - 1], m;
          if (last2 && last2.isText && (m = /[ \t\r\n\u000c]+$/.exec(last2.text))) {
            let text3 = last2;
            if (last2.text.length == m[0].length)
              this.content.pop();
            else
              this.content[this.content.length - 1] = text3.withText(text3.text.slice(0, text3.text.length - m[0].length));
          }
        }
        let content = Fragment.from(this.content);
        if (!openEnd && this.match)
          content = content.append(this.match.fillBefore(Fragment.empty, true));
        return this.type ? this.type.create(this.attrs, content, this.marks) : content;
      }
      popFromStashMark(mark) {
        for (let i2 = this.stashMarks.length - 1; i2 >= 0; i2--)
          if (mark.eq(this.stashMarks[i2]))
            return this.stashMarks.splice(i2, 1)[0];
      }
      applyPending(nextType) {
        for (let i2 = 0, pending = this.pendingMarks; i2 < pending.length; i2++) {
          let mark = pending[i2];
          if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
            this.activeMarks = mark.addToSet(this.activeMarks);
            this.pendingMarks = mark.removeFromSet(this.pendingMarks);
          }
        }
      }
      inlineContext(node) {
        if (this.type)
          return this.type.inlineContent;
        if (this.content.length)
          return this.content[0].isInline;
        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
      }
    };
    ParseContext = class {
      constructor(parser, options2, isOpen) {
        this.parser = parser;
        this.options = options2;
        this.isOpen = isOpen;
        this.open = 0;
        let topNode = options2.topNode, topContext;
        let topOptions = wsOptionsFor(null, options2.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
        if (topNode)
          topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options2.topMatch || topNode.type.contentMatch, topOptions);
        else if (isOpen)
          topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
        else
          topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
        this.nodes = [topContext];
        this.find = options2.findPositions;
        this.needsBlock = false;
      }
      get top() {
        return this.nodes[this.open];
      }
      // Add a DOM node to the content. Text is inserted as text node,
      // otherwise, the node is passed to `addElement` or, if it has a
      // `style` attribute, `addElementWithStyles`.
      addDOM(dom) {
        if (dom.nodeType == 3)
          this.addTextNode(dom);
        else if (dom.nodeType == 1)
          this.addElement(dom);
      }
      withStyleRules(dom, f) {
        let style = dom.getAttribute("style");
        if (!style)
          return f();
        let marks = this.readStyles(parseStyles(style));
        if (!marks)
          return;
        let [addMarks, removeMarks] = marks, top = this.top;
        for (let i2 = 0; i2 < removeMarks.length; i2++)
          this.removePendingMark(removeMarks[i2], top);
        for (let i2 = 0; i2 < addMarks.length; i2++)
          this.addPendingMark(addMarks[i2]);
        f();
        for (let i2 = 0; i2 < addMarks.length; i2++)
          this.removePendingMark(addMarks[i2], top);
        for (let i2 = 0; i2 < removeMarks.length; i2++)
          this.addPendingMark(removeMarks[i2]);
      }
      addTextNode(dom) {
        let value = dom.nodeValue;
        let top = this.top;
        if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
          if (!(top.options & OPT_PRESERVE_WS)) {
            value = value.replace(/[ \t\r\n\u000c]+/g, " ");
            if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
              let nodeBefore = top.content[top.content.length - 1];
              let domNodeBefore = dom.previousSibling;
              if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
                value = value.slice(1);
            }
          } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
            value = value.replace(/\r?\n|\r/g, " ");
          } else {
            value = value.replace(/\r\n?/g, "\n");
          }
          if (value)
            this.insertNode(this.parser.schema.text(value));
          this.findInText(dom);
        } else {
          this.findInside(dom);
        }
      }
      // Try to find a handler for the given tag and use that to parse. If
      // none is found, the element's content nodes are added directly.
      addElement(dom, matchAfter) {
        let name3 = dom.nodeName.toLowerCase(), ruleID;
        if (listTags.hasOwnProperty(name3) && this.parser.normalizeLists)
          normalizeList(dom);
        let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
        if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name3)) {
          this.findInside(dom);
          this.ignoreFallback(dom);
        } else if (!rule || rule.skip || rule.closeParent) {
          if (rule && rule.closeParent)
            this.open = Math.max(0, this.open - 1);
          else if (rule && rule.skip.nodeType)
            dom = rule.skip;
          let sync, top = this.top, oldNeedsBlock = this.needsBlock;
          if (blockTags.hasOwnProperty(name3)) {
            if (top.content.length && top.content[0].isInline && this.open) {
              this.open--;
              top = this.top;
            }
            sync = true;
            if (!top.type)
              this.needsBlock = true;
          } else if (!dom.firstChild) {
            this.leafFallback(dom);
            return;
          }
          if (rule && rule.skip)
            this.addAll(dom);
          else
            this.withStyleRules(dom, () => this.addAll(dom));
          if (sync)
            this.sync(top);
          this.needsBlock = oldNeedsBlock;
        } else {
          this.withStyleRules(dom, () => {
            this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
          });
        }
      }
      // Called for leaf DOM nodes that would otherwise be ignored
      leafFallback(dom) {
        if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
          this.addTextNode(dom.ownerDocument.createTextNode("\n"));
      }
      // Called for ignored nodes
      ignoreFallback(dom) {
        if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
          this.findPlace(this.parser.schema.text("-"));
      }
      // Run any style parser associated with the node's styles. Either
      // return an array of marks, or null to indicate some of the styles
      // had a rule with `ignore` set.
      readStyles(styles) {
        let add = Mark.none, remove = Mark.none;
        for (let i2 = 0; i2 < styles.length; i2 += 2) {
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(styles[i2], styles[i2 + 1], this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark) {
              this.top.pendingMarks.concat(this.top.activeMarks).forEach((m) => {
                if (rule.clearMark(m))
                  remove = m.addToSet(remove);
              });
            } else {
              add = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);
            }
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
        }
        return [add, remove];
      }
      // Look up a handler for the given node. If none are found, return
      // false. Otherwise, apply it, use its return value to drive the way
      // the node's content is wrapped, and return true.
      addElementByRule(dom, rule, continueAfter) {
        let sync, nodeType, mark;
        if (rule.node) {
          nodeType = this.parser.schema.nodes[rule.node];
          if (!nodeType.isLeaf) {
            sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
          } else if (!this.insertNode(nodeType.create(rule.attrs))) {
            this.leafFallback(dom);
          }
        } else {
          let markType = this.parser.schema.marks[rule.mark];
          mark = markType.create(rule.attrs);
          this.addPendingMark(mark);
        }
        let startIn = this.top;
        if (nodeType && nodeType.isLeaf) {
          this.findInside(dom);
        } else if (continueAfter) {
          this.addElement(dom, continueAfter);
        } else if (rule.getContent) {
          this.findInside(dom);
          rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node));
        } else {
          let contentDOM = dom;
          if (typeof rule.contentElement == "string")
            contentDOM = dom.querySelector(rule.contentElement);
          else if (typeof rule.contentElement == "function")
            contentDOM = rule.contentElement(dom);
          else if (rule.contentElement)
            contentDOM = rule.contentElement;
          this.findAround(dom, contentDOM, true);
          this.addAll(contentDOM);
        }
        if (sync && this.sync(startIn))
          this.open--;
        if (mark)
          this.removePendingMark(mark, startIn);
      }
      // Add all child nodes between `startIndex` and `endIndex` (or the
      // whole node, if not given). If `sync` is passed, use it to
      // synchronize after every block element.
      addAll(parent, startIndex, endIndex) {
        let index8 = startIndex || 0;
        for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index8) {
          this.findAtPoint(parent, index8);
          this.addDOM(dom);
        }
        this.findAtPoint(parent, index8);
      }
      // Try to find a way to fit the given node type into the current
      // context. May add intermediate wrappers and/or leave non-solid
      // nodes that we're in.
      findPlace(node) {
        let route, sync;
        for (let depth = this.open; depth >= 0; depth--) {
          let cx = this.nodes[depth];
          let found2 = cx.findWrapping(node);
          if (found2 && (!route || route.length > found2.length)) {
            route = found2;
            sync = cx;
            if (!found2.length)
              break;
          }
          if (cx.solid)
            break;
        }
        if (!route)
          return false;
        this.sync(sync);
        for (let i2 = 0; i2 < route.length; i2++)
          this.enterInner(route[i2], null, false);
        return true;
      }
      // Try to insert the given node, adjusting the context when needed.
      insertNode(node) {
        if (node.isInline && this.needsBlock && !this.top.type) {
          let block = this.textblockFromContext();
          if (block)
            this.enterInner(block);
        }
        if (this.findPlace(node)) {
          this.closeExtra();
          let top = this.top;
          top.applyPending(node.type);
          if (top.match)
            top.match = top.match.matchType(node.type);
          let marks = top.activeMarks;
          for (let i2 = 0; i2 < node.marks.length; i2++)
            if (!top.type || top.type.allowsMarkType(node.marks[i2].type))
              marks = node.marks[i2].addToSet(marks);
          top.content.push(node.mark(marks));
          return true;
        }
        return false;
      }
      // Try to start a node of the given type, adjusting the context when
      // necessary.
      enter(type, attrs, preserveWS) {
        let ok2 = this.findPlace(type.create(attrs));
        if (ok2)
          this.enterInner(type, attrs, true, preserveWS);
        return ok2;
      }
      // Open a node of the given type
      enterInner(type, attrs = null, solid = false, preserveWS) {
        this.closeExtra();
        let top = this.top;
        top.applyPending(type);
        top.match = top.match && top.match.matchType(type);
        let options2 = wsOptionsFor(type, preserveWS, top.options);
        if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
          options2 |= OPT_OPEN_LEFT;
        this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options2));
        this.open++;
      }
      // Make sure all nodes above this.open are finished and added to
      // their parents
      closeExtra(openEnd = false) {
        let i2 = this.nodes.length - 1;
        if (i2 > this.open) {
          for (; i2 > this.open; i2--)
            this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
          this.nodes.length = this.open + 1;
        }
      }
      finish() {
        this.open = 0;
        this.closeExtra(this.isOpen);
        return this.nodes[0].finish(this.isOpen || this.options.topOpen);
      }
      sync(to) {
        for (let i2 = this.open; i2 >= 0; i2--)
          if (this.nodes[i2] == to) {
            this.open = i2;
            return true;
          }
        return false;
      }
      get currentPos() {
        this.closeExtra();
        let pos = 0;
        for (let i2 = this.open; i2 >= 0; i2--) {
          let content = this.nodes[i2].content;
          for (let j2 = content.length - 1; j2 >= 0; j2--)
            pos += content[j2].nodeSize;
          if (i2)
            pos++;
        }
        return pos;
      }
      findAtPoint(parent, offset2) {
        if (this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].node == parent && this.find[i2].offset == offset2)
              this.find[i2].pos = this.currentPos;
          }
      }
      findInside(parent) {
        if (this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node))
              this.find[i2].pos = this.currentPos;
          }
      }
      findAround(parent, content, before) {
        if (parent != content && this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
              let pos = content.compareDocumentPosition(this.find[i2].node);
              if (pos & (before ? 2 : 4))
                this.find[i2].pos = this.currentPos;
            }
          }
      }
      findInText(textNode) {
        if (this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].node == textNode)
              this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
          }
      }
      // Determines whether the given context string matches this context.
      matchesContext(context) {
        if (context.indexOf("|") > -1)
          return context.split(/\s*\|\s*/).some(this.matchesContext, this);
        let parts = context.split("/");
        let option = this.options.context;
        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
        let match = (i2, depth) => {
          for (; i2 >= 0; i2--) {
            let part = parts[i2];
            if (part == "") {
              if (i2 == parts.length - 1 || i2 == 0)
                continue;
              for (; depth >= minDepth; depth--)
                if (match(i2 - 1, depth))
                  return true;
              return false;
            } else {
              let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
              if (!next || next.name != part && next.groups.indexOf(part) == -1)
                return false;
              depth--;
            }
          }
          return true;
        };
        return match(parts.length - 1, this.open);
      }
      textblockFromContext() {
        let $context = this.options.context;
        if ($context)
          for (let d = $context.depth; d >= 0; d--) {
            let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
            if (deflt && deflt.isTextblock && deflt.defaultAttrs)
              return deflt;
          }
        for (let name3 in this.parser.schema.nodes) {
          let type = this.parser.schema.nodes[name3];
          if (type.isTextblock && type.defaultAttrs)
            return type;
        }
      }
      addPendingMark(mark) {
        let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
        if (found2)
          this.top.stashMarks.push(found2);
        this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
      }
      removePendingMark(mark, upto) {
        for (let depth = this.open; depth >= 0; depth--) {
          let level = this.nodes[depth];
          let found2 = level.pendingMarks.lastIndexOf(mark);
          if (found2 > -1) {
            level.pendingMarks = mark.removeFromSet(level.pendingMarks);
          } else {
            level.activeMarks = mark.removeFromSet(level.activeMarks);
            let stashMark = level.popFromStashMark(mark);
            if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
              level.activeMarks = stashMark.addToSet(level.activeMarks);
          }
          if (level == upto)
            break;
        }
      }
    };
    DOMSerializer = class _DOMSerializer {
      /**
      Create a serializer. `nodes` should map node names to functions
      that take a node and return a description of the corresponding
      DOM. `marks` does the same for mark names, but also gets an
      argument that tells it whether the mark's content is block or
      inline content (for typical use, it'll always be inline). A mark
      serializer may be `null` to indicate that marks of that type
      should not be serialized.
      */
      constructor(nodes, marks) {
        this.nodes = nodes;
        this.marks = marks;
      }
      /**
      Serialize the content of this fragment to a DOM fragment. When
      not in the browser, the `document` option, containing a DOM
      document, should be passed so that the serializer can create
      nodes.
      */
      serializeFragment(fragment, options2 = {}, target) {
        if (!target)
          target = doc(options2).createDocumentFragment();
        let top = target, active = [];
        fragment.forEach((node) => {
          if (active.length || node.marks.length) {
            let keep = 0, rendered = 0;
            while (keep < active.length && rendered < node.marks.length) {
              let next = node.marks[rendered];
              if (!this.marks[next.type.name]) {
                rendered++;
                continue;
              }
              if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
                break;
              keep++;
              rendered++;
            }
            while (keep < active.length)
              top = active.pop()[1];
            while (rendered < node.marks.length) {
              let add = node.marks[rendered++];
              let markDOM = this.serializeMark(add, node.isInline, options2);
              if (markDOM) {
                active.push([add, top]);
                top.appendChild(markDOM.dom);
                top = markDOM.contentDOM || markDOM.dom;
              }
            }
          }
          top.appendChild(this.serializeNodeInner(node, options2));
        });
        return target;
      }
      /**
      @internal
      */
      serializeNodeInner(node, options2) {
        let { dom, contentDOM } = _DOMSerializer.renderSpec(doc(options2), this.nodes[node.type.name](node));
        if (contentDOM) {
          if (node.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(node.content, options2, contentDOM);
        }
        return dom;
      }
      /**
      Serialize this node to a DOM node. This can be useful when you
      need to serialize a part of a document, as opposed to the whole
      document. To serialize a whole document, use
      [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
      its [content](https://prosemirror.net/docs/ref/#model.Node.content).
      */
      serializeNode(node, options2 = {}) {
        let dom = this.serializeNodeInner(node, options2);
        for (let i2 = node.marks.length - 1; i2 >= 0; i2--) {
          let wrap2 = this.serializeMark(node.marks[i2], node.isInline, options2);
          if (wrap2) {
            (wrap2.contentDOM || wrap2.dom).appendChild(dom);
            dom = wrap2.dom;
          }
        }
        return dom;
      }
      /**
      @internal
      */
      serializeMark(mark, inline, options2 = {}) {
        let toDOM = this.marks[mark.type.name];
        return toDOM && _DOMSerializer.renderSpec(doc(options2), toDOM(mark, inline));
      }
      /**
      Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
      the spec has a hole (zero) in it, `contentDOM` will point at the
      node with the hole.
      */
      static renderSpec(doc3, structure, xmlNS = null) {
        if (typeof structure == "string")
          return { dom: doc3.createTextNode(structure) };
        if (structure.nodeType != null)
          return { dom: structure };
        if (structure.dom && structure.dom.nodeType != null)
          return structure;
        let tagName = structure[0], space = tagName.indexOf(" ");
        if (space > 0) {
          xmlNS = tagName.slice(0, space);
          tagName = tagName.slice(space + 1);
        }
        let contentDOM;
        let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
        let attrs = structure[1], start = 1;
        if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
          start = 2;
          for (let name3 in attrs)
            if (attrs[name3] != null) {
              let space2 = name3.indexOf(" ");
              if (space2 > 0)
                dom.setAttributeNS(name3.slice(0, space2), name3.slice(space2 + 1), attrs[name3]);
              else
                dom.setAttribute(name3, attrs[name3]);
            }
        }
        for (let i2 = start; i2 < structure.length; i2++) {
          let child = structure[i2];
          if (child === 0) {
            if (i2 < structure.length - 1 || i2 > start)
              throw new RangeError("Content hole must be the only child of its parent node");
            return { dom, contentDOM: dom };
          } else {
            let { dom: inner, contentDOM: innerContent } = _DOMSerializer.renderSpec(doc3, child, xmlNS);
            dom.appendChild(inner);
            if (innerContent) {
              if (contentDOM)
                throw new RangeError("Multiple content holes");
              contentDOM = innerContent;
            }
          }
        }
        return { dom, contentDOM };
      }
      /**
      Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
      properties in a schema's node and mark specs.
      */
      static fromSchema(schema3) {
        return schema3.cached.domSerializer || (schema3.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema3), this.marksFromSchema(schema3)));
      }
      /**
      Gather the serializers in a schema's node specs into an object.
      This can be useful as a base to build a custom serializer from.
      */
      static nodesFromSchema(schema3) {
        let result = gatherToDOM(schema3.nodes);
        if (!result.text)
          result.text = (node) => node.text;
        return result;
      }
      /**
      Gather the serializers in a schema's mark specs into an object.
      */
      static marksFromSchema(schema3) {
        return gatherToDOM(schema3.marks);
      }
    };
  }
});

// node_modules/.pnpm/prosemirror-transform@1.7.5/node_modules/prosemirror-transform/dist/index.js
function makeRecover(index8, offset2) {
  return index8 + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i2 = 0; i2 < fragment.childCount; i2++) {
    let child = fragment.child(i2);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i2);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
function contentBetween(doc3, from2, to) {
  let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from2), end = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i2 = 0; i2 < marks.length; i2++) {
        if (!marks[i2].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i2]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i2]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s2) => tr2.step(s2));
  added.forEach((s2) => tr2.step(s2));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set2 = node.marks, found2;
      while (found2 = mark.isInSet(set2)) {
        (toRemove || (toRemove = [])).push(found2);
        set2 = found2.removeFromSet(set2);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to);
      for (let i2 = 0; i2 < toRemove.length; i2++) {
        let style = toRemove[i2], found2;
        for (let j2 = 0; j2 < matched.length; j2++) {
          let m = matched[j2];
          if (m.step == step - 1 && style.eq(matched[j2].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style, from: Math.max(pos, from2), to: end, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i2 = 0; i2 < node.childCount; i2++) {
    let child = node.child(i2), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j2 = 0; j2 < child.marks.length; j2++)
        if (!parentType.allowsMarkType(child.marks[j2].type))
          tr2.step(new RemoveMarkStep(cur, end, child.marks[j2]));
      if (child.isText && !parentType.spec.code) {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i2 = replSteps.length - 1; i2 >= 0; i2--)
    tr2.step(replSteps[i2]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index8 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index8, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index8, endIndex))
      break;
  }
  return null;
}
function lift(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr2.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i2 = startIndex; innerMatch && i2 < endIndex; i2++)
    innerMatch = innerMatch.matchType(parent.child(i2).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr2, range, wrappers) {
  let content = Fragment.empty;
  for (let i2 = wrappers.length - 1; i2 >= 0; i2--) {
    if (content.size) {
      let match = wrappers[i2].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
  }
  let start = range.start, end = range.end;
  tr2.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr2, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      tr2.clearIncompatible(tr2.mapping.slice(mapFrom).map(pos, 1), type);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false;
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index8 = $pos.index();
  return $pos.parent.canReplaceWith(index8, index8 + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode2 = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode2);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode2), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base3 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base3 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i2 = depth - 2; d > base3; d--, i2--) {
    let node = $pos.node(d), index9 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index9, node.childCount);
    let overrideChild = typesAfter && typesAfter[i2 + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i2] || node;
    if (!node.canReplace(index9 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index8 = $pos.indexAfter(base3);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base3).canReplaceWith(index8, index8, baseType ? baseType.type : $pos.node(base3 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i2 = depth - 1; d > e; d--, i2--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i2];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index8 = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index8, index8 + 1);
}
function joinable2(a2, b) {
  return !!(a2 && b && !a2.isLeaf && a2.canAppend(b));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index8 = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index8++;
      after = $pos.node(d).maybeChild(index8);
    } else {
      before = $pos.node(d).maybeChild(index8 - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index8, index8 + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  tr2.step(step);
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index8 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index8, index8, nodeType))
        return $pos.before(d + 1);
      if (index8 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index8 = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index8, index8, nodeType))
        return $pos.after(d + 1);
      if (index8 < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice2) {
  let $pos = doc3.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i2 = 0; i2 < slice2.openStart; i2++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc3.resolve(from2), $to = doc3.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i2 = 0; i2 < depth; i2++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index8 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index8 == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index8);
  return fit && !invalidMarks(type, node.content, index8) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (let i2 = start; i2 < fragment.childCount; i2++)
    if (!type.allowsMarks(fragment.child(i2).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr2.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i2 = 0; ; i2++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i2 == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j2 = slice2.openStart; j2 >= 0; j2--) {
    let openDepth = (j2 + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i2 = 0; i2 < targetDepths.length; i2++) {
      let targetDepth = targetDepths[(i2 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index8 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index8, index8, insert.type, insert.marks))
        return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i2 = targetDepths.length - 1; i2 >= 0; i2--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i2];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node) {
  if (!node.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i2 = 0; i2 < covered.length; i2++) {
    let depth = covered[i2], last2 = i2 == covered.length - 1;
    if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
      result.push(d);
  }
  return result;
}
var lower16, factor16, DEL_BEFORE, DEL_AFTER, DEL_ACROSS, DEL_SIDE, MapResult, StepMap, Mapping, stepsByID, Step, StepResult, AddMarkStep, RemoveMarkStep, AddNodeMarkStep, RemoveNodeMarkStep, ReplaceStep, ReplaceAroundStep, Fitter, AttrStep, TransformError, Transform;
var init_dist5 = __esm({
  "node_modules/.pnpm/prosemirror-transform@1.7.5/node_modules/prosemirror-transform/dist/index.js"() {
    init_dist4();
    lower16 = 65535;
    factor16 = Math.pow(2, 16);
    DEL_BEFORE = 1;
    DEL_AFTER = 2;
    DEL_ACROSS = 4;
    DEL_SIDE = 8;
    MapResult = class {
      /**
      @internal
      */
      constructor(pos, delInfo, recover) {
        this.pos = pos;
        this.delInfo = delInfo;
        this.recover = recover;
      }
      /**
      Tells you whether the position was deleted, that is, whether the
      step removed the token on the side queried (via the `assoc`)
      argument from the document.
      */
      get deleted() {
        return (this.delInfo & DEL_SIDE) > 0;
      }
      /**
      Tells you whether the token before the mapped position was deleted.
      */
      get deletedBefore() {
        return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
      }
      /**
      True when the token after the mapped position was deleted.
      */
      get deletedAfter() {
        return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
      }
      /**
      Tells whether any of the steps mapped through deletes across the
      position (including both the token before and after the
      position).
      */
      get deletedAcross() {
        return (this.delInfo & DEL_ACROSS) > 0;
      }
    };
    StepMap = class _StepMap {
      /**
      Create a position map. The modifications to the document are
      represented as an array of numbers, in which each group of three
      represents a modified chunk as `[start, oldSize, newSize]`.
      */
      constructor(ranges, inverted = false) {
        this.ranges = ranges;
        this.inverted = inverted;
        if (!ranges.length && _StepMap.empty)
          return _StepMap.empty;
      }
      /**
      @internal
      */
      recover(value) {
        let diff = 0, index8 = recoverIndex(value);
        if (!this.inverted)
          for (let i2 = 0; i2 < index8; i2++)
            diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
        return this.ranges[index8 * 3] + diff + recoverOffset(value);
      }
      mapResult(pos, assoc = 1) {
        return this._map(pos, assoc, false);
      }
      map(pos, assoc = 1) {
        return this._map(pos, assoc, true);
      }
      /**
      @internal
      */
      _map(pos, assoc, simple) {
        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
          let start = this.ranges[i2] - (this.inverted ? diff : 0);
          if (start > pos)
            break;
          let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end = start + oldSize;
          if (pos <= end) {
            let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
            let result = start + diff + (side < 0 ? 0 : newSize);
            if (simple)
              return result;
            let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i2 / 3, pos - start);
            let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
            if (assoc < 0 ? pos != start : pos != end)
              del2 |= DEL_SIDE;
            return new MapResult(result, del2, recover);
          }
          diff += newSize - oldSize;
        }
        return simple ? pos + diff : new MapResult(pos + diff, 0, null);
      }
      /**
      @internal
      */
      touches(pos, recover) {
        let diff = 0, index8 = recoverIndex(recover);
        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
          let start = this.ranges[i2] - (this.inverted ? diff : 0);
          if (start > pos)
            break;
          let oldSize = this.ranges[i2 + oldIndex], end = start + oldSize;
          if (pos <= end && i2 == index8 * 3)
            return true;
          diff += this.ranges[i2 + newIndex] - oldSize;
        }
        return false;
      }
      /**
      Calls the given function on each of the changed ranges included in
      this map.
      */
      forEach(f) {
        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
          let start = this.ranges[i2], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
          let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
          f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
          diff += newSize - oldSize;
        }
      }
      /**
      Create an inverted version of this map. The result can be used to
      map positions in the post-step document to the pre-step document.
      */
      invert() {
        return new _StepMap(this.ranges, !this.inverted);
      }
      /**
      @internal
      */
      toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
      }
      /**
      Create a map that moves all positions by offset `n` (which may be
      negative). This can be useful when applying steps meant for a
      sub-document to a larger document, or vice-versa.
      */
      static offset(n) {
        return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
      }
    };
    StepMap.empty = new StepMap([]);
    Mapping = class _Mapping {
      /**
      Create a new mapping with the given position maps.
      */
      constructor(maps = [], mirror, from2 = 0, to = maps.length) {
        this.maps = maps;
        this.mirror = mirror;
        this.from = from2;
        this.to = to;
      }
      /**
      Create a mapping that maps only through a part of this one.
      */
      slice(from2 = 0, to = this.maps.length) {
        return new _Mapping(this.maps, this.mirror, from2, to);
      }
      /**
      @internal
      */
      copy() {
        return new _Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
      }
      /**
      Add a step map to the end of this mapping. If `mirrors` is
      given, it should be the index of the step map that is the mirror
      image of this one.
      */
      appendMap(map2, mirrors) {
        this.to = this.maps.push(map2);
        if (mirrors != null)
          this.setMirror(this.maps.length - 1, mirrors);
      }
      /**
      Add all the step maps in a given mapping to this one (preserving
      mirroring information).
      */
      appendMapping(mapping) {
        for (let i2 = 0, startSize = this.maps.length; i2 < mapping.maps.length; i2++) {
          let mirr = mapping.getMirror(i2);
          this.appendMap(mapping.maps[i2], mirr != null && mirr < i2 ? startSize + mirr : void 0);
        }
      }
      /**
      Finds the offset of the step map that mirrors the map at the
      given offset, in this mapping (as per the second argument to
      `appendMap`).
      */
      getMirror(n) {
        if (this.mirror) {
          for (let i2 = 0; i2 < this.mirror.length; i2++)
            if (this.mirror[i2] == n)
              return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
        }
      }
      /**
      @internal
      */
      setMirror(n, m) {
        if (!this.mirror)
          this.mirror = [];
        this.mirror.push(n, m);
      }
      /**
      Append the inverse of the given mapping to this one.
      */
      appendMappingInverted(mapping) {
        for (let i2 = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i2 >= 0; i2--) {
          let mirr = mapping.getMirror(i2);
          this.appendMap(mapping.maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : void 0);
        }
      }
      /**
      Create an inverted version of this mapping.
      */
      invert() {
        let inverse = new _Mapping();
        inverse.appendMappingInverted(this);
        return inverse;
      }
      /**
      Map a position through this mapping.
      */
      map(pos, assoc = 1) {
        if (this.mirror)
          return this._map(pos, assoc, true);
        for (let i2 = this.from; i2 < this.to; i2++)
          pos = this.maps[i2].map(pos, assoc);
        return pos;
      }
      /**
      Map a position through this mapping, returning a mapping
      result.
      */
      mapResult(pos, assoc = 1) {
        return this._map(pos, assoc, false);
      }
      /**
      @internal
      */
      _map(pos, assoc, simple) {
        let delInfo = 0;
        for (let i2 = this.from; i2 < this.to; i2++) {
          let map2 = this.maps[i2], result = map2.mapResult(pos, assoc);
          if (result.recover != null) {
            let corr = this.getMirror(i2);
            if (corr != null && corr > i2 && corr < this.to) {
              i2 = corr;
              pos = this.maps[corr].recover(result.recover);
              continue;
            }
          }
          delInfo |= result.delInfo;
          pos = result.pos;
        }
        return simple ? pos : new MapResult(pos, delInfo, null);
      }
    };
    stepsByID = /* @__PURE__ */ Object.create(null);
    Step = class {
      /**
      Get the step map that represents the changes made by this step,
      and which can be used to transform between positions in the old
      and the new document.
      */
      getMap() {
        return StepMap.empty;
      }
      /**
      Try to merge this step with another one, to be applied directly
      after it. Returns the merged step when possible, null if the
      steps can't be merged.
      */
      merge(other) {
        return null;
      }
      /**
      Deserialize a step from its JSON representation. Will call
      through to the step class' own implementation of this method.
      */
      static fromJSON(schema3, json2) {
        if (!json2 || !json2.stepType)
          throw new RangeError("Invalid input for Step.fromJSON");
        let type = stepsByID[json2.stepType];
        if (!type)
          throw new RangeError(`No step type ${json2.stepType} defined`);
        return type.fromJSON(schema3, json2);
      }
      /**
      To be able to serialize steps to JSON, each step needs a string
      ID to attach to its JSON representation. Use this method to
      register an ID for your step classes. Try to pick something
      that's unlikely to clash with steps from other modules.
      */
      static jsonID(id, stepClass) {
        if (id in stepsByID)
          throw new RangeError("Duplicate use of step JSON ID " + id);
        stepsByID[id] = stepClass;
        stepClass.prototype.jsonID = id;
        return stepClass;
      }
    };
    StepResult = class _StepResult {
      /**
      @internal
      */
      constructor(doc3, failed) {
        this.doc = doc3;
        this.failed = failed;
      }
      /**
      Create a successful step result.
      */
      static ok(doc3) {
        return new _StepResult(doc3, null);
      }
      /**
      Create a failed step result.
      */
      static fail(message) {
        return new _StepResult(null, message);
      }
      /**
      Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
      arguments. Create a successful result if it succeeds, and a
      failed one if it throws a `ReplaceError`.
      */
      static fromReplace(doc3, from2, to, slice2) {
        try {
          return _StepResult.ok(doc3.replace(from2, to, slice2));
        } catch (e) {
          if (e instanceof ReplaceError)
            return _StepResult.fail(e.message);
          throw e;
        }
      }
    };
    AddMarkStep = class _AddMarkStep extends Step {
      /**
      Create a mark step.
      */
      constructor(from2, to, mark) {
        super();
        this.from = from2;
        this.to = to;
        this.mark = mark;
      }
      apply(doc3) {
        let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
        let parent = $from.node($from.sharedDepth(this.to));
        let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
          if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
            return node;
          return node.mark(this.mark.addToSet(node.marks));
        }, parent), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc3, this.from, this.to, slice2);
      }
      invert() {
        return new RemoveMarkStep(this.from, this.to, this.mark);
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from2.deleted && to.deleted || from2.pos >= to.pos)
          return null;
        return new _AddMarkStep(from2.pos, to.pos, this.mark);
      }
      merge(other) {
        if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
          return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        return null;
      }
      toJSON() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(schema3, json2) {
        if (typeof json2.from != "number" || typeof json2.to != "number")
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new _AddMarkStep(json2.from, json2.to, schema3.markFromJSON(json2.mark));
      }
    };
    Step.jsonID("addMark", AddMarkStep);
    RemoveMarkStep = class _RemoveMarkStep extends Step {
      /**
      Create a mark-removing step.
      */
      constructor(from2, to, mark) {
        super();
        this.from = from2;
        this.to = to;
        this.mark = mark;
      }
      apply(doc3) {
        let oldSlice = doc3.slice(this.from, this.to);
        let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
          return node.mark(this.mark.removeFromSet(node.marks));
        }, doc3), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc3, this.from, this.to, slice2);
      }
      invert() {
        return new AddMarkStep(this.from, this.to, this.mark);
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from2.deleted && to.deleted || from2.pos >= to.pos)
          return null;
        return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
      }
      merge(other) {
        if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
          return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        return null;
      }
      toJSON() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(schema3, json2) {
        if (typeof json2.from != "number" || typeof json2.to != "number")
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new _RemoveMarkStep(json2.from, json2.to, schema3.markFromJSON(json2.mark));
      }
    };
    Step.jsonID("removeMark", RemoveMarkStep);
    AddNodeMarkStep = class _AddNodeMarkStep extends Step {
      /**
      Create a node mark step.
      */
      constructor(pos, mark) {
        super();
        this.pos = pos;
        this.mark = mark;
      }
      apply(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at mark step's position");
        let updated2 = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
        return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated2), 0, node.isLeaf ? 0 : 1));
      }
      invert(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (node) {
          let newSet = this.mark.addToSet(node.marks);
          if (newSet.length == node.marks.length) {
            for (let i2 = 0; i2 < node.marks.length; i2++)
              if (!node.marks[i2].isInSet(newSet))
                return new _AddNodeMarkStep(this.pos, node.marks[i2]);
            return new _AddNodeMarkStep(this.pos, this.mark);
          }
        }
        return new RemoveNodeMarkStep(this.pos, this.mark);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
      }
      toJSON() {
        return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(schema3, json2) {
        if (typeof json2.pos != "number")
          throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new _AddNodeMarkStep(json2.pos, schema3.markFromJSON(json2.mark));
      }
    };
    Step.jsonID("addNodeMark", AddNodeMarkStep);
    RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
      /**
      Create a mark-removing step.
      */
      constructor(pos, mark) {
        super();
        this.pos = pos;
        this.mark = mark;
      }
      apply(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at mark step's position");
        let updated2 = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
        return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated2), 0, node.isLeaf ? 0 : 1));
      }
      invert(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node || !this.mark.isInSet(node.marks))
          return this;
        return new AddNodeMarkStep(this.pos, this.mark);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
      }
      toJSON() {
        return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(schema3, json2) {
        if (typeof json2.pos != "number")
          throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new _RemoveNodeMarkStep(json2.pos, schema3.markFromJSON(json2.mark));
      }
    };
    Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
    ReplaceStep = class _ReplaceStep extends Step {
      /**
      The given `slice` should fit the 'gap' between `from` and
      `to`—the depths must line up, and the surrounding nodes must be
      able to be joined with the open sides of the slice. When
      `structure` is true, the step will fail if the content between
      from and to is not just a sequence of closing and then opening
      tokens (this is to guard against rebased replace steps
      overwriting something they weren't supposed to).
      */
      constructor(from2, to, slice2, structure = false) {
        super();
        this.from = from2;
        this.to = to;
        this.slice = slice2;
        this.structure = structure;
      }
      apply(doc3) {
        if (this.structure && contentBetween(doc3, this.from, this.to))
          return StepResult.fail("Structure replace would overwrite content");
        return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
      }
      getMap() {
        return new StepMap([this.from, this.to - this.from, this.slice.size]);
      }
      invert(doc3) {
        return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from2.deletedAcross && to.deletedAcross)
          return null;
        return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
      }
      merge(other) {
        if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
          return null;
        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
          let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
          return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
        } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
          let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
          return new _ReplaceStep(other.from, this.to, slice2, this.structure);
        } else {
          return null;
        }
      }
      toJSON() {
        let json2 = { stepType: "replace", from: this.from, to: this.to };
        if (this.slice.size)
          json2.slice = this.slice.toJSON();
        if (this.structure)
          json2.structure = true;
        return json2;
      }
      /**
      @internal
      */
      static fromJSON(schema3, json2) {
        if (typeof json2.from != "number" || typeof json2.to != "number")
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new _ReplaceStep(json2.from, json2.to, Slice.fromJSON(schema3, json2.slice), !!json2.structure);
      }
    };
    Step.jsonID("replace", ReplaceStep);
    ReplaceAroundStep = class _ReplaceAroundStep extends Step {
      /**
      Create a replace-around step with the given range and gap.
      `insert` should be the point in the slice into which the content
      of the gap should be moved. `structure` has the same meaning as
      it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
      */
      constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
        super();
        this.from = from2;
        this.to = to;
        this.gapFrom = gapFrom;
        this.gapTo = gapTo;
        this.slice = slice2;
        this.insert = insert;
        this.structure = structure;
      }
      apply(doc3) {
        if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
          return StepResult.fail("Structure gap-replace would overwrite content");
        let gap = doc3.slice(this.gapFrom, this.gapTo);
        if (gap.openStart || gap.openEnd)
          return StepResult.fail("Gap is not a flat range");
        let inserted = this.slice.insertAt(this.insert, gap.content);
        if (!inserted)
          return StepResult.fail("Content does not fit in gap");
        return StepResult.fromReplace(doc3, this.from, this.to, inserted);
      }
      getMap() {
        return new StepMap([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      }
      invert(doc3) {
        let gap = this.gapTo - this.gapFrom;
        return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
        if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
          return null;
        return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
      }
      toJSON() {
        let json2 = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        if (this.slice.size)
          json2.slice = this.slice.toJSON();
        if (this.structure)
          json2.structure = true;
        return json2;
      }
      /**
      @internal
      */
      static fromJSON(schema3, json2) {
        if (typeof json2.from != "number" || typeof json2.to != "number" || typeof json2.gapFrom != "number" || typeof json2.gapTo != "number" || typeof json2.insert != "number")
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new _ReplaceAroundStep(json2.from, json2.to, json2.gapFrom, json2.gapTo, Slice.fromJSON(schema3, json2.slice), json2.insert, !!json2.structure);
      }
    };
    Step.jsonID("replaceAround", ReplaceAroundStep);
    Fitter = class {
      constructor($from, $to, unplaced) {
        this.$from = $from;
        this.$to = $to;
        this.unplaced = unplaced;
        this.frontier = [];
        this.placed = Fragment.empty;
        for (let i2 = 0; i2 <= $from.depth; i2++) {
          let node = $from.node(i2);
          this.frontier.push({
            type: node.type,
            match: node.contentMatchAt($from.indexAfter(i2))
          });
        }
        for (let i2 = $from.depth; i2 > 0; i2--)
          this.placed = Fragment.from($from.node(i2).copy(this.placed));
      }
      get depth() {
        return this.frontier.length - 1;
      }
      fit() {
        while (this.unplaced.size) {
          let fit = this.findFittable();
          if (fit)
            this.placeNodes(fit);
          else
            this.openMore() || this.dropNode();
        }
        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
        if (!$to)
          return null;
        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
        while (openStart && openEnd && content.childCount == 1) {
          content = content.firstChild.content;
          openStart--;
          openEnd--;
        }
        let slice2 = new Slice(content, openStart, openEnd);
        if (moveInline > -1)
          return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
        if (slice2.size || $from.pos != this.$to.pos)
          return new ReplaceStep($from.pos, $to.pos, slice2);
        return null;
      }
      // Find a position on the start spine of `this.unplaced` that has
      // content that can be moved somewhere on the frontier. Returns two
      // depths, one for the slice and one for the frontier.
      findFittable() {
        let startDepth = this.unplaced.openStart;
        for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
          let node = cur.firstChild;
          if (cur.childCount > 1)
            openEnd = 0;
          if (node.type.spec.isolating && openEnd <= d) {
            startDepth = d;
            break;
          }
          cur = node.content;
        }
        for (let pass = 1; pass <= 2; pass++) {
          for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
            let fragment, parent = null;
            if (sliceDepth) {
              parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
              fragment = parent.content;
            } else {
              fragment = this.unplaced.content;
            }
            let first2 = fragment.firstChild;
            for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
              let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
              if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
                return { sliceDepth, frontierDepth, parent, inject };
              else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
                return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
              if (parent && match.matchType(parent.type))
                break;
            }
          }
        }
      }
      openMore() {
        let { content, openStart, openEnd } = this.unplaced;
        let inner = contentAt(content, openStart);
        if (!inner.childCount || inner.firstChild.isLeaf)
          return false;
        this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
        return true;
      }
      dropNode() {
        let { content, openStart, openEnd } = this.unplaced;
        let inner = contentAt(content, openStart);
        if (inner.childCount <= 1 && openStart > 0) {
          let openAtEnd = content.size - openStart <= openStart + inner.size;
          this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
        } else {
          this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
        }
      }
      // Move content from the unplaced slice at `sliceDepth` to the
      // frontier node at `frontierDepth`. Close that frontier node when
      // applicable.
      placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
        while (this.depth > frontierDepth)
          this.closeFrontierNode();
        if (wrap2)
          for (let i2 = 0; i2 < wrap2.length; i2++)
            this.openFrontierNode(wrap2[i2]);
        let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
        let openStart = slice2.openStart - sliceDepth;
        let taken = 0, add = [];
        let { match, type } = this.frontier[frontierDepth];
        if (inject) {
          for (let i2 = 0; i2 < inject.childCount; i2++)
            add.push(inject.child(i2));
          match = match.matchFragment(inject);
        }
        let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
        while (taken < fragment.childCount) {
          let next = fragment.child(taken), matches3 = match.matchType(next.type);
          if (!matches3)
            break;
          taken++;
          if (taken > 1 || openStart == 0 || next.content.size) {
            match = matches3;
            add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
          }
        }
        let toEnd = taken == fragment.childCount;
        if (!toEnd)
          openEndCount = -1;
        this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
        this.frontier[frontierDepth].match = match;
        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
          this.closeFrontierNode();
        for (let i2 = 0, cur = fragment; i2 < openEndCount; i2++) {
          let node = cur.lastChild;
          this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
          cur = node.content;
        }
        this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
      }
      mustMoveInline() {
        if (!this.$to.parent.isTextblock)
          return -1;
        let top = this.frontier[this.depth], level;
        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
          return -1;
        let { depth } = this.$to, after = this.$to.after(depth);
        while (depth > 1 && after == this.$to.end(--depth))
          ++after;
        return after;
      }
      findCloseLevel($to) {
        scan:
          for (let i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
            let { match, type } = this.frontier[i2];
            let dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
            let fit = contentAfterFits($to, i2, type, match, dropInner);
            if (!fit)
              continue;
            for (let d = i2 - 1; d >= 0; d--) {
              let { match: match2, type: type2 } = this.frontier[d];
              let matches3 = contentAfterFits($to, d, type2, match2, true);
              if (!matches3 || matches3.childCount)
                continue scan;
            }
            return { depth: i2, fit, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
          }
      }
      close($to) {
        let close2 = this.findCloseLevel($to);
        if (!close2)
          return null;
        while (this.depth > close2.depth)
          this.closeFrontierNode();
        if (close2.fit.childCount)
          this.placed = addToFragment(this.placed, close2.depth, close2.fit);
        $to = close2.move;
        for (let d = close2.depth + 1; d <= $to.depth; d++) {
          let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
          this.openFrontierNode(node.type, node.attrs, add);
        }
        return $to;
      }
      openFrontierNode(type, attrs = null, content) {
        let top = this.frontier[this.depth];
        top.match = top.match.matchType(type);
        this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
        this.frontier.push({ type, match: type.contentMatch });
      }
      closeFrontierNode() {
        let open = this.frontier.pop();
        let add = open.match.fillBefore(Fragment.empty, true);
        if (add.childCount)
          this.placed = addToFragment(this.placed, this.frontier.length, add);
      }
    };
    AttrStep = class _AttrStep extends Step {
      /**
      Construct an attribute step.
      */
      constructor(pos, attr, value) {
        super();
        this.pos = pos;
        this.attr = attr;
        this.value = value;
      }
      apply(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at attribute step's position");
        let attrs = /* @__PURE__ */ Object.create(null);
        for (let name3 in node.attrs)
          attrs[name3] = node.attrs[name3];
        attrs[this.attr] = this.value;
        let updated2 = node.type.create(attrs, null, node.marks);
        return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated2), 0, node.isLeaf ? 0 : 1));
      }
      getMap() {
        return StepMap.empty;
      }
      invert(doc3) {
        return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
      }
      toJSON() {
        return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
      }
      static fromJSON(schema3, json2) {
        if (typeof json2.pos != "number" || typeof json2.attr != "string")
          throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new _AttrStep(json2.pos, json2.attr, json2.value);
      }
    };
    Step.jsonID("attr", AttrStep);
    TransformError = class extends Error {
    };
    TransformError = function TransformError2(message) {
      let err = Error.call(this, message);
      err.__proto__ = TransformError2.prototype;
      return err;
    };
    TransformError.prototype = Object.create(Error.prototype);
    TransformError.prototype.constructor = TransformError;
    TransformError.prototype.name = "TransformError";
    Transform = class {
      /**
      Create a transform that starts with the given document.
      */
      constructor(doc3) {
        this.doc = doc3;
        this.steps = [];
        this.docs = [];
        this.mapping = new Mapping();
      }
      /**
      The starting document.
      */
      get before() {
        return this.docs.length ? this.docs[0] : this.doc;
      }
      /**
      Apply a new step in this transform, saving the result. Throws an
      error when the step fails.
      */
      step(step) {
        let result = this.maybeStep(step);
        if (result.failed)
          throw new TransformError(result.failed);
        return this;
      }
      /**
      Try to apply a step in this transformation, ignoring it if it
      fails. Returns the step result.
      */
      maybeStep(step) {
        let result = step.apply(this.doc);
        if (!result.failed)
          this.addStep(step, result.doc);
        return result;
      }
      /**
      True when the document has been changed (when there are any
      steps).
      */
      get docChanged() {
        return this.steps.length > 0;
      }
      /**
      @internal
      */
      addStep(step, doc3) {
        this.docs.push(this.doc);
        this.steps.push(step);
        this.mapping.appendMap(step.getMap());
        this.doc = doc3;
      }
      /**
      Replace the part of the document between `from` and `to` with the
      given `slice`.
      */
      replace(from2, to = from2, slice2 = Slice.empty) {
        let step = replaceStep(this.doc, from2, to, slice2);
        if (step)
          this.step(step);
        return this;
      }
      /**
      Replace the given range with the given content, which may be a
      fragment, node, or array of nodes.
      */
      replaceWith(from2, to, content) {
        return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
      }
      /**
      Delete the content between the given positions.
      */
      delete(from2, to) {
        return this.replace(from2, to, Slice.empty);
      }
      /**
      Insert the given content at the given position.
      */
      insert(pos, content) {
        return this.replaceWith(pos, pos, content);
      }
      /**
      Replace a range of the document with a given slice, using
      `from`, `to`, and the slice's
      [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
      than fixed start and end points. This method may grow the
      replaced area or close open nodes in the slice in order to get a
      fit that is more in line with WYSIWYG expectations, by dropping
      fully covered parent nodes of the replaced region when they are
      marked [non-defining as
      context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
      open parent node from the slice that _is_ marked as [defining
      its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
      
      This is the method, for example, to handle paste. The similar
      [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
      primitive tool which will _not_ move the start and end of its given
      range, and is useful in situations where you need more precise
      control over what happens.
      */
      replaceRange(from2, to, slice2) {
        replaceRange(this, from2, to, slice2);
        return this;
      }
      /**
      Replace the given range with a node, but use `from` and `to` as
      hints, rather than precise positions. When from and to are the same
      and are at the start or end of a parent node in which the given
      node doesn't fit, this method may _move_ them out towards a parent
      that does allow the given node to be placed. When the given range
      completely covers a parent node, this method may completely replace
      that parent node.
      */
      replaceRangeWith(from2, to, node) {
        replaceRangeWith(this, from2, to, node);
        return this;
      }
      /**
      Delete the given range, expanding it to cover fully covered
      parent nodes until a valid replace is found.
      */
      deleteRange(from2, to) {
        deleteRange(this, from2, to);
        return this;
      }
      /**
      Split the content in the given range off from its parent, if there
      is sibling content before or after it, and move it up the tree to
      the depth specified by `target`. You'll probably want to use
      [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
      sure the lift is valid.
      */
      lift(range, target) {
        lift(this, range, target);
        return this;
      }
      /**
      Join the blocks around the given position. If depth is 2, their
      last and first siblings are also joined, and so on.
      */
      join(pos, depth = 1) {
        join(this, pos, depth);
        return this;
      }
      /**
      Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
      The wrappers are assumed to be valid in this position, and should
      probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
      */
      wrap(range, wrappers) {
        wrap(this, range, wrappers);
        return this;
      }
      /**
      Set the type of all textblocks (partly) between `from` and `to` to
      the given node type with the given attributes.
      */
      setBlockType(from2, to = from2, type, attrs = null) {
        setBlockType(this, from2, to, type, attrs);
        return this;
      }
      /**
      Change the type, attributes, and/or marks of the node at `pos`.
      When `type` isn't given, the existing node type is preserved,
      */
      setNodeMarkup(pos, type, attrs = null, marks) {
        setNodeMarkup(this, pos, type, attrs, marks);
        return this;
      }
      /**
      Set a single attribute on a given node to a new value.
      */
      setNodeAttribute(pos, attr, value) {
        this.step(new AttrStep(pos, attr, value));
        return this;
      }
      /**
      Add a mark to the node at position `pos`.
      */
      addNodeMark(pos, mark) {
        this.step(new AddNodeMarkStep(pos, mark));
        return this;
      }
      /**
      Remove a mark (or a mark of the given type) from the node at
      position `pos`.
      */
      removeNodeMark(pos, mark) {
        if (!(mark instanceof Mark)) {
          let node = this.doc.nodeAt(pos);
          if (!node)
            throw new RangeError("No node at position " + pos);
          mark = mark.isInSet(node.marks);
          if (!mark)
            return this;
        }
        this.step(new RemoveNodeMarkStep(pos, mark));
        return this;
      }
      /**
      Split the node at the given position, and optionally, if `depth` is
      greater than one, any number of nodes above that. By default, the
      parts split off will inherit the node type of the original node.
      This can be changed by passing an array of types and attributes to
      use after the split.
      */
      split(pos, depth = 1, typesAfter) {
        split(this, pos, depth, typesAfter);
        return this;
      }
      /**
      Add the given mark to the inline content between `from` and `to`.
      */
      addMark(from2, to, mark) {
        addMark(this, from2, to, mark);
        return this;
      }
      /**
      Remove marks from inline nodes between `from` and `to`. When
      `mark` is a single mark, remove precisely that mark. When it is
      a mark type, remove all marks of that type. When it is null,
      remove all marks of any type.
      */
      removeMark(from2, to, mark) {
        removeMark(this, from2, to, mark);
        return this;
      }
      /**
      Removes all marks and nodes from the content of the node at
      `pos` that don't match the given new parent node type. Accepts
      an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
      third argument.
      */
      clearIncompatible(pos, parentType, match) {
        clearIncompatible(this, pos, parentType, match);
        return this;
      }
    };
  }
});

// node_modules/.pnpm/prosemirror-state@1.4.3/node_modules/prosemirror-state/dist/index.js
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
function findSelectionIn(doc3, node, pos, index8, dir, text3 = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i2 = index8 - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node.childCount : i2 >= 0; i2 += dir) {
    let child = node.child(i2);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text3);
      if (inner)
        return inner;
    } else if (!text3 && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  let last2 = tr2.steps.length - 1;
  if (last2 < startLen)
    return;
  let step = tr2.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr2.mapping.maps[last2], end;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}
function bindProps(obj, self, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target;
}
function createKey(name3) {
  if (name3 in keys)
    return name3 + "$" + ++keys[name3];
  keys[name3] = 0;
  return name3 + "$";
}
var classesById, Selection, SelectionRange, warnedAboutTextSelection, TextSelection, TextBookmark, NodeSelection, NodeBookmark, AllSelection, AllBookmark, FieldDesc, baseFields, Plugin, keys, PluginKey;
var init_dist6 = __esm({
  "node_modules/.pnpm/prosemirror-state@1.4.3/node_modules/prosemirror-state/dist/index.js"() {
    init_dist4();
    init_dist5();
    classesById = /* @__PURE__ */ Object.create(null);
    Selection = class {
      /**
      Initialize a selection with the head and anchor and ranges. If no
      ranges are given, constructs a single range across `$anchor` and
      `$head`.
      */
      constructor($anchor, $head, ranges) {
        this.$anchor = $anchor;
        this.$head = $head;
        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
      }
      /**
      The selection's anchor, as an unresolved position.
      */
      get anchor() {
        return this.$anchor.pos;
      }
      /**
      The selection's head.
      */
      get head() {
        return this.$head.pos;
      }
      /**
      The lower bound of the selection's main range.
      */
      get from() {
        return this.$from.pos;
      }
      /**
      The upper bound of the selection's main range.
      */
      get to() {
        return this.$to.pos;
      }
      /**
      The resolved lower  bound of the selection's main range.
      */
      get $from() {
        return this.ranges[0].$from;
      }
      /**
      The resolved upper bound of the selection's main range.
      */
      get $to() {
        return this.ranges[0].$to;
      }
      /**
      Indicates whether the selection contains any content.
      */
      get empty() {
        let ranges = this.ranges;
        for (let i2 = 0; i2 < ranges.length; i2++)
          if (ranges[i2].$from.pos != ranges[i2].$to.pos)
            return false;
        return true;
      }
      /**
      Get the content of this selection as a slice.
      */
      content() {
        return this.$from.doc.slice(this.from, this.to, true);
      }
      /**
      Replace the selection with a slice or, if no slice is given,
      delete the selection. Will append to the given transaction.
      */
      replace(tr2, content = Slice.empty) {
        let lastNode = content.content.lastChild, lastParent = null;
        for (let i2 = 0; i2 < content.openEnd; i2++) {
          lastParent = lastNode;
          lastNode = lastNode.lastChild;
        }
        let mapFrom = tr2.steps.length, ranges = this.ranges;
        for (let i2 = 0; i2 < ranges.length; i2++) {
          let { $from, $to } = ranges[i2], mapping = tr2.mapping.slice(mapFrom);
          tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i2 ? Slice.empty : content);
          if (i2 == 0)
            selectionToInsertionEnd(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
        }
      }
      /**
      Replace the selection with the given node, appending the changes
      to the given transaction.
      */
      replaceWith(tr2, node) {
        let mapFrom = tr2.steps.length, ranges = this.ranges;
        for (let i2 = 0; i2 < ranges.length; i2++) {
          let { $from, $to } = ranges[i2], mapping = tr2.mapping.slice(mapFrom);
          let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
          if (i2) {
            tr2.deleteRange(from2, to);
          } else {
            tr2.replaceRangeWith(from2, to, node);
            selectionToInsertionEnd(tr2, mapFrom, node.isInline ? -1 : 1);
          }
        }
      }
      /**
      Find a valid cursor or leaf node selection starting at the given
      position and searching back if `dir` is negative, and forward if
      positive. When `textOnly` is true, only consider cursor
      selections. Will return null when no valid selection position is
      found.
      */
      static findFrom($pos, dir, textOnly = false) {
        let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
        if (inner)
          return inner;
        for (let depth = $pos.depth - 1; depth >= 0; depth--) {
          let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
          if (found2)
            return found2;
        }
        return null;
      }
      /**
      Find a valid cursor or leaf node selection near the given
      position. Searches forward first by default, but if `bias` is
      negative, it will search backwards first.
      */
      static near($pos, bias = 1) {
        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
      }
      /**
      Find the cursor or leaf node selection closest to the start of
      the given document. Will return an
      [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
      exists.
      */
      static atStart(doc3) {
        return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
      }
      /**
      Find the cursor or leaf node selection closest to the end of the
      given document.
      */
      static atEnd(doc3) {
        return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
      }
      /**
      Deserialize the JSON representation of a selection. Must be
      implemented for custom classes (as a static class method).
      */
      static fromJSON(doc3, json2) {
        if (!json2 || !json2.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        let cls = classesById[json2.type];
        if (!cls)
          throw new RangeError(`No selection type ${json2.type} defined`);
        return cls.fromJSON(doc3, json2);
      }
      /**
      To be able to deserialize selections from JSON, custom selection
      classes must register themselves with an ID string, so that they
      can be disambiguated. Try to pick something that's unlikely to
      clash with classes from other modules.
      */
      static jsonID(id, selectionClass) {
        if (id in classesById)
          throw new RangeError("Duplicate use of selection JSON ID " + id);
        classesById[id] = selectionClass;
        selectionClass.prototype.jsonID = id;
        return selectionClass;
      }
      /**
      Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
      which is a value that can be mapped without having access to a
      current document, and later resolved to a real selection for a
      given document again. (This is used mostly by the history to
      track and restore old selections.) The default implementation of
      this method just converts the selection to a text selection and
      returns the bookmark for that.
      */
      getBookmark() {
        return TextSelection.between(this.$anchor, this.$head).getBookmark();
      }
    };
    Selection.prototype.visible = true;
    SelectionRange = class {
      /**
      Create a range.
      */
      constructor($from, $to) {
        this.$from = $from;
        this.$to = $to;
      }
    };
    warnedAboutTextSelection = false;
    TextSelection = class _TextSelection extends Selection {
      /**
      Construct a text selection between the given points.
      */
      constructor($anchor, $head = $anchor) {
        checkTextSelection($anchor);
        checkTextSelection($head);
        super($anchor, $head);
      }
      /**
      Returns a resolved position if this is a cursor selection (an
      empty text selection), and null otherwise.
      */
      get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
      map(doc3, mapping) {
        let $head = doc3.resolve(mapping.map(this.head));
        if (!$head.parent.inlineContent)
          return Selection.near($head);
        let $anchor = doc3.resolve(mapping.map(this.anchor));
        return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
      }
      replace(tr2, content = Slice.empty) {
        super.replace(tr2, content);
        if (content == Slice.empty) {
          let marks = this.$from.marksAcross(this.$to);
          if (marks)
            tr2.ensureMarks(marks);
        }
      }
      eq(other) {
        return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
      }
      getBookmark() {
        return new TextBookmark(this.anchor, this.head);
      }
      toJSON() {
        return { type: "text", anchor: this.anchor, head: this.head };
      }
      /**
      @internal
      */
      static fromJSON(doc3, json2) {
        if (typeof json2.anchor != "number" || typeof json2.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new _TextSelection(doc3.resolve(json2.anchor), doc3.resolve(json2.head));
      }
      /**
      Create a text selection from non-resolved positions.
      */
      static create(doc3, anchor, head = anchor) {
        let $anchor = doc3.resolve(anchor);
        return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
      }
      /**
      Return a text selection that spans the given positions or, if
      they aren't text positions, find a text selection near them.
      `bias` determines whether the method searches forward (default)
      or backwards (negative number) first. Will fall back to calling
      [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
      doesn't contain a valid text position.
      */
      static between($anchor, $head, bias) {
        let dPos = $anchor.pos - $head.pos;
        if (!bias || dPos)
          bias = dPos >= 0 ? 1 : -1;
        if (!$head.parent.inlineContent) {
          let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
          if (found2)
            $head = found2.$head;
          else
            return Selection.near($head, bias);
        }
        if (!$anchor.parent.inlineContent) {
          if (dPos == 0) {
            $anchor = $head;
          } else {
            $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
            if ($anchor.pos < $head.pos != dPos < 0)
              $anchor = $head;
          }
        }
        return new _TextSelection($anchor, $head);
      }
    };
    Selection.jsonID("text", TextSelection);
    TextBookmark = class _TextBookmark {
      constructor(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      }
      map(mapping) {
        return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
      }
      resolve(doc3) {
        return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
      }
    };
    NodeSelection = class _NodeSelection extends Selection {
      /**
      Create a node selection. Does not verify the validity of its
      argument.
      */
      constructor($pos) {
        let node = $pos.nodeAfter;
        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
        super($pos, $end);
        this.node = node;
      }
      map(doc3, mapping) {
        let { deleted, pos } = mapping.mapResult(this.anchor);
        let $pos = doc3.resolve(pos);
        if (deleted)
          return Selection.near($pos);
        return new _NodeSelection($pos);
      }
      content() {
        return new Slice(Fragment.from(this.node), 0, 0);
      }
      eq(other) {
        return other instanceof _NodeSelection && other.anchor == this.anchor;
      }
      toJSON() {
        return { type: "node", anchor: this.anchor };
      }
      getBookmark() {
        return new NodeBookmark(this.anchor);
      }
      /**
      @internal
      */
      static fromJSON(doc3, json2) {
        if (typeof json2.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new _NodeSelection(doc3.resolve(json2.anchor));
      }
      /**
      Create a node selection from non-resolved positions.
      */
      static create(doc3, from2) {
        return new _NodeSelection(doc3.resolve(from2));
      }
      /**
      Determines whether the given node may be selected as a node
      selection.
      */
      static isSelectable(node) {
        return !node.isText && node.type.spec.selectable !== false;
      }
    };
    NodeSelection.prototype.visible = false;
    Selection.jsonID("node", NodeSelection);
    NodeBookmark = class _NodeBookmark {
      constructor(anchor) {
        this.anchor = anchor;
      }
      map(mapping) {
        let { deleted, pos } = mapping.mapResult(this.anchor);
        return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
      }
      resolve(doc3) {
        let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
        if (node && NodeSelection.isSelectable(node))
          return new NodeSelection($pos);
        return Selection.near($pos);
      }
    };
    AllSelection = class _AllSelection extends Selection {
      /**
      Create an all-selection over the given document.
      */
      constructor(doc3) {
        super(doc3.resolve(0), doc3.resolve(doc3.content.size));
      }
      replace(tr2, content = Slice.empty) {
        if (content == Slice.empty) {
          tr2.delete(0, tr2.doc.content.size);
          let sel = Selection.atStart(tr2.doc);
          if (!sel.eq(tr2.selection))
            tr2.setSelection(sel);
        } else {
          super.replace(tr2, content);
        }
      }
      toJSON() {
        return { type: "all" };
      }
      /**
      @internal
      */
      static fromJSON(doc3) {
        return new _AllSelection(doc3);
      }
      map(doc3) {
        return new _AllSelection(doc3);
      }
      eq(other) {
        return other instanceof _AllSelection;
      }
      getBookmark() {
        return AllBookmark;
      }
    };
    Selection.jsonID("all", AllSelection);
    AllBookmark = {
      map() {
        return this;
      },
      resolve(doc3) {
        return new AllSelection(doc3);
      }
    };
    FieldDesc = class {
      constructor(name3, desc2, self) {
        this.name = name3;
        this.init = bind(desc2.init, self);
        this.apply = bind(desc2.apply, self);
      }
    };
    baseFields = [
      new FieldDesc("doc", {
        init(config) {
          return config.doc || config.schema.topNodeType.createAndFill();
        },
        apply(tr2) {
          return tr2.doc;
        }
      }),
      new FieldDesc("selection", {
        init(config, instance) {
          return config.selection || Selection.atStart(instance.doc);
        },
        apply(tr2) {
          return tr2.selection;
        }
      }),
      new FieldDesc("storedMarks", {
        init(config) {
          return config.storedMarks || null;
        },
        apply(tr2, _marks, _old, state) {
          return state.selection.$cursor ? tr2.storedMarks : null;
        }
      }),
      new FieldDesc("scrollToSelection", {
        init() {
          return 0;
        },
        apply(tr2, prev) {
          return tr2.scrolledIntoView ? prev + 1 : prev;
        }
      })
    ];
    Plugin = class {
      /**
      Create a plugin.
      */
      constructor(spec) {
        this.spec = spec;
        this.props = {};
        if (spec.props)
          bindProps(spec.props, this, this.props);
        this.key = spec.key ? spec.key.key : createKey("plugin");
      }
      /**
      Extract the plugin's state field from an editor state.
      */
      getState(state) {
        return state[this.key];
      }
    };
    keys = /* @__PURE__ */ Object.create(null);
    PluginKey = class {
      /**
      Create a plugin key.
      */
      constructor(name3 = "key") {
        this.key = createKey(name3);
      }
      /**
      Get the active plugin with this key, if any, from an editor
      state.
      */
      get(state) {
        return state.config.pluginsByKey[this.key];
      }
      /**
      Get the plugin's state from an editor state.
      */
      getState(state) {
        return state[this.key];
      }
    };
  }
});

// node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/state/dist/index.js
var init_dist7 = __esm({
  "node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/state/dist/index.js"() {
    init_dist6();
  }
});

// node_modules/.pnpm/prosemirror-view@1.31.8/node_modules/prosemirror-view/dist/index.js
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isOnEdge(node, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index8 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index8 == 0;
    atEnd = atEnd && index8 == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc2;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc2 = cur.pmViewDesc)
      break;
  return desc2 && desc2.node && desc2.node.isBlock && (desc2.dom == dom || desc2.contentDOM == dom);
}
function keyEvent(keyCode, key3) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key3;
  return event;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc3.resolve(anchor);
  }
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  let before = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setEnd(node.parentNode, domIndex(node) + 1);
  else
    range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc2 = view.docView.descAt(sel.from);
    if (desc2 != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc2)
        desc2.selectNode();
      view.lastSelectedViewDesc = desc2;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc2;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc2 = view.docView.descAt(nodePos)) && !desc2.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  if (dom.contentEditable == "false")
    return true;
  let desc2 = dom.pmViewDesc;
  return desc2 && desc2.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset2 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node = before;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset2];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc2 = dom.pmViewDesc;
  return desc2 && desc2.node && desc2.node.isBlock;
}
function textNodeAfter(node, offset2) {
  while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset2 < node.childNodes.length) {
    let next = node.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = 0;
  }
}
function textNodeBefore(node, offset2) {
  while (node && !offset2 && !hasBlockDesc(node)) {
    offset2 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset2) {
    let next = node.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset2) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset2)) {
      node = after;
      offset2 = 0;
    } else if (before = textNodeBefore(node, offset2)) {
      node = before;
      offset2 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset2);
    range.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i2 = needsWrap.length - 1; i2 >= 0; i2--) {
      let wrapper = doc3.createElement(needsWrap[i2]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text3 = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text: text3 };
}
function parseFromClipboard(view, text3, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text3)
    return null;
  let asText = text3 && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text3 = f(text3, inCode || plainText, view);
    });
    if (inCode)
      return text3 ? new Slice(Fragment.from(view.state.schema.text(text3.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text3, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema: schema3 } = view.state, serializer = DOMSerializer.fromSchema(schema3);
      dom = document.createElement("div");
      text3.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p2 = dom.appendChild(document.createElement("p"));
        if (block)
          p2.appendChild(serializer.serializeNode(schema3.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i2 = +sliceData[3]; i2 > 0; i2--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i2 = wrap2.length - 1; i2 >= from2; i2--)
    node = wrap2[i2].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = html;
  if (wrap2)
    for (let i2 = 0; i2 < wrap2.length; i2++)
      elt = elt.querySelector(wrap2[i2]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i2 = 0; i2 < nodes.length; i2++) {
    let node = nodes[i2];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema3 = slice2.content.firstChild.type.schema, array2;
  try {
    array2 = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i2 = array2.length - 2; i2 >= 0; i2 -= 2) {
    let type = schema3.nodes[array2[i2]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array2[i2 + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    if (view.someProp(propName, (f) => i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  let tr2 = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i2);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    let nodePos = $pos.before(i2);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
function scheduleComposeEnd(view, delay3) {
  clearTimeout(view.input.composingTimeout);
  if (delay3 > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay3);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text3, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text3, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function compareObjs(a2, b) {
  if (a2 == b)
    return true;
  for (let p2 in a2)
    if (a2[p2] !== b[p2])
      return false;
  for (let p2 in b)
    if (!(p2 in a2))
      return false;
  return true;
}
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options2) {
  let children = oldChildren.slice();
  for (let i2 = 0, baseOffset = oldOffset; i2 < mapping.maps.length; i2++) {
    let moved = 0;
    mapping.maps[i2].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i3 = 0; i3 < children.length; i3 += 3) {
        let end = children[i3 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start = children[i3] + baseOffset - moved;
        if (oldEnd >= start) {
          children[i3 + 1] = oldStart <= start ? -2 : -1;
        } else if (newStart >= offset2 && dSize) {
          children[i3] += dSize;
          children[i3 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i2].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i2 = 0; i2 < children.length; i2 += 3)
    if (children[i2 + 1] < 0) {
      if (children[i2 + 1] == -2) {
        mustRebuild = true;
        children[i2 + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i2] + oldOffset), fromLocal = from2 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i2 + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index: index8, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index8);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i2 + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i2] + oldOffset + 1, options2);
        if (mapped != empty) {
          children[i2] = fromLocal;
          children[i2 + 1] = toLocal;
          children[i2 + 2] = mapped;
        } else {
          children[i2 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options2);
    let built = buildTree(decorations, node, 0, options2);
    newLocal = built.local;
    for (let i2 = 0; i2 < children.length; i2 += 3)
      if (children[i2 + 1] < 0) {
        children.splice(i2, 3);
        i2 -= 3;
      }
    for (let i2 = 0, j2 = 0; i2 < built.children.length; i2 += 3) {
      let from2 = built.children[i2];
      while (j2 < children.length && children[j2] < from2)
        j2 += 3;
      children.splice(j2, 0, built.children[i2], built.children[i2 + 1], built.children[i2 + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i2 = 0; i2 < spans.length; i2++) {
    let span = spans[i2];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options2) {
  function gather(set2, oldOffset2) {
    for (let i2 = 0; i2 < set2.local.length; i2++) {
      let mapped = set2.local[i2].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options2.onRemove)
        options2.onRemove(set2.local[i2].spec);
    }
    for (let i2 = 0; i2 < set2.children.length; i2 += 3)
      gather(set2.children[i2 + 2], set2.children[i2] + oldOffset2 + 1);
  }
  for (let i2 = 0; i2 < children.length; i2 += 3)
    if (children[i2 + 1] == -1)
      gather(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  let end = offset2 + node.nodeSize, found2 = null;
  for (let i2 = 0, span; i2 < spans.length; i2++) {
    if ((span = spans[i2]) && span.from > offset2 && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i2] = null;
    }
  }
  return found2;
}
function withoutNulls(array2) {
  let result = [];
  for (let i2 = 0; i2 < array2.length; i2++)
    if (array2[i2] != null)
      result.push(array2[i2]);
  return result;
}
function buildTree(spans, node, offset2, options2) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options2);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i2 = 0; i2 < locals.length; i2++)
    if (!locals[i2].type.valid(node, locals[i2])) {
      if (options2.onRemove)
        options2.onRemove(locals[i2].spec);
      locals.splice(i2--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a2, b) {
  return a2.from - b.from || a2.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i2 = 0; i2 < working.length - 1; i2++) {
    let span = working[i2];
    if (span.from != span.to)
      for (let j2 = i2 + 1; j2 < working.length; j2++) {
        let next = working[j2];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j2] = next.copy(next.from, span.to);
            insertAhead(working, j2 + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i2] = span.copy(span.from, next.from);
            insertAhead(working, j2, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array2, i2, deco) {
  while (i2 < array2.length && byPos(deco, array2[i2]) > 0)
    i2++;
  array2.splice(i2, 0, deco);
}
var domIndex, isEquivalentPosition, atomElements, selectionCollapsed, nav, doc2, agent, ie_edge, ie_upto10, ie_11up, ie, ie_version, gecko, _chrome, chrome, chrome_version, safari, ios, mac, windows, android, webkit, webkit_version, OuterDecoLevel, noDeco, brokenSelectBetweenUneditable, inlineParents, wrapMap, _detachedDoc, handlers, editHandlers, selectNodeModifier, MouseDown, timeoutComposition, brokenClipboardAPI, Dragging, dragCopyModifier, WidgetType, InlineType, NodeType, Decoration, none, noSpec, DecorationSet, empty, DecorationGroup, useCharData;
var init_dist8 = __esm({
  "node_modules/.pnpm/prosemirror-view@1.31.8/node_modules/prosemirror-view/dist/index.js"() {
    init_dist6();
    init_dist4();
    init_dist5();
    domIndex = function(node) {
      for (var index8 = 0; ; index8++) {
        node = node.previousSibling;
        if (!node)
          return index8;
      }
    };
    isEquivalentPosition = function(node, off, targetNode, targetOff) {
      return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
    };
    atomElements = /^(img|br|input|textarea|hr)$/i;
    selectionCollapsed = function(domSel) {
      return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
    };
    nav = typeof navigator != "undefined" ? navigator : null;
    doc2 = typeof document != "undefined" ? document : null;
    agent = nav && nav.userAgent || "";
    ie_edge = /Edge\/(\d+)/.exec(agent);
    ie_upto10 = /MSIE \d/.exec(agent);
    ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
    ie = !!(ie_upto10 || ie_11up || ie_edge);
    ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
    gecko = !ie && /gecko\/(\d+)/i.test(agent);
    gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
    _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
    chrome = !!_chrome;
    chrome_version = _chrome ? +_chrome[1] : 0;
    safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
    ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
    mac = ios || (nav ? /Mac/.test(nav.platform) : false);
    windows = nav ? /Win/.test(nav.platform) : false;
    android = /Android \d/.test(agent);
    webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
    webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    OuterDecoLevel = function(nodeName) {
      if (nodeName)
        this.nodeName = nodeName;
    };
    OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
    noDeco = [new OuterDecoLevel()];
    brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
    inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    wrapMap = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    _detachedDoc = null;
    handlers = {};
    editHandlers = {};
    editHandlers.keydown = (view, _event) => {
      let event = _event;
      view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
      if (inOrNearComposition(view, event))
        return;
      view.input.lastKeyCode = event.keyCode;
      view.input.lastKeyCodeTime = Date.now();
      if (android && chrome && event.keyCode == 13)
        return;
      if (event.keyCode != 229)
        view.domObserver.forceFlush();
      if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        let now = Date.now();
        view.input.lastIOSEnter = now;
        view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
          if (view.input.lastIOSEnter == now) {
            view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
            view.input.lastIOSEnter = 0;
          }
        }, 200);
      } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "key");
      }
    };
    editHandlers.keyup = (view, event) => {
      if (event.keyCode == 16)
        view.input.shiftKey = false;
    };
    editHandlers.keypress = (view, _event) => {
      let event = _event;
      if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
        return;
      if (view.someProp("handleKeyPress", (f) => f(view, event))) {
        event.preventDefault();
        return;
      }
      let sel = view.state.selection;
      if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
        let text3 = String.fromCharCode(event.charCode);
        if (!/[\r\n]/.test(text3) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text3)))
          view.dispatch(view.state.tr.insertText(text3).scrollIntoView());
        event.preventDefault();
      }
    };
    selectNodeModifier = mac ? "metaKey" : "ctrlKey";
    handlers.mousedown = (view, _event) => {
      let event = _event;
      view.input.shiftKey = event.shiftKey;
      let flushed = forceDOMFlush(view);
      let now = Date.now(), type = "singleClick";
      if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
        if (view.input.lastClick.type == "singleClick")
          type = "doubleClick";
        else if (view.input.lastClick.type == "doubleClick")
          type = "tripleClick";
      }
      view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
      let pos = view.posAtCoords(eventCoords(event));
      if (!pos)
        return;
      if (type == "singleClick") {
        if (view.input.mouseDown)
          view.input.mouseDown.done();
        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
      } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "pointer");
      }
    };
    MouseDown = class {
      constructor(view, pos, event, flushed) {
        this.view = view;
        this.pos = pos;
        this.event = event;
        this.flushed = flushed;
        this.delayedSelectionSync = false;
        this.mightDrag = null;
        this.startDoc = view.state.doc;
        this.selectNode = !!event[selectNodeModifier];
        this.allowDefault = event.shiftKey;
        let targetNode, targetPos;
        if (pos.inside > -1) {
          targetNode = view.state.doc.nodeAt(pos.inside);
          targetPos = pos.inside;
        } else {
          let $pos = view.state.doc.resolve(pos.pos);
          targetNode = $pos.parent;
          targetPos = $pos.depth ? $pos.before() : 0;
        }
        const target = flushed ? null : event.target;
        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
        this.target = targetDesc ? targetDesc.dom : null;
        let { selection } = view.state;
        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
          this.mightDrag = {
            node: targetNode,
            pos: targetPos,
            addAttr: !!(this.target && !this.target.draggable),
            setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
          };
        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr)
            this.target.draggable = true;
          if (this.mightDrag.setUneditable)
            setTimeout(() => {
              if (this.view.input.mouseDown == this)
                this.target.setAttribute("contentEditable", "false");
            }, 20);
          this.view.domObserver.start();
        }
        view.root.addEventListener("mouseup", this.up = this.up.bind(this));
        view.root.addEventListener("mousemove", this.move = this.move.bind(this));
        setSelectionOrigin(view, "pointer");
      }
      done() {
        this.view.root.removeEventListener("mouseup", this.up);
        this.view.root.removeEventListener("mousemove", this.move);
        if (this.mightDrag && this.target) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr)
            this.target.removeAttribute("draggable");
          if (this.mightDrag.setUneditable)
            this.target.removeAttribute("contentEditable");
          this.view.domObserver.start();
        }
        if (this.delayedSelectionSync)
          setTimeout(() => selectionToDOM(this.view));
        this.view.input.mouseDown = null;
      }
      up(event) {
        this.done();
        if (!this.view.dom.contains(event.target))
          return;
        let pos = this.pos;
        if (this.view.state.doc != this.startDoc)
          pos = this.view.posAtCoords(eventCoords(event));
        this.updateAllowDefault(event);
        if (this.allowDefault || !pos) {
          setSelectionOrigin(this.view, "pointer");
        } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
          event.preventDefault();
        } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
        safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
        // cursor, but still report that the node is selected
        // when asked through getSelection. You'll then get a
        // situation where clicking at the point where that
        // (hidden) cursor is doesn't change the selection, and
        // thus doesn't get a reaction from ProseMirror. This
        // works around that.
        chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
          updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
          event.preventDefault();
        } else {
          setSelectionOrigin(this.view, "pointer");
        }
      }
      move(event) {
        this.updateAllowDefault(event);
        setSelectionOrigin(this.view, "pointer");
        if (event.buttons == 0)
          this.done();
      }
      updateAllowDefault(event) {
        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
          this.allowDefault = true;
      }
    };
    handlers.touchstart = (view) => {
      view.input.lastTouch = Date.now();
      forceDOMFlush(view);
      setSelectionOrigin(view, "pointer");
    };
    handlers.touchmove = (view) => {
      view.input.lastTouch = Date.now();
      setSelectionOrigin(view, "pointer");
    };
    handlers.contextmenu = (view) => forceDOMFlush(view);
    timeoutComposition = android ? 5e3 : -1;
    editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
      if (!view.composing) {
        view.domObserver.flush();
        let { state } = view, $pos = state.selection.$from;
        if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
          view.markCursor = view.state.storedMarks || $pos.marks();
          endComposition(view, true);
          view.markCursor = null;
        } else {
          endComposition(view);
          if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
            let sel = view.domSelectionRange();
            for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
              let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
              if (!before)
                break;
              if (before.nodeType == 3) {
                view.domSelection().collapse(before, before.nodeValue.length);
                break;
              } else {
                node = before;
                offset2 = -1;
              }
            }
          }
        }
        view.input.composing = true;
      }
      scheduleComposeEnd(view, timeoutComposition);
    };
    editHandlers.compositionend = (view, event) => {
      if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = event.timeStamp;
        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
        if (view.input.compositionPendingChanges)
          Promise.resolve().then(() => view.domObserver.flush());
        view.input.compositionID++;
        scheduleComposeEnd(view, 20);
      }
    };
    brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
    handlers.copy = editHandlers.cut = (view, _event) => {
      let event = _event;
      let sel = view.state.selection, cut2 = event.type == "cut";
      if (sel.empty)
        return;
      let data = brokenClipboardAPI ? null : event.clipboardData;
      let slice2 = sel.content(), { dom, text: text3 } = serializeForClipboard(view, slice2);
      if (data) {
        event.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text3);
      } else {
        captureCopy(view, dom);
      }
      if (cut2)
        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    };
    editHandlers.paste = (view, _event) => {
      let event = _event;
      if (view.composing && !android)
        return;
      let data = brokenClipboardAPI ? null : event.clipboardData;
      let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
      if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), plain, event))
        event.preventDefault();
      else
        capturePaste(view, event);
    };
    Dragging = class {
      constructor(slice2, move) {
        this.slice = slice2;
        this.move = move;
      }
    };
    dragCopyModifier = mac ? "altKey" : "ctrlKey";
    handlers.dragstart = (view, _event) => {
      let event = _event;
      let mouseDown = view.input.mouseDown;
      if (mouseDown)
        mouseDown.done();
      if (!event.dataTransfer)
        return;
      let sel = view.state.selection;
      let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
      if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
        ;
      else if (mouseDown && mouseDown.mightDrag) {
        view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
      } else if (event.target && event.target.nodeType == 1) {
        let desc2 = view.docView.nearestDesc(event.target, true);
        if (desc2 && desc2.node.type.spec.draggable && desc2 != view.docView)
          view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc2.posBefore)));
      }
      let slice2 = view.state.selection.content(), { dom, text: text3 } = serializeForClipboard(view, slice2);
      event.dataTransfer.clearData();
      event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
      event.dataTransfer.effectAllowed = "copyMove";
      if (!brokenClipboardAPI)
        event.dataTransfer.setData("text/plain", text3);
      view.dragging = new Dragging(slice2, !event[dragCopyModifier]);
    };
    handlers.dragend = (view) => {
      let dragging = view.dragging;
      window.setTimeout(() => {
        if (view.dragging == dragging)
          view.dragging = null;
      }, 50);
    };
    editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
    editHandlers.drop = (view, _event) => {
      let event = _event;
      let dragging = view.dragging;
      view.dragging = null;
      if (!event.dataTransfer)
        return;
      let eventPos = view.posAtCoords(eventCoords(event));
      if (!eventPos)
        return;
      let $mouse = view.state.doc.resolve(eventPos.pos);
      let slice2 = dragging && dragging.slice;
      if (slice2) {
        view.someProp("transformPasted", (f) => {
          slice2 = f(slice2, view);
        });
      } else {
        slice2 = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
      }
      let move = !!(dragging && !event[dragCopyModifier]);
      if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
        event.preventDefault();
        return;
      }
      if (!slice2)
        return;
      event.preventDefault();
      let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
      if (insertPos == null)
        insertPos = $mouse.pos;
      let tr2 = view.state.tr;
      if (move)
        tr2.deleteSelection();
      let pos = tr2.mapping.map(insertPos);
      let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
      let beforeInsert = tr2.doc;
      if (isNode2)
        tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
      else
        tr2.replaceRange(pos, pos, slice2);
      if (tr2.doc.eq(beforeInsert))
        return;
      let $pos = tr2.doc.resolve(pos);
      if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
        tr2.setSelection(new NodeSelection($pos));
      } else {
        let end = tr2.mapping.map(insertPos);
        tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
        tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end)));
      }
      view.focus();
      view.dispatch(tr2.setMeta("uiEvent", "drop"));
    };
    handlers.focus = (view) => {
      view.input.lastFocus = Date.now();
      if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(() => {
          if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
            selectionToDOM(view);
        }, 20);
      }
    };
    handlers.blur = (view, _event) => {
      let event = _event;
      if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        if (event.relatedTarget && view.dom.contains(event.relatedTarget))
          view.domObserver.currentSelection.clear();
        view.focused = false;
      }
    };
    handlers.beforeinput = (view, _event) => {
      let event = _event;
      if (chrome && android && event.inputType == "deleteContentBackward") {
        view.domObserver.flushSoon();
        let { domChangeCount } = view.input;
        setTimeout(() => {
          if (view.input.domChangeCount != domChangeCount)
            return;
          view.dom.blur();
          view.focus();
          if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
            return;
          let { $cursor } = view.state.selection;
          if ($cursor && $cursor.pos > 0)
            view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
        }, 50);
      }
    };
    for (let prop in editHandlers)
      handlers[prop] = editHandlers[prop];
    WidgetType = class _WidgetType {
      constructor(toDOM, spec) {
        this.toDOM = toDOM;
        this.spec = spec || noSpec;
        this.side = this.spec.side || 0;
      }
      map(mapping, span, offset2, oldOffset) {
        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
        return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
      }
      valid() {
        return true;
      }
      eq(other) {
        return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
      }
      destroy(node) {
        if (this.spec.destroy)
          this.spec.destroy(node);
      }
    };
    InlineType = class _InlineType {
      constructor(attrs, spec) {
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      map(mapping, span, offset2, oldOffset) {
        let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
        return from2 >= to ? null : new Decoration(from2, to, this);
      }
      valid(_, span) {
        return span.from < span.to;
      }
      eq(other) {
        return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
      }
      static is(span) {
        return span.type instanceof _InlineType;
      }
      destroy() {
      }
    };
    NodeType = class _NodeType {
      constructor(attrs, spec) {
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      map(mapping, span, offset2, oldOffset) {
        let from2 = mapping.mapResult(span.from + oldOffset, 1);
        if (from2.deleted)
          return null;
        let to = mapping.mapResult(span.to + oldOffset, -1);
        if (to.deleted || to.pos <= from2.pos)
          return null;
        return new Decoration(from2.pos - offset2, to.pos - offset2, this);
      }
      valid(node, span) {
        let { index: index8, offset: offset2 } = node.content.findIndex(span.from), child;
        return offset2 == span.from && !(child = node.child(index8)).isText && offset2 + child.nodeSize == span.to;
      }
      eq(other) {
        return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
      }
      destroy() {
      }
    };
    Decoration = class _Decoration {
      /**
      @internal
      */
      constructor(from2, to, type) {
        this.from = from2;
        this.to = to;
        this.type = type;
      }
      /**
      @internal
      */
      copy(from2, to) {
        return new _Decoration(from2, to, this.type);
      }
      /**
      @internal
      */
      eq(other, offset2 = 0) {
        return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
      }
      /**
      @internal
      */
      map(mapping, offset2, oldOffset) {
        return this.type.map(mapping, this, offset2, oldOffset);
      }
      /**
      Creates a widget decoration, which is a DOM node that's shown in
      the document at the given position. It is recommended that you
      delay rendering the widget by passing a function that will be
      called when the widget is actually drawn in a view, but you can
      also directly pass a DOM node. `getPos` can be used to find the
      widget's current document position.
      */
      static widget(pos, toDOM, spec) {
        return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
      }
      /**
      Creates an inline decoration, which adds the given attributes to
      each inline node between `from` and `to`.
      */
      static inline(from2, to, attrs, spec) {
        return new _Decoration(from2, to, new InlineType(attrs, spec));
      }
      /**
      Creates a node decoration. `from` and `to` should point precisely
      before and after a node in the document. That node, and only that
      node, will receive the given attributes.
      */
      static node(from2, to, attrs, spec) {
        return new _Decoration(from2, to, new NodeType(attrs, spec));
      }
      /**
      The spec provided when creating this decoration. Can be useful
      if you've stored extra information in that object.
      */
      get spec() {
        return this.type.spec;
      }
      /**
      @internal
      */
      get inline() {
        return this.type instanceof InlineType;
      }
      /**
      @internal
      */
      get widget() {
        return this.type instanceof WidgetType;
      }
    };
    none = [];
    noSpec = {};
    DecorationSet = class _DecorationSet {
      /**
      @internal
      */
      constructor(local, children) {
        this.local = local.length ? local : none;
        this.children = children.length ? children : none;
      }
      /**
      Create a set of decorations, using the structure of the given
      document. This will consume (modify) the `decorations` array, so
      you must make a copy if you want need to preserve that.
      */
      static create(doc3, decorations) {
        return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
      }
      /**
      Find all decorations in this set which touch the given range
      (including decorations that start or end directly at the
      boundaries) and match the given predicate on their spec. When
      `start` and `end` are omitted, all decorations in the set are
      considered. When `predicate` isn't given, all decorations are
      assumed to match.
      */
      find(start, end, predicate) {
        let result = [];
        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
        return result;
      }
      findInner(start, end, result, offset2, predicate) {
        for (let i2 = 0; i2 < this.local.length; i2++) {
          let span = this.local[i2];
          if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
            result.push(span.copy(span.from + offset2, span.to + offset2));
        }
        for (let i2 = 0; i2 < this.children.length; i2 += 3) {
          if (this.children[i2] < end && this.children[i2 + 1] > start) {
            let childOff = this.children[i2] + 1;
            this.children[i2 + 2].findInner(start - childOff, end - childOff, result, offset2 + childOff, predicate);
          }
        }
      }
      /**
      Map the set of decorations in response to a change in the
      document.
      */
      map(mapping, doc3, options2) {
        if (this == empty || mapping.maps.length == 0)
          return this;
        return this.mapInner(mapping, doc3, 0, 0, options2 || noSpec);
      }
      /**
      @internal
      */
      mapInner(mapping, node, offset2, oldOffset, options2) {
        let newLocal;
        for (let i2 = 0; i2 < this.local.length; i2++) {
          let mapped = this.local[i2].map(mapping, offset2, oldOffset);
          if (mapped && mapped.type.valid(node, mapped))
            (newLocal || (newLocal = [])).push(mapped);
          else if (options2.onRemove)
            options2.onRemove(this.local[i2].spec);
        }
        if (this.children.length)
          return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options2);
        else
          return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
      }
      /**
      Add the given array of decorations to the ones in the set,
      producing a new set. Consumes the `decorations` array. Needs
      access to the current document to create the appropriate tree
      structure.
      */
      add(doc3, decorations) {
        if (!decorations.length)
          return this;
        if (this == empty)
          return _DecorationSet.create(doc3, decorations);
        return this.addInner(doc3, decorations, 0);
      }
      addInner(doc3, decorations, offset2) {
        let children, childIndex = 0;
        doc3.forEach((childNode, childOffset) => {
          let baseOffset = childOffset + offset2, found2;
          if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
            return;
          if (!children)
            children = this.children.slice();
          while (childIndex < children.length && children[childIndex] < childOffset)
            childIndex += 3;
          if (children[childIndex] == childOffset)
            children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
          else
            children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
          childIndex += 3;
        });
        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
        for (let i2 = 0; i2 < local.length; i2++)
          if (!local[i2].type.valid(doc3, local[i2]))
            local.splice(i2--, 1);
        return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
      }
      /**
      Create a new set that contains the decorations in this set, minus
      the ones in the given array.
      */
      remove(decorations) {
        if (decorations.length == 0 || this == empty)
          return this;
        return this.removeInner(decorations, 0);
      }
      removeInner(decorations, offset2) {
        let children = this.children, local = this.local;
        for (let i2 = 0; i2 < children.length; i2 += 3) {
          let found2;
          let from2 = children[i2] + offset2, to = children[i2 + 1] + offset2;
          for (let j2 = 0, span; j2 < decorations.length; j2++)
            if (span = decorations[j2]) {
              if (span.from > from2 && span.to < to) {
                decorations[j2] = null;
                (found2 || (found2 = [])).push(span);
              }
            }
          if (!found2)
            continue;
          if (children == this.children)
            children = this.children.slice();
          let removed = children[i2 + 2].removeInner(found2, from2 + 1);
          if (removed != empty) {
            children[i2 + 2] = removed;
          } else {
            children.splice(i2, 3);
            i2 -= 3;
          }
        }
        if (local.length) {
          for (let i2 = 0, span; i2 < decorations.length; i2++)
            if (span = decorations[i2]) {
              for (let j2 = 0; j2 < local.length; j2++)
                if (local[j2].eq(span, offset2)) {
                  if (local == this.local)
                    local = this.local.slice();
                  local.splice(j2--, 1);
                }
            }
        }
        if (children == this.children && local == this.local)
          return this;
        return local.length || children.length ? new _DecorationSet(local, children) : empty;
      }
      /**
      @internal
      */
      forChild(offset2, node) {
        if (this == empty)
          return this;
        if (node.isLeaf)
          return _DecorationSet.empty;
        let child, local;
        for (let i2 = 0; i2 < this.children.length; i2 += 3)
          if (this.children[i2] >= offset2) {
            if (this.children[i2] == offset2)
              child = this.children[i2 + 2];
            break;
          }
        let start = offset2 + 1, end = start + node.content.size;
        for (let i2 = 0; i2 < this.local.length; i2++) {
          let dec = this.local[i2];
          if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
            let from2 = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
            if (from2 < to)
              (local || (local = [])).push(dec.copy(from2, to));
          }
        }
        if (local) {
          let localSet = new _DecorationSet(local.sort(byPos), none);
          return child ? new DecorationGroup([localSet, child]) : localSet;
        }
        return child || empty;
      }
      /**
      @internal
      */
      eq(other) {
        if (this == other)
          return true;
        if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
          return false;
        for (let i2 = 0; i2 < this.local.length; i2++)
          if (!this.local[i2].eq(other.local[i2]))
            return false;
        for (let i2 = 0; i2 < this.children.length; i2 += 3)
          if (this.children[i2] != other.children[i2] || this.children[i2 + 1] != other.children[i2 + 1] || !this.children[i2 + 2].eq(other.children[i2 + 2]))
            return false;
        return true;
      }
      /**
      @internal
      */
      locals(node) {
        return removeOverlap(this.localsInner(node));
      }
      /**
      @internal
      */
      localsInner(node) {
        if (this == empty)
          return none;
        if (node.inlineContent || !this.local.some(InlineType.is))
          return this.local;
        let result = [];
        for (let i2 = 0; i2 < this.local.length; i2++) {
          if (!(this.local[i2].type instanceof InlineType))
            result.push(this.local[i2]);
        }
        return result;
      }
    };
    DecorationSet.empty = new DecorationSet([], []);
    DecorationSet.removeOverlap = removeOverlap;
    empty = DecorationSet.empty;
    DecorationGroup = class _DecorationGroup {
      constructor(members) {
        this.members = members;
      }
      map(mapping, doc3) {
        const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
        return _DecorationGroup.from(mappedDecos);
      }
      forChild(offset2, child) {
        if (child.isLeaf)
          return DecorationSet.empty;
        let found2 = [];
        for (let i2 = 0; i2 < this.members.length; i2++) {
          let result = this.members[i2].forChild(offset2, child);
          if (result == empty)
            continue;
          if (result instanceof _DecorationGroup)
            found2 = found2.concat(result.members);
          else
            found2.push(result);
        }
        return _DecorationGroup.from(found2);
      }
      eq(other) {
        if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
          return false;
        for (let i2 = 0; i2 < this.members.length; i2++)
          if (!this.members[i2].eq(other.members[i2]))
            return false;
        return true;
      }
      locals(node) {
        let result, sorted = true;
        for (let i2 = 0; i2 < this.members.length; i2++) {
          let locals = this.members[i2].localsInner(node);
          if (!locals.length)
            continue;
          if (!result) {
            result = locals;
          } else {
            if (sorted) {
              result = result.slice();
              sorted = false;
            }
            for (let j2 = 0; j2 < locals.length; j2++)
              result.push(locals[j2]);
          }
        }
        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
      }
      // Create a group for the given array of decoration sets, or return
      // a single set when possible.
      static from(members) {
        switch (members.length) {
          case 0:
            return empty;
          case 1:
            return members[0];
          default:
            return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r2, m) => r2.concat(m instanceof DecorationSet ? m : m.members), []));
        }
      }
    };
    useCharData = ie && ie_version <= 11;
  }
});

// node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/view/dist/index.js
var init_dist9 = __esm({
  "node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/view/dist/index.js"() {
    init_dist8();
  }
});

// node_modules/.pnpm/w3c-keyname@2.2.8/node_modules/w3c-keyname/index.js
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name3 = !ignoreKey && event.key || (event.shiftKey ? shift2 : base2)[event.keyCode] || event.key || "Unidentified";
  if (name3 == "Esc")
    name3 = "Escape";
  if (name3 == "Del")
    name3 = "Delete";
  if (name3 == "Left")
    name3 = "ArrowLeft";
  if (name3 == "Up")
    name3 = "ArrowUp";
  if (name3 == "Right")
    name3 = "ArrowRight";
  if (name3 == "Down")
    name3 = "ArrowDown";
  return name3;
}
var base2, shift2, mac2, ie2, i2, i2, i2, code;
var init_w3c_keyname = __esm({
  "node_modules/.pnpm/w3c-keyname@2.2.8/node_modules/w3c-keyname/index.js"() {
    base2 = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    };
    shift2 = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    };
    mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (i2 = 0; i2 < 10; i2++)
      base2[48 + i2] = base2[96 + i2] = String(i2);
    for (i2 = 1; i2 <= 24; i2++)
      base2[i2 + 111] = "F" + i2;
    for (i2 = 65; i2 <= 90; i2++) {
      base2[i2] = String.fromCharCode(i2 + 32);
      shift2[i2] = String.fromCharCode(i2);
    }
    for (code in base2)
      if (!shift2.hasOwnProperty(code))
        shift2[code] = base2[code];
  }
});

// node_modules/.pnpm/prosemirror-keymap@1.2.2/node_modules/prosemirror-keymap/dist/index.js
function normalizeKeyName(name3) {
  let parts = name3.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift3, meta;
  for (let i2 = 0; i2 < parts.length - 1; i2++) {
    let mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift3 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift3)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName(prop)] = map2[prop];
  return copy2;
}
function modifiers(name3, event, shift3 = true) {
  if (event.altKey)
    name3 = "Alt-" + name3;
  if (event.ctrlKey)
    name3 = "Ctrl-" + name3;
  if (event.metaKey)
    name3 = "Meta-" + name3;
  if (shift3 && event.shiftKey)
    name3 = "Shift-" + name3;
  return name3;
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name3 = keyName(event), baseName, direct = map2[modifiers(name3, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name3.length == 1 && name3 != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name3, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name3.charCodeAt(0) > 127) && (baseName = base2[event.keyCode]) && baseName != name3) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
var mac3;
var init_dist10 = __esm({
  "node_modules/.pnpm/prosemirror-keymap@1.2.2/node_modules/prosemirror-keymap/dist/index.js"() {
    init_w3c_keyname();
    mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
  }
});

// node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/keymap/dist/index.js
var init_dist11 = __esm({
  "node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/keymap/dist/index.js"() {
    init_dist10();
  }
});

// node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/model/dist/index.js
var init_dist12 = __esm({
  "node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/model/dist/index.js"() {
    init_dist4();
  }
});

// node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/transform/dist/index.js
var init_dist13 = __esm({
  "node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/transform/dist/index.js"() {
    init_dist5();
  }
});

// node_modules/.pnpm/prosemirror-commands@1.5.2/node_modules/prosemirror-commands/dist/index.js
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
      if ($pos.index(i2) > 0)
        return $pos.doc.resolve($pos.before(i2 + 1));
      if ($pos.node(i2).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
      let parent = $pos.node(i2);
      if ($pos.index(i2) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i2 + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
function defaultBlockAt(match) {
  for (let i2 = 0; i2 < match.edgeCount; i2++) {
    let { type } = match.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.parent.isBlock)
      return false;
    if (dispatch) {
      let atEnd = $to.parentOffset == $to.parent.content.size;
      let tr2 = state.tr;
      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
        tr2.deleteSelection();
      let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let splitType = splitNode && splitNode($to.parent, atEnd);
      let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : void 0;
      let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        if (deflt)
          types = [{ type: deflt }];
        can = true;
      }
      if (can) {
        tr2.split(tr2.mapping.map($from.pos), 1, types);
        if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
          let first2 = tr2.mapping.map($from.before()), $first = tr2.doc.resolve(first2);
          if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
            tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index8 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index8 - 1, index8)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index8, index8 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  if (before.type.spec.isolating || after.type.spec.isolating)
    return false;
  if (joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i2 = conn.length - 1; i2 >= 0; i2--)
        wrap2 = Fragment.from(conn[i2].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
      let joinAt = end + 2 * conn.length;
      if (canJoin(tr2.doc, joinAt))
        tr2.join(joinAt);
      dispatch(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end = Fragment.empty;
        for (let i2 = wrap2.length - 1; i2 >= 0; i2--)
          end = Fragment.from(wrap2[i2].copy(end));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i2 = 0; i2 < state.selection.ranges.length && !applicable; i2++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i2];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index8 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index8, index8 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr2 = state.tr;
      for (let i2 = 0; i2 < state.selection.ranges.length; i2++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i2];
        tr2.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch, view) {
    for (let i2 = 0; i2 < commands2.length; i2++)
      if (commands2[i2](state, dispatch, view))
        return true;
    return false;
  };
}
var deleteSelection, joinBackward, selectNodeBackward, joinForward, selectNodeForward, joinUp, joinDown, lift2, newlineInCode, exitCode, createParagraphNear, liftEmptyBlock, splitBlock, selectParentNode, selectAll, selectTextblockStart, selectTextblockEnd, backspace, del, pcBaseKeymap, macBaseKeymap, mac4;
var init_dist14 = __esm({
  "node_modules/.pnpm/prosemirror-commands@1.5.2/node_modules/prosemirror-commands/dist/index.js"() {
    init_dist5();
    init_dist4();
    init_dist6();
    deleteSelection = (state, dispatch) => {
      if (state.selection.empty)
        return false;
      if (dispatch)
        dispatch(state.tr.deleteSelection().scrollIntoView());
      return true;
    };
    joinBackward = (state, dispatch, view) => {
      let $cursor = atBlockStart(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutBefore($cursor);
      if (!$cut) {
        let range = $cursor.blockRange(), target = range && liftTarget(range);
        if (target == null)
          return false;
        if (dispatch)
          dispatch(state.tr.lift(range, target).scrollIntoView());
        return true;
      }
      let before = $cut.nodeBefore;
      if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
        return true;
      if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
        let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
          if (dispatch) {
            let tr2 = state.tr.step(delStep);
            tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
            dispatch(tr2.scrollIntoView());
          }
          return true;
        }
      }
      if (before.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch)
          dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
        return true;
      }
      return false;
    };
    selectNodeBackward = (state, dispatch, view) => {
      let { $head, empty: empty2 } = state.selection, $cut = $head;
      if (!empty2)
        return false;
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
          return false;
        $cut = findCutBefore($head);
      }
      let node = $cut && $cut.nodeBefore;
      if (!node || !NodeSelection.isSelectable(node))
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
      return true;
    };
    joinForward = (state, dispatch, view) => {
      let $cursor = atBlockEnd(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutAfter($cursor);
      if (!$cut)
        return false;
      let after = $cut.nodeAfter;
      if (deleteBarrier(state, $cut, dispatch))
        return true;
      if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
        let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
          if (dispatch) {
            let tr2 = state.tr.step(delStep);
            tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
            dispatch(tr2.scrollIntoView());
          }
          return true;
        }
      }
      if (after.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch)
          dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
        return true;
      }
      return false;
    };
    selectNodeForward = (state, dispatch, view) => {
      let { $head, empty: empty2 } = state.selection, $cut = $head;
      if (!empty2)
        return false;
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
          return false;
        $cut = findCutAfter($head);
      }
      let node = $cut && $cut.nodeAfter;
      if (!node || !NodeSelection.isSelectable(node))
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
      return true;
    };
    joinUp = (state, dispatch) => {
      let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
      if (nodeSel) {
        if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
          return false;
        point = sel.from;
      } else {
        point = joinPoint(state.doc, sel.from, -1);
        if (point == null)
          return false;
      }
      if (dispatch) {
        let tr2 = state.tr.join(point);
        if (nodeSel)
          tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    };
    joinDown = (state, dispatch) => {
      let sel = state.selection, point;
      if (sel instanceof NodeSelection) {
        if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
          return false;
        point = sel.to;
      } else {
        point = joinPoint(state.doc, sel.to, 1);
        if (point == null)
          return false;
      }
      if (dispatch)
        dispatch(state.tr.join(point).scrollIntoView());
      return true;
    };
    lift2 = (state, dispatch) => {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    };
    newlineInCode = (state, dispatch) => {
      let { $head, $anchor } = state.selection;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
        return false;
      if (dispatch)
        dispatch(state.tr.insertText("\n").scrollIntoView());
      return true;
    };
    exitCode = (state, dispatch) => {
      let { $head, $anchor } = state.selection;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
        return false;
      let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
      if (!type || !above.canReplaceWith(after, after, type))
        return false;
      if (dispatch) {
        let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
        tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    };
    createParagraphNear = (state, dispatch) => {
      let sel = state.selection, { $from, $to } = sel;
      if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
        return false;
      let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
      if (!type || !type.isTextblock)
        return false;
      if (dispatch) {
        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
        let tr2 = state.tr.insert(side, type.createAndFill());
        tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    };
    liftEmptyBlock = (state, dispatch) => {
      let { $cursor } = state.selection;
      if (!$cursor || $cursor.parent.content.size)
        return false;
      if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
        let before = $cursor.before();
        if (canSplit(state.doc, before)) {
          if (dispatch)
            dispatch(state.tr.split(before).scrollIntoView());
          return true;
        }
      }
      let range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    };
    splitBlock = splitBlockAs();
    selectParentNode = (state, dispatch) => {
      let { $from, to } = state.selection, pos;
      let same = $from.sharedDepth(to);
      if (same == 0)
        return false;
      pos = $from.before(same);
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
      return true;
    };
    selectAll = (state, dispatch) => {
      if (dispatch)
        dispatch(state.tr.setSelection(new AllSelection(state.doc)));
      return true;
    };
    selectTextblockStart = selectTextblockSide(-1);
    selectTextblockEnd = selectTextblockSide(1);
    backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
    del = chainCommands(deleteSelection, joinForward, selectNodeForward);
    pcBaseKeymap = {
      "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
      "Mod-Enter": exitCode,
      "Backspace": backspace,
      "Mod-Backspace": backspace,
      "Shift-Backspace": backspace,
      "Delete": del,
      "Mod-Delete": del,
      "Mod-a": selectAll
    };
    macBaseKeymap = {
      "Ctrl-h": pcBaseKeymap["Backspace"],
      "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
      "Ctrl-d": pcBaseKeymap["Delete"],
      "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
      "Alt-Delete": pcBaseKeymap["Mod-Delete"],
      "Alt-d": pcBaseKeymap["Mod-Delete"],
      "Ctrl-a": selectTextblockStart,
      "Ctrl-e": selectTextblockEnd
    };
    for (let key3 in pcBaseKeymap)
      macBaseKeymap[key3] = pcBaseKeymap[key3];
    mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
  }
});

// node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/commands/dist/index.js
var init_dist15 = __esm({
  "node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/commands/dist/index.js"() {
    init_dist14();
  }
});

// node_modules/.pnpm/prosemirror-schema-list@1.3.0/node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range)
      return false;
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0)
        return false;
      let $insert = state.doc.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      doJoin = true;
    }
    let wrap2 = findWrapping(outerRange, listType, attrs, range);
    if (!wrap2)
      return false;
    if (dispatch)
      dispatch(doWrapInList(state.tr, range, wrap2, doJoin, listType).scrollIntoView());
    return true;
  };
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i2 = wrappers.length - 1; i2 >= 0; i2--)
    content = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i2 = 0; i2 < wrappers.length; i2++)
    if (wrappers[i2].type == listType)
      found2 = i2 + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i2 = range.startIndex, e = range.endIndex, first2 = true; i2 < e; i2++, first2 = false) {
    if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i2).nodeSize;
  }
  return tr2;
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr2 = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr2.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let after = tr2.mapping.map(end, -1) - 1;
  if (canJoin(tr2.doc, after))
    tr2.join(after);
  dispatch(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i2 = range.endIndex - 1, e = range.startIndex; i2 > e; i2--) {
    pos -= list.child(i2).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr2.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}
var init_dist16 = __esm({
  "node_modules/.pnpm/prosemirror-schema-list@1.3.0/node_modules/prosemirror-schema-list/dist/index.js"() {
    init_dist5();
    init_dist4();
  }
});

// node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/schema-list/dist/index.js
var init_dist17 = __esm({
  "node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/schema-list/dist/index.js"() {
    init_dist16();
  }
});

// node_modules/.pnpm/@tiptap+core@2.1.10_@tiptap+pm@2.1.10/node_modules/@tiptap/core/dist/index.js
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc3 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    filterTransaction: state.filterTransaction,
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction.selection;
      doc3 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getNodeType(nameOrType, schema3) {
  if (typeof nameOrType === "string") {
    if (!schema3.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema3.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key3, value]) => {
      const exists2 = mergedAttributes[key3];
      if (!exists2) {
        mergedAttributes[key3] = value;
        return;
      }
      if (key3 === "class") {
        const valueClasses = value ? value.split(" ") : [];
        const existingClasses = mergedAttributes[key3] ? mergedAttributes[key3].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key3] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key3 === "style") {
        mergedAttributes[key3] = [mergedAttributes[key3], value].join("; ");
      } else {
        mergedAttributes[key3] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function isFunction2(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction2(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source2) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source2)) {
    Object.keys(source2).forEach((key3) => {
      if (isPlainObject(source2[key3])) {
        if (!(key3 in target)) {
          Object.assign(output, { [key3]: source2[key3] });
        } else {
          output[key3] = mergeDeep(target[key3], source2[key3]);
        }
      } else {
        Object.assign(output, { [key3]: source2[key3] });
      }
    });
  }
  return output;
}
function getTextBetween(startNode, range, options2) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
  let text3 = "";
  let separated = true;
  startNode.nodesBetween(from2, to, (node, pos, parent, index8) => {
    var _a178;
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (node.isBlock && !separated) {
        text3 += blockSeparator;
        separated = true;
      }
      if (parent) {
        text3 += textSerializer({
          node,
          pos,
          parent,
          index: index8,
          range
        });
      }
    } else if (node.isText) {
      text3 += (_a178 = node === null || node === void 0 ? void 0 : node.text) === null || _a178 === void 0 ? void 0 : _a178.slice(Math.max(from2, pos) - pos, to - pos);
      separated = false;
    } else if (node.isBlock && !separated) {
      text3 += blockSeparator;
      separated = true;
    }
  });
  return text3;
}
function getTextSerializersFromSchema(schema3) {
  return Object.fromEntries(Object.entries(schema3.nodes).filter(([, node]) => node.spec.toText).map(([name3, node]) => [name3, node.spec.toText]));
}
function objectIncludes(object1, object2, options2 = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key3) => {
    if (options2.strict) {
      return object2[key3] === object1[key3];
    }
    if (isRegExp(object2[key3])) {
      return object2[key3].test(object1[key3]);
    }
    return object2[key3] === object1[key3];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(item.attrs, attributes);
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes = {}) {
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start.offset && start.offset !== 0) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node) {
    return;
  }
  const mark = findMarkInSet([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  findMarkInSet([...start.node.marks], type, attributes);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema3) {
  if (typeof nameOrType === "string") {
    if (!schema3.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema3.marks[nameOrType];
  }
  return nameOrType;
}
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition(doc3, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
}
function createNodeFromContent(content, schema3, options2) {
  options2 = {
    slice: true,
    parseOptions: {},
    ...options2
  };
  if (typeof content === "object" && content !== null) {
    try {
      if (Array.isArray(content) && content.length > 0) {
        return Fragment.fromArray(content.map((item) => schema3.nodeFromJSON(item)));
      }
      return schema3.nodeFromJSON(content);
    } catch (error3) {
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error3);
      return createNodeFromContent("", schema3, options2);
    }
  }
  if (typeof content === "string") {
    const parser = DOMParser.fromSchema(schema3);
    return options2.slice ? parser.parseSlice(elementFromString(content), options2.parseOptions).content : parser.parse(elementFromString(content), options2.parseOptions);
  }
  return createNodeFromContent("", schema3, options2);
}
function selectionToInsertionEnd2(tr2, startLen, bias) {
  const last2 = tr2.steps.length - 1;
  if (last2 < startLen) {
    return;
  }
  const step = tr2.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last2];
  let end = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name3) {
  const parts = name3.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift3;
  let meta;
  for (let i2 = 0; i2 < parts.length - 1; i2 += 1) {
    const mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift3 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift3) {
    result = `Shift-${result}`;
  }
  return result;
}
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
function getSchemaTypeNameByName(name3, schema3) {
  if (schema3.nodes[name3]) {
    return "node";
  }
  if (schema3.marks[name3]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
function createDocument(content, schema3, parseOptions = {}) {
  return createNodeFromContent(content, schema3, { slice: false, parseOptions });
}
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt2(match) {
  for (let i2 = 0; i2 < match.edgeCount; i2 += 1) {
    const { type } = match.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildren(node, predicate) {
  const nodesWithPos = [];
  node.descendants((child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i2 = $pos.depth; i2 > 0; i2 -= 1) {
    const node = $pos.node(i2);
    if (predicate(node)) {
      return {
        pos: i2 > 0 ? $pos.before(i2) : 0,
        start: $pos.start(i2),
        depth: i2,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array2, by = JSON.stringify) {
  const seen = {};
  return array2.filter((item) => {
    const key3 = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key3) ? false : seen[key3] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index8) => {
    const rest = uniqueChanges.filter((_, i2) => i2 !== index8);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index8) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index8];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index8).map(from2, -1);
      const newEnd = mapping.slice(index8).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc3) {
  const marks = [];
  if (from2 === to) {
    doc3.resolve(from2).marks().forEach((mark) => {
      const $pos = doc3.resolve(from2 - 1);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc3.nodesBetween(from2, to, (node, pos) => {
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name3]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name3;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isList(name3, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name3);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function canSetMark(state, tr2, newMarkType) {
  var _a178;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a178 = state.storedMarks) !== null && _a178 !== void 0 ? _a178 : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr: tr2 } = state;
      const start = range.from;
      let end = range.to;
      const newNode2 = config.type.create(attributes);
      if (match[1]) {
        const offset2 = match[0].lastIndexOf(match[1]);
        let matchStart = start + offset2;
        if (matchStart > end) {
          matchStart = end;
        } else {
          end = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr2.insertText(lastChar, start + match[0].length - 1);
        tr2.replaceWith(matchStart, end, newNode2);
      } else if (match[0]) {
        tr2.insert(start - 1, config.type.create(attributes)).delete(tr2.mapping.map(start), tr2.mapping.map(end));
      }
      tr2.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match, chain }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr2.join(range.from - 1);
      }
    }
  });
}
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
var CommandManager, InputRule, PasteRule, Extension, ClipboardTextSerializer, blur, clearContent, clearNodes, command, createParagraphNear2, cut, deleteCurrentNode, deleteNode, deleteRange2, deleteSelection2, enter, exitCode2, extendMarkRange, first, focus, forEach, insertContent, isFragment, insertContentAt, joinUp2, joinDown2, joinBackward2, joinForward2, joinItemBackward, joinItemForward, keyboardShortcut, lift3, liftEmptyBlock2, liftListItem2, newlineInCode2, resetAttributes, scrollIntoView, selectAll2, selectNodeBackward2, selectNodeForward2, selectParentNode2, selectTextblockEnd2, selectTextblockStart2, setContent, setMark, setMeta, setNode, setNodeSelection, setTextSelection, sinkListItem2, splitBlock2, splitListItem, joinListBackwards, joinListForwards, toggleList, toggleMark, toggleNode, toggleWrap, undoInputRule, unsetAllMarks, unsetMark, updateAttributes, wrapIn2, wrapInList2, commands, Commands, Editable, FocusEvents, Keymap, Tabindex, Mark2, Node3;
var init_dist18 = __esm({
  "node_modules/.pnpm/@tiptap+core@2.1.10_@tiptap+pm@2.1.10/node_modules/@tiptap/core/dist/index.js"() {
    init_dist7();
    init_dist9();
    init_dist11();
    init_dist12();
    init_dist13();
    init_dist15();
    init_dist17();
    CommandManager = class {
      constructor(props) {
        this.editor = props.editor;
        this.rawCommands = this.editor.extensionManager.commands;
        this.customState = props.state;
      }
      get hasCustomState() {
        return !!this.customState;
      }
      get state() {
        return this.customState || this.editor.state;
      }
      get commands() {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const { tr: tr2 } = state;
        const props = this.buildProps(tr2);
        return Object.fromEntries(Object.entries(rawCommands).map(([name3, command2]) => {
          const method = (...args) => {
            const callback = command2(...args)(props);
            if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
              view.dispatch(tr2);
            }
            return callback;
          };
          return [name3, method];
        }));
      }
      get chain() {
        return () => this.createChain();
      }
      get can() {
        return () => this.createCan();
      }
      createChain(startTr, shouldDispatch = true) {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const callbacks = [];
        const hasStartTransaction = !!startTr;
        const tr2 = startTr || state.tr;
        const run3 = () => {
          if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr2);
          }
          return callbacks.every((callback) => callback === true);
        };
        const chain = {
          ...Object.fromEntries(Object.entries(rawCommands).map(([name3, command2]) => {
            const chainedCommand = (...args) => {
              const props = this.buildProps(tr2, shouldDispatch);
              const callback = command2(...args)(props);
              callbacks.push(callback);
              return chain;
            };
            return [name3, chainedCommand];
          })),
          run: run3
        };
        return chain;
      }
      createCan(startTr) {
        const { rawCommands, state } = this;
        const dispatch = false;
        const tr2 = startTr || state.tr;
        const props = this.buildProps(tr2, dispatch);
        const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name3, command2]) => {
          return [name3, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
        }));
        return {
          ...formattedCommands,
          chain: () => this.createChain(tr2, dispatch)
        };
      }
      buildProps(tr2, shouldDispatch = true) {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const props = {
          tr: tr2,
          editor,
          view,
          state: createChainableState({
            state,
            transaction: tr2
          }),
          dispatch: shouldDispatch ? () => void 0 : void 0,
          chain: () => this.createChain(tr2, shouldDispatch),
          can: () => this.createCan(tr2),
          get commands() {
            return Object.fromEntries(Object.entries(rawCommands).map(([name3, command2]) => {
              return [name3, (...args) => command2(...args)(props)];
            }));
          }
        };
        return props;
      }
    };
    InputRule = class {
      constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
      }
    };
    PasteRule = class {
      constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
      }
    };
    Extension = class _Extension {
      constructor(config = {}) {
        this.type = "extension";
        this.name = "extension";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = {
          ...this.config,
          ...config
        };
        this.name = this.config.name;
        if (config.defaultOptions) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
          this.options = callOrReturn(getExtensionField(this, "addOptions", {
            name: this.name
          }));
        }
        this.storage = callOrReturn(getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(config = {}) {
        return new _Extension(config);
      }
      configure(options2 = {}) {
        const extension = this.extend();
        extension.options = mergeDeep(this.options, options2);
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new _Extension(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        if (extendedConfig.defaultOptions) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
          name: extension.name
        }));
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
    };
    ClipboardTextSerializer = Extension.create({
      name: "clipboardTextSerializer",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("clipboardTextSerializer"),
            props: {
              clipboardTextSerializer: () => {
                const { editor } = this;
                const { state, schema: schema3 } = editor;
                const { doc: doc3, selection } = state;
                const { ranges } = selection;
                const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
                const to = Math.max(...ranges.map((range2) => range2.$to.pos));
                const textSerializers = getTextSerializersFromSchema(schema3);
                const range = { from: from2, to };
                return getTextBetween(doc3, range, {
                  textSerializers
                });
              }
            }
          })
        ];
      }
    });
    blur = () => ({ editor, view }) => {
      requestAnimationFrame(() => {
        var _a178;
        if (!editor.isDestroyed) {
          view.dom.blur();
          (_a178 = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a178 === void 0 ? void 0 : _a178.removeAllRanges();
        }
      });
      return true;
    };
    clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
      return commands2.setContent("", emitUpdate);
    };
    clearNodes = () => ({ state, tr: tr2, dispatch }) => {
      const { selection } = tr2;
      const { ranges } = selection;
      if (!dispatch) {
        return true;
      }
      ranges.forEach(({ $from, $to }) => {
        state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
          if (node.type.isText) {
            return;
          }
          const { doc: doc3, mapping } = tr2;
          const $mappedFrom = doc3.resolve(mapping.map(pos));
          const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
          const nodeRange = $mappedFrom.blockRange($mappedTo);
          if (!nodeRange) {
            return;
          }
          const targetLiftDepth = liftTarget(nodeRange);
          if (node.type.isTextblock) {
            const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
            tr2.setNodeMarkup(nodeRange.start, defaultType);
          }
          if (targetLiftDepth || targetLiftDepth === 0) {
            tr2.lift(nodeRange, targetLiftDepth);
          }
        });
      });
      return true;
    };
    command = (fn) => (props) => {
      return fn(props);
    };
    createParagraphNear2 = () => ({ state, dispatch }) => {
      return createParagraphNear(state, dispatch);
    };
    cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
      const { state } = editor;
      const contentSlice = state.doc.slice(originRange.from, originRange.to);
      tr2.deleteRange(originRange.from, originRange.to);
      const newPos = tr2.mapping.map(targetPos);
      tr2.insert(newPos, contentSlice.content);
      tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
      return true;
    };
    deleteCurrentNode = () => ({ tr: tr2, dispatch }) => {
      const { selection } = tr2;
      const currentNode = selection.$anchor.node();
      if (currentNode.content.size > 0) {
        return false;
      }
      const $pos = tr2.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === currentNode.type) {
          if (dispatch) {
            const from2 = $pos.before(depth);
            const to = $pos.after(depth);
            tr2.delete(from2, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
    deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const $pos = tr2.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === type) {
          if (dispatch) {
            const from2 = $pos.before(depth);
            const to = $pos.after(depth);
            tr2.delete(from2, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
    deleteRange2 = (range) => ({ tr: tr2, dispatch }) => {
      const { from: from2, to } = range;
      if (dispatch) {
        tr2.delete(from2, to);
      }
      return true;
    };
    deleteSelection2 = () => ({ state, dispatch }) => {
      return deleteSelection(state, dispatch);
    };
    enter = () => ({ commands: commands2 }) => {
      return commands2.keyboardShortcut("Enter");
    };
    exitCode2 = () => ({ state, dispatch }) => {
      return exitCode(state, dispatch);
    };
    extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
      const type = getMarkType(typeOrName, state.schema);
      const { doc: doc3, selection } = tr2;
      const { $from, from: from2, to } = selection;
      if (dispatch) {
        const range = getMarkRange($from, type, attributes);
        if (range && range.from <= from2 && range.to >= to) {
          const newSelection = TextSelection.create(doc3, range.from, range.to);
          tr2.setSelection(newSelection);
        }
      }
      return true;
    };
    first = (commands2) => (props) => {
      const items = typeof commands2 === "function" ? commands2(props) : commands2;
      for (let i2 = 0; i2 < items.length; i2 += 1) {
        if (items[i2](props)) {
          return true;
        }
      }
      return false;
    };
    focus = (position = null, options2 = {}) => ({ editor, view, tr: tr2, dispatch }) => {
      options2 = {
        scrollIntoView: true,
        ...options2
      };
      const delayedFocus = () => {
        if (isiOS()) {
          view.dom.focus();
        }
        requestAnimationFrame(() => {
          if (!editor.isDestroyed) {
            view.focus();
            if (options2 === null || options2 === void 0 ? void 0 : options2.scrollIntoView) {
              editor.commands.scrollIntoView();
            }
          }
        });
      };
      if (view.hasFocus() && position === null || position === false) {
        return true;
      }
      if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
        delayedFocus();
        return true;
      }
      const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
      const isSameSelection = editor.state.selection.eq(selection);
      if (dispatch) {
        if (!isSameSelection) {
          tr2.setSelection(selection);
        }
        if (isSameSelection && tr2.storedMarks) {
          tr2.setStoredMarks(tr2.storedMarks);
        }
        delayedFocus();
      }
      return true;
    };
    forEach = (items, fn) => (props) => {
      return items.every((item, index8) => fn(item, { ...props, index: index8 }));
    };
    insertContent = (value, options2) => ({ tr: tr2, commands: commands2 }) => {
      return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options2);
    };
    isFragment = (nodeOrFragment) => {
      return nodeOrFragment.toString().startsWith("<");
    };
    insertContentAt = (position, value, options2) => ({ tr: tr2, dispatch, editor }) => {
      if (dispatch) {
        options2 = {
          parseOptions: {},
          updateSelection: true,
          ...options2
        };
        const content = createNodeFromContent(value, editor.schema, {
          parseOptions: {
            preserveWhitespace: "full",
            ...options2.parseOptions
          }
        });
        if (content.toString() === "<>") {
          return true;
        }
        let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
        let isOnlyTextContent = true;
        let isOnlyBlockContent = true;
        const nodes = isFragment(content) ? content : [content];
        nodes.forEach((node) => {
          node.check();
          isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
          isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
        });
        if (from2 === to && isOnlyBlockContent) {
          const { parent } = tr2.doc.resolve(from2);
          const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
          if (isEmptyTextBlock) {
            from2 -= 1;
            to += 1;
          }
        }
        if (isOnlyTextContent) {
          if (Array.isArray(value)) {
            tr2.insertText(value.map((v) => v.text || "").join(""), from2, to);
          } else if (typeof value === "object" && !!value && !!value.text) {
            tr2.insertText(value.text, from2, to);
          } else {
            tr2.insertText(value, from2, to);
          }
        } else {
          tr2.replaceWith(from2, to, content);
        }
        if (options2.updateSelection) {
          selectionToInsertionEnd2(tr2, tr2.steps.length - 1, -1);
        }
      }
      return true;
    };
    joinUp2 = () => ({ state, dispatch }) => {
      return joinUp(state, dispatch);
    };
    joinDown2 = () => ({ state, dispatch }) => {
      return joinDown(state, dispatch);
    };
    joinBackward2 = () => ({ state, dispatch }) => {
      return joinBackward(state, dispatch);
    };
    joinForward2 = () => ({ state, dispatch }) => {
      return joinForward(state, dispatch);
    };
    joinItemBackward = () => ({ tr: tr2, state, dispatch }) => {
      try {
        const point = joinPoint(state.doc, state.selection.$from.pos, -1);
        if (point === null || point === void 0) {
          return false;
        }
        tr2.join(point, 2);
        if (dispatch) {
          dispatch(tr2);
        }
        return true;
      } catch {
        return false;
      }
    };
    joinItemForward = () => ({ state, dispatch, tr: tr2 }) => {
      try {
        const point = joinPoint(state.doc, state.selection.$from.pos, 1);
        if (point === null || point === void 0) {
          return false;
        }
        tr2.join(point, 2);
        if (dispatch) {
          dispatch(tr2);
        }
        return true;
      } catch (e) {
        return false;
      }
    };
    keyboardShortcut = (name3) => ({ editor, view, tr: tr2, dispatch }) => {
      const keys2 = normalizeKeyName2(name3).split(/-(?!$)/);
      const key3 = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
      const event = new KeyboardEvent("keydown", {
        key: key3 === "Space" ? " " : key3,
        altKey: keys2.includes("Alt"),
        ctrlKey: keys2.includes("Ctrl"),
        metaKey: keys2.includes("Meta"),
        shiftKey: keys2.includes("Shift"),
        bubbles: true,
        cancelable: true
      });
      const capturedTransaction = editor.captureTransaction(() => {
        view.someProp("handleKeyDown", (f) => f(view, event));
      });
      capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
        const newStep = step.map(tr2.mapping);
        if (newStep && dispatch) {
          tr2.maybeStep(newStep);
        }
      });
      return true;
    };
    lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive = isNodeActive(state, type, attributes);
      if (!isActive) {
        return false;
      }
      return lift2(state, dispatch);
    };
    liftEmptyBlock2 = () => ({ state, dispatch }) => {
      return liftEmptyBlock(state, dispatch);
    };
    liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return liftListItem(type)(state, dispatch);
    };
    newlineInCode2 = () => ({ state, dispatch }) => {
      return newlineInCode(state, dispatch);
    };
    resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr2.selection.ranges.forEach((range) => {
          state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
            if (nodeType && nodeType === node.type) {
              tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
                }
              });
            }
          });
        });
      }
      return true;
    };
    scrollIntoView = () => ({ tr: tr2, dispatch }) => {
      if (dispatch) {
        tr2.scrollIntoView();
      }
      return true;
    };
    selectAll2 = () => ({ tr: tr2, commands: commands2 }) => {
      return commands2.setTextSelection({
        from: 0,
        to: tr2.doc.content.size
      });
    };
    selectNodeBackward2 = () => ({ state, dispatch }) => {
      return selectNodeBackward(state, dispatch);
    };
    selectNodeForward2 = () => ({ state, dispatch }) => {
      return selectNodeForward(state, dispatch);
    };
    selectParentNode2 = () => ({ state, dispatch }) => {
      return selectParentNode(state, dispatch);
    };
    selectTextblockEnd2 = () => ({ state, dispatch }) => {
      return selectTextblockEnd(state, dispatch);
    };
    selectTextblockStart2 = () => ({ state, dispatch }) => {
      return selectTextblockStart(state, dispatch);
    };
    setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr: tr2, editor, dispatch }) => {
      const { doc: doc3 } = tr2;
      const document2 = createDocument(content, editor.schema, parseOptions);
      if (dispatch) {
        tr2.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
      }
      return true;
    };
    setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
      const { selection } = tr2;
      const { empty: empty2, ranges } = selection;
      const type = getMarkType(typeOrName, state.schema);
      if (dispatch) {
        if (empty2) {
          const oldAttributes = getMarkAttributes(state, type);
          tr2.addStoredMark(type.create({
            ...oldAttributes,
            ...attributes
          }));
        } else {
          ranges.forEach((range) => {
            const from2 = range.$from.pos;
            const to = range.$to.pos;
            state.doc.nodesBetween(from2, to, (node, pos) => {
              const trimmedFrom = Math.max(pos, from2);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              const someHasMark = node.marks.find((mark) => mark.type === type);
              if (someHasMark) {
                node.marks.forEach((mark) => {
                  if (type === mark.type) {
                    tr2.addMark(trimmedFrom, trimmedTo, type.create({
                      ...mark.attrs,
                      ...attributes
                    }));
                  }
                });
              } else {
                tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
              }
            });
          });
        }
      }
      return canSetMark(state, tr2, type);
    };
    setMeta = (key3, value) => ({ tr: tr2 }) => {
      tr2.setMeta(key3, value);
      return true;
    };
    setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
      const type = getNodeType(typeOrName, state.schema);
      if (!type.isTextblock) {
        console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
        return false;
      }
      return chain().command(({ commands: commands2 }) => {
        const canSetBlock = setBlockType2(type, attributes)(state);
        if (canSetBlock) {
          return true;
        }
        return commands2.clearNodes();
      }).command(({ state: updatedState }) => {
        return setBlockType2(type, attributes)(updatedState, dispatch);
      }).run();
    };
    setNodeSelection = (position) => ({ tr: tr2, dispatch }) => {
      if (dispatch) {
        const { doc: doc3 } = tr2;
        const from2 = minMax(position, 0, doc3.content.size);
        const selection = NodeSelection.create(doc3, from2);
        tr2.setSelection(selection);
      }
      return true;
    };
    setTextSelection = (position) => ({ tr: tr2, dispatch }) => {
      if (dispatch) {
        const { doc: doc3 } = tr2;
        const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
        const minPos = TextSelection.atStart(doc3).from;
        const maxPos = TextSelection.atEnd(doc3).to;
        const resolvedFrom = minMax(from2, minPos, maxPos);
        const resolvedEnd = minMax(to, minPos, maxPos);
        const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
        tr2.setSelection(selection);
      }
      return true;
    };
    sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return sinkListItem(type)(state, dispatch);
    };
    splitBlock2 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch, editor }) => {
      const { selection, doc: doc3 } = tr2;
      const { $from, $to } = selection;
      const extensionAttributes = editor.extensionManager.attributes;
      const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      if (selection instanceof NodeSelection && selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
          return false;
        }
        if (dispatch) {
          if (keepMarks) {
            ensureMarks(state, editor.extensionManager.splittableMarks);
          }
          tr2.split($from.pos).scrollIntoView();
        }
        return true;
      }
      if (!$from.parent.isBlock) {
        return false;
      }
      if (dispatch) {
        const atEnd = $to.parentOffset === $to.parent.content.size;
        if (selection instanceof TextSelection) {
          tr2.deleteSelection();
        }
        const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
        let types = atEnd && deflt ? [
          {
            type: deflt,
            attrs: newAttributes
          }
        ] : void 0;
        let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
        if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
          can = true;
          types = deflt ? [
            {
              type: deflt,
              attrs: newAttributes
            }
          ] : void 0;
        }
        if (can) {
          tr2.split(tr2.mapping.map($from.pos), 1, types);
          if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
            const first2 = tr2.mapping.map($from.before());
            const $first = tr2.doc.resolve(first2);
            if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
              tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
            }
          }
        }
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr2.scrollIntoView();
      }
      return true;
    };
    splitListItem = (typeOrName) => ({ tr: tr2, state, dispatch, editor }) => {
      var _a178;
      const type = getNodeType(typeOrName, state.schema);
      const { $from, $to } = state.selection;
      const node = state.selection.node;
      if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
        return false;
      }
      const grandParent = $from.node(-1);
      if (grandParent.type !== type) {
        return false;
      }
      const extensionAttributes = editor.extensionManager.attributes;
      if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
        if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
          return false;
        }
        if (dispatch) {
          let wrap2 = Fragment.empty;
          const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
          for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
            wrap2 = Fragment.from($from.node(d).copy(wrap2));
          }
          const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
          const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
          const nextType2 = ((_a178 = type.contentMatch.defaultType) === null || _a178 === void 0 ? void 0 : _a178.createAndFill(newNextTypeAttributes2)) || void 0;
          wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
          const start = $from.before($from.depth - (depthBefore - 1));
          tr2.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
          let sel = -1;
          tr2.doc.nodesBetween(start, tr2.doc.content.size, (n, pos) => {
            if (sel > -1) {
              return false;
            }
            if (n.isTextblock && n.content.size === 0) {
              sel = pos + 1;
            }
          });
          if (sel > -1) {
            tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
          }
          tr2.scrollIntoView();
        }
        return true;
      }
      const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
      const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
      const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      tr2.delete($from.pos, $to.pos);
      const types = nextType ? [
        { type, attrs: newTypeAttributes },
        { type: nextType, attrs: newNextTypeAttributes }
      ] : [{ type, attrs: newTypeAttributes }];
      if (!canSplit(tr2.doc, $from.pos, 2)) {
        return false;
      }
      if (dispatch) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        tr2.split($from.pos, 2, types).scrollIntoView();
        if (!marks || !dispatch) {
          return true;
        }
        const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
        tr2.ensureMarks(filteredMarks);
      }
      return true;
    };
    joinListBackwards = (tr2, listType) => {
      const list = findParentNode((node) => node.type === listType)(tr2.selection);
      if (!list) {
        return true;
      }
      const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
      if (before === void 0) {
        return true;
      }
      const nodeBefore = tr2.doc.nodeAt(before);
      const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
      if (!canJoinBackwards) {
        return true;
      }
      tr2.join(list.pos);
      return true;
    };
    joinListForwards = (tr2, listType) => {
      const list = findParentNode((node) => node.type === listType)(tr2.selection);
      if (!list) {
        return true;
      }
      const after = tr2.doc.resolve(list.start).after(list.depth);
      if (after === void 0) {
        return true;
      }
      const nodeAfter = tr2.doc.nodeAt(after);
      const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
      if (!canJoinForwards) {
        return true;
      }
      tr2.join(after);
      return true;
    };
    toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch, chain, commands: commands2, can }) => {
      const { extensions, splittableMarks } = editor.extensionManager;
      const listType = getNodeType(listTypeOrName, state.schema);
      const itemType = getNodeType(itemTypeOrName, state.schema);
      const { selection, storedMarks } = state;
      const { $from, $to } = selection;
      const range = $from.blockRange($to);
      const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      if (!range) {
        return false;
      }
      const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
      if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
        if (parentList.node.type === listType) {
          return commands2.liftListItem(itemType);
        }
        if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
          return chain().command(() => {
            tr2.setNodeMarkup(parentList.pos, listType);
            return true;
          }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
        }
      }
      if (!keepMarks || !marks || !dispatch) {
        return chain().command(() => {
          const canWrapInList = can().wrapInList(listType, attributes);
          if (canWrapInList) {
            return true;
          }
          return commands2.clearNodes();
        }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
      }
      return chain().command(() => {
        const canWrapInList = can().wrapInList(listType, attributes);
        const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
        tr2.ensureMarks(filteredMarks);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    };
    toggleMark = (typeOrName, attributes = {}, options2 = {}) => ({ state, commands: commands2 }) => {
      const { extendEmptyMarkRange = false } = options2;
      const type = getMarkType(typeOrName, state.schema);
      const isActive = isMarkActive(state, type, attributes);
      if (isActive) {
        return commands2.unsetMark(type, { extendEmptyMarkRange });
      }
      return commands2.setMark(type, attributes);
    };
    toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
      const type = getNodeType(typeOrName, state.schema);
      const toggleType = getNodeType(toggleTypeOrName, state.schema);
      const isActive = isNodeActive(state, type, attributes);
      if (isActive) {
        return commands2.setNode(toggleType);
      }
      return commands2.setNode(type, attributes);
    };
    toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive = isNodeActive(state, type, attributes);
      if (isActive) {
        return commands2.lift(type);
      }
      return commands2.wrapIn(type, attributes);
    };
    undoInputRule = () => ({ state, dispatch }) => {
      const plugins = state.plugins;
      for (let i2 = 0; i2 < plugins.length; i2 += 1) {
        const plugin = plugins[i2];
        let undoable;
        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
          if (dispatch) {
            const tr2 = state.tr;
            const toUndo = undoable.transform;
            for (let j2 = toUndo.steps.length - 1; j2 >= 0; j2 -= 1) {
              tr2.step(toUndo.steps[j2].invert(toUndo.docs[j2]));
            }
            if (undoable.text) {
              const marks = tr2.doc.resolve(undoable.from).marks();
              tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
            } else {
              tr2.delete(undoable.from, undoable.to);
            }
          }
          return true;
        }
      }
      return false;
    };
    unsetAllMarks = () => ({ tr: tr2, dispatch }) => {
      const { selection } = tr2;
      const { empty: empty2, ranges } = selection;
      if (empty2) {
        return true;
      }
      if (dispatch) {
        ranges.forEach((range) => {
          tr2.removeMark(range.$from.pos, range.$to.pos);
        });
      }
      return true;
    };
    unsetMark = (typeOrName, options2 = {}) => ({ tr: tr2, state, dispatch }) => {
      var _a178;
      const { extendEmptyMarkRange = false } = options2;
      const { selection } = tr2;
      const type = getMarkType(typeOrName, state.schema);
      const { $from, empty: empty2, ranges } = selection;
      if (!dispatch) {
        return true;
      }
      if (empty2 && extendEmptyMarkRange) {
        let { from: from2, to } = selection;
        const attrs = (_a178 = $from.marks().find((mark) => mark.type === type)) === null || _a178 === void 0 ? void 0 : _a178.attrs;
        const range = getMarkRange($from, type, attrs);
        if (range) {
          from2 = range.from;
          to = range.to;
        }
        tr2.removeMark(from2, to, type);
      } else {
        ranges.forEach((range) => {
          tr2.removeMark(range.$from.pos, range.$to.pos, type);
        });
      }
      tr2.removeStoredMark(type);
      return true;
    };
    updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr2.selection.ranges.forEach((range) => {
          const from2 = range.$from.pos;
          const to = range.$to.pos;
          state.doc.nodesBetween(from2, to, (node, pos) => {
            if (nodeType && nodeType === node.type) {
              tr2.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom = Math.max(pos, from2);
                  const trimmedTo = Math.min(pos + node.nodeSize, to);
                  tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            }
          });
        });
      }
      return true;
    };
    wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return wrapIn(type, attributes)(state, dispatch);
    };
    wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return wrapInList(type, attributes)(state, dispatch);
    };
    commands = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      blur,
      clearContent,
      clearNodes,
      command,
      createParagraphNear: createParagraphNear2,
      cut,
      deleteCurrentNode,
      deleteNode,
      deleteRange: deleteRange2,
      deleteSelection: deleteSelection2,
      enter,
      exitCode: exitCode2,
      extendMarkRange,
      first,
      focus,
      forEach,
      insertContent,
      insertContentAt,
      joinUp: joinUp2,
      joinDown: joinDown2,
      joinBackward: joinBackward2,
      joinForward: joinForward2,
      joinItemBackward,
      joinItemForward,
      keyboardShortcut,
      lift: lift3,
      liftEmptyBlock: liftEmptyBlock2,
      liftListItem: liftListItem2,
      newlineInCode: newlineInCode2,
      resetAttributes,
      scrollIntoView,
      selectAll: selectAll2,
      selectNodeBackward: selectNodeBackward2,
      selectNodeForward: selectNodeForward2,
      selectParentNode: selectParentNode2,
      selectTextblockEnd: selectTextblockEnd2,
      selectTextblockStart: selectTextblockStart2,
      setContent,
      setMark,
      setMeta,
      setNode,
      setNodeSelection,
      setTextSelection,
      sinkListItem: sinkListItem2,
      splitBlock: splitBlock2,
      splitListItem,
      toggleList,
      toggleMark,
      toggleNode,
      toggleWrap,
      undoInputRule,
      unsetAllMarks,
      unsetMark,
      updateAttributes,
      wrapIn: wrapIn2,
      wrapInList: wrapInList2
    });
    Commands = Extension.create({
      name: "commands",
      addCommands() {
        return {
          ...commands
        };
      }
    });
    Editable = Extension.create({
      name: "editable",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("editable"),
            props: {
              editable: () => this.editor.options.editable
            }
          })
        ];
      }
    });
    FocusEvents = Extension.create({
      name: "focusEvents",
      addProseMirrorPlugins() {
        const { editor } = this;
        return [
          new Plugin({
            key: new PluginKey("focusEvents"),
            props: {
              handleDOMEvents: {
                focus: (view, event) => {
                  editor.isFocused = true;
                  const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                  view.dispatch(transaction);
                  return false;
                },
                blur: (view, event) => {
                  editor.isFocused = false;
                  const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                  view.dispatch(transaction);
                  return false;
                }
              }
            }
          })
        ];
      }
    });
    Keymap = Extension.create({
      name: "keymap",
      addKeyboardShortcuts() {
        const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.undoInputRule(),
          // maybe convert first text block node to default node
          () => commands2.command(({ tr: tr2 }) => {
            const { selection, doc: doc3 } = tr2;
            const { empty: empty2, $anchor } = selection;
            const { pos, parent } = $anchor;
            const $parentPos = $anchor.parent.isTextblock ? tr2.doc.resolve(pos - 1) : $anchor;
            const parentIsIsolating = $parentPos.parent.type.spec.isolating;
            const parentPos = $anchor.pos - $anchor.parentOffset;
            const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
            if (!empty2 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
              return false;
            }
            return commands2.clearNodes();
          }),
          () => commands2.deleteSelection(),
          () => commands2.joinBackward(),
          () => commands2.selectNodeBackward()
        ]);
        const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.deleteSelection(),
          () => commands2.deleteCurrentNode(),
          () => commands2.joinForward(),
          () => commands2.selectNodeForward()
        ]);
        const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.newlineInCode(),
          () => commands2.createParagraphNear(),
          () => commands2.liftEmptyBlock(),
          () => commands2.splitBlock()
        ]);
        const baseKeymap = {
          Enter: handleEnter,
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: handleBackspace,
          "Mod-Backspace": handleBackspace,
          "Shift-Backspace": handleBackspace,
          Delete: handleDelete,
          "Mod-Delete": handleDelete,
          "Mod-a": () => this.editor.commands.selectAll()
        };
        const pcKeymap = {
          ...baseKeymap
        };
        const macKeymap = {
          ...baseKeymap,
          "Ctrl-h": handleBackspace,
          "Alt-Backspace": handleBackspace,
          "Ctrl-d": handleDelete,
          "Ctrl-Alt-Backspace": handleDelete,
          "Alt-Delete": handleDelete,
          "Alt-d": handleDelete,
          "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
          "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
        };
        if (isiOS() || isMacOS()) {
          return macKeymap;
        }
        return pcKeymap;
      },
      addProseMirrorPlugins() {
        return [
          // With this plugin we check if the whole document was selected and deleted.
          // In this case we will additionally call `clearNodes()` to convert e.g. a heading
          // to a paragraph if necessary.
          // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
          // with many other commands.
          new Plugin({
            key: new PluginKey("clearDocument"),
            appendTransaction: (transactions, oldState, newState) => {
              const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
              if (!docChanges) {
                return;
              }
              const { empty: empty2, from: from2, to } = oldState.selection;
              const allFrom = Selection.atStart(oldState.doc).from;
              const allEnd = Selection.atEnd(oldState.doc).to;
              const allWasSelected = from2 === allFrom && to === allEnd;
              if (empty2 || !allWasSelected) {
                return;
              }
              const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
              if (!isEmpty) {
                return;
              }
              const tr2 = newState.tr;
              const state = createChainableState({
                state: newState,
                transaction: tr2
              });
              const { commands: commands2 } = new CommandManager({
                editor: this.editor,
                state
              });
              commands2.clearNodes();
              if (!tr2.steps.length) {
                return;
              }
              return tr2;
            }
          })
        ];
      }
    });
    Tabindex = Extension.create({
      name: "tabindex",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("tabindex"),
            props: {
              attributes: this.editor.isEditable ? { tabindex: "0" } : {}
            }
          })
        ];
      }
    });
    Mark2 = class _Mark {
      constructor(config = {}) {
        this.type = "mark";
        this.name = "mark";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = {
          ...this.config,
          ...config
        };
        this.name = this.config.name;
        if (config.defaultOptions) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
          this.options = callOrReturn(getExtensionField(this, "addOptions", {
            name: this.name
          }));
        }
        this.storage = callOrReturn(getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(config = {}) {
        return new _Mark(config);
      }
      configure(options2 = {}) {
        const extension = this.extend();
        extension.options = mergeDeep(this.options, options2);
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new _Mark(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        if (extendedConfig.defaultOptions) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
          name: extension.name
        }));
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
      static handleExit({ editor, mark }) {
        const { tr: tr2 } = editor.state;
        const currentPos = editor.state.selection.$from;
        const isAtEnd = currentPos.pos === currentPos.end();
        if (isAtEnd) {
          const currentMarks = currentPos.marks();
          const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
          if (!isInMark) {
            return false;
          }
          const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
          if (removeMark2) {
            tr2.removeStoredMark(removeMark2);
          }
          tr2.insertText(" ", currentPos.pos);
          editor.view.dispatch(tr2);
          return true;
        }
        return false;
      }
    };
    Node3 = class _Node {
      constructor(config = {}) {
        this.type = "node";
        this.name = "node";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = {
          ...this.config,
          ...config
        };
        this.name = this.config.name;
        if (config.defaultOptions) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
          this.options = callOrReturn(getExtensionField(this, "addOptions", {
            name: this.name
          }));
        }
        this.storage = callOrReturn(getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(config = {}) {
        return new _Node(config);
      }
      configure(options2 = {}) {
        const extension = this.extend();
        extension.options = mergeDeep(this.options, options2);
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new _Node(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        if (extendedConfig.defaultOptions) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
          name: extension.name
        }));
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
    };
  }
});

// node_modules/.pnpm/prosemirror-dropcursor@1.8.1/node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options2 = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options2);
    }
  });
}
var DropCursorView;
var init_dist19 = __esm({
  "node_modules/.pnpm/prosemirror-dropcursor@1.8.1/node_modules/prosemirror-dropcursor/dist/index.js"() {
    init_dist6();
    init_dist5();
    DropCursorView = class {
      constructor(editorView, options2) {
        var _a178;
        this.editorView = editorView;
        this.cursorPos = null;
        this.element = null;
        this.timeout = -1;
        this.width = (_a178 = options2.width) !== null && _a178 !== void 0 ? _a178 : 1;
        this.color = options2.color === false ? void 0 : options2.color || "black";
        this.class = options2.class;
        this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name3) => {
          let handler = (e) => {
            this[name3](e);
          };
          editorView.dom.addEventListener(name3, handler);
          return { name: name3, handler };
        });
      }
      destroy() {
        this.handlers.forEach(({ name: name3, handler }) => this.editorView.dom.removeEventListener(name3, handler));
      }
      update(editorView, prevState) {
        if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
          if (this.cursorPos > editorView.state.doc.content.size)
            this.setCursor(null);
          else
            this.updateOverlay();
        }
      }
      setCursor(pos) {
        if (pos == this.cursorPos)
          return;
        this.cursorPos = pos;
        if (pos == null) {
          this.element.parentNode.removeChild(this.element);
          this.element = null;
        } else {
          this.updateOverlay();
        }
      }
      updateOverlay() {
        let $pos = this.editorView.state.doc.resolve(this.cursorPos);
        let isBlock = !$pos.parent.inlineContent, rect;
        if (isBlock) {
          let before = $pos.nodeBefore, after = $pos.nodeAfter;
          if (before || after) {
            let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
            if (node) {
              let nodeRect = node.getBoundingClientRect();
              let top = before ? nodeRect.bottom : nodeRect.top;
              if (before && after)
                top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
              rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };
            }
          }
        }
        if (!rect) {
          let coords = this.editorView.coordsAtPos(this.cursorPos);
          rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
        }
        let parent = this.editorView.dom.offsetParent;
        if (!this.element) {
          this.element = parent.appendChild(document.createElement("div"));
          if (this.class)
            this.element.className = this.class;
          this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
          if (this.color) {
            this.element.style.backgroundColor = this.color;
          }
        }
        this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
        this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
        let parentLeft, parentTop;
        if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
          parentLeft = -pageXOffset;
          parentTop = -pageYOffset;
        } else {
          let rect2 = parent.getBoundingClientRect();
          parentLeft = rect2.left - parent.scrollLeft;
          parentTop = rect2.top - parent.scrollTop;
        }
        this.element.style.left = rect.left - parentLeft + "px";
        this.element.style.top = rect.top - parentTop + "px";
        this.element.style.width = rect.right - rect.left + "px";
        this.element.style.height = rect.bottom - rect.top + "px";
      }
      scheduleRemoval(timeout) {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => this.setCursor(null), timeout);
      }
      dragover(event) {
        if (!this.editorView.editable)
          return;
        let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
        let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
        let disableDropCursor = node && node.type.spec.disableDropCursor;
        let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
        if (pos && !disabled) {
          let target = pos.pos;
          if (this.editorView.dragging && this.editorView.dragging.slice) {
            let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
            if (point != null)
              target = point;
          }
          this.setCursor(target);
          this.scheduleRemoval(5e3);
        }
      }
      dragend() {
        this.scheduleRemoval(20);
      }
      drop() {
        this.scheduleRemoval(20);
      }
      dragleave(event) {
        if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
          this.setCursor(null);
      }
    };
  }
});

// node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/dropcursor/dist/index.js
var init_dist20 = __esm({
  "node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/dropcursor/dist/index.js"() {
    init_dist19();
  }
});

// node_modules/.pnpm/prosemirror-gapcursor@1.3.2/node_modules/prosemirror-gapcursor/dist/index.js
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index8 = $pos.index(d), parent = $pos.node(d);
    if (index8 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index8 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index8 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index8 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index8); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
function arrow2(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i2 = insert.length - 1; i2 >= 0; i2--)
    frag = Fragment.from(insert[i2].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}
var GapCursor, GapBookmark, handleKeyDown;
var init_dist21 = __esm({
  "node_modules/.pnpm/prosemirror-gapcursor@1.3.2/node_modules/prosemirror-gapcursor/dist/index.js"() {
    init_dist10();
    init_dist6();
    init_dist4();
    init_dist8();
    GapCursor = class _GapCursor extends Selection {
      /**
      Create a gap cursor.
      */
      constructor($pos) {
        super($pos, $pos);
      }
      map(doc3, mapping) {
        let $pos = doc3.resolve(mapping.map(this.head));
        return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
      }
      content() {
        return Slice.empty;
      }
      eq(other) {
        return other instanceof _GapCursor && other.head == this.head;
      }
      toJSON() {
        return { type: "gapcursor", pos: this.head };
      }
      /**
      @internal
      */
      static fromJSON(doc3, json2) {
        if (typeof json2.pos != "number")
          throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new _GapCursor(doc3.resolve(json2.pos));
      }
      /**
      @internal
      */
      getBookmark() {
        return new GapBookmark(this.anchor);
      }
      /**
      @internal
      */
      static valid($pos) {
        let parent = $pos.parent;
        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
          return false;
        let override = parent.type.spec.allowGapCursor;
        if (override != null)
          return override;
        let deflt = parent.contentMatchAt($pos.index()).defaultType;
        return deflt && deflt.isTextblock;
      }
      /**
      @internal
      */
      static findGapCursorFrom($pos, dir, mustMove = false) {
        search:
          for (; ; ) {
            if (!mustMove && _GapCursor.valid($pos))
              return $pos;
            let pos = $pos.pos, next = null;
            for (let d = $pos.depth; ; d--) {
              let parent = $pos.node(d);
              if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
                next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
                break;
              } else if (d == 0) {
                return null;
              }
              pos += dir;
              let $cur = $pos.doc.resolve(pos);
              if (_GapCursor.valid($cur))
                return $cur;
            }
            for (; ; ) {
              let inside = dir > 0 ? next.firstChild : next.lastChild;
              if (!inside) {
                if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
                  $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                  mustMove = false;
                  continue search;
                }
                break;
              }
              next = inside;
              pos += dir;
              let $cur = $pos.doc.resolve(pos);
              if (_GapCursor.valid($cur))
                return $cur;
            }
            return null;
          }
      }
    };
    GapCursor.prototype.visible = false;
    GapCursor.findFrom = GapCursor.findGapCursorFrom;
    Selection.jsonID("gapcursor", GapCursor);
    GapBookmark = class _GapBookmark {
      constructor(pos) {
        this.pos = pos;
      }
      map(mapping) {
        return new _GapBookmark(mapping.map(this.pos));
      }
      resolve(doc3) {
        let $pos = doc3.resolve(this.pos);
        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
      }
    };
    handleKeyDown = keydownHandler({
      "ArrowLeft": arrow2("horiz", -1),
      "ArrowRight": arrow2("horiz", 1),
      "ArrowUp": arrow2("vert", -1),
      "ArrowDown": arrow2("vert", 1)
    });
  }
});

// node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/gapcursor/dist/index.js
var init_dist22 = __esm({
  "node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/gapcursor/dist/index.js"() {
    init_dist21();
  }
});

// node_modules/.pnpm/rope-sequence@1.3.4/node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE, RopeSequence, Leaf, Append, dist_default;
var init_dist23 = __esm({
  "node_modules/.pnpm/rope-sequence@1.3.4/node_modules/rope-sequence/dist/index.js"() {
    GOOD_LEAF_SIZE = 200;
    RopeSequence = function RopeSequence2() {
    };
    RopeSequence.prototype.append = function append(other) {
      if (!other.length) {
        return this;
      }
      other = RopeSequence.from(other);
      return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
    };
    RopeSequence.prototype.prepend = function prepend(other) {
      if (!other.length) {
        return this;
      }
      return RopeSequence.from(other).append(this);
    };
    RopeSequence.prototype.appendInner = function appendInner(other) {
      return new Append(this, other);
    };
    RopeSequence.prototype.slice = function slice(from2, to) {
      if (from2 === void 0)
        from2 = 0;
      if (to === void 0)
        to = this.length;
      if (from2 >= to) {
        return RopeSequence.empty;
      }
      return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
    };
    RopeSequence.prototype.get = function get3(i2) {
      if (i2 < 0 || i2 >= this.length) {
        return void 0;
      }
      return this.getInner(i2);
    };
    RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
      if (from2 === void 0)
        from2 = 0;
      if (to === void 0)
        to = this.length;
      if (from2 <= to) {
        this.forEachInner(f, from2, to, 0);
      } else {
        this.forEachInvertedInner(f, from2, to, 0);
      }
    };
    RopeSequence.prototype.map = function map(f, from2, to) {
      if (from2 === void 0)
        from2 = 0;
      if (to === void 0)
        to = this.length;
      var result = [];
      this.forEach(function(elt, i2) {
        return result.push(f(elt, i2));
      }, from2, to);
      return result;
    };
    RopeSequence.from = function from(values) {
      if (values instanceof RopeSequence) {
        return values;
      }
      return values && values.length ? new Leaf(values) : RopeSequence.empty;
    };
    Leaf = /* @__PURE__ */ function(RopeSequence3) {
      function Leaf2(values) {
        RopeSequence3.call(this);
        this.values = values;
      }
      if (RopeSequence3)
        Leaf2.__proto__ = RopeSequence3;
      Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
      Leaf2.prototype.constructor = Leaf2;
      var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
      Leaf2.prototype.flatten = function flatten() {
        return this.values;
      };
      Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
        if (from2 == 0 && to == this.length) {
          return this;
        }
        return new Leaf2(this.values.slice(from2, to));
      };
      Leaf2.prototype.getInner = function getInner(i2) {
        return this.values[i2];
      };
      Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
        for (var i2 = from2; i2 < to; i2++) {
          if (f(this.values[i2], start + i2) === false) {
            return false;
          }
        }
      };
      Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
        for (var i2 = from2 - 1; i2 >= to; i2--) {
          if (f(this.values[i2], start + i2) === false) {
            return false;
          }
        }
      };
      Leaf2.prototype.leafAppend = function leafAppend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf2(this.values.concat(other.flatten()));
        }
      };
      Leaf2.prototype.leafPrepend = function leafPrepend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf2(other.flatten().concat(this.values));
        }
      };
      prototypeAccessors.length.get = function() {
        return this.values.length;
      };
      prototypeAccessors.depth.get = function() {
        return 0;
      };
      Object.defineProperties(Leaf2.prototype, prototypeAccessors);
      return Leaf2;
    }(RopeSequence);
    RopeSequence.empty = new Leaf([]);
    Append = /* @__PURE__ */ function(RopeSequence3) {
      function Append2(left, right) {
        RopeSequence3.call(this);
        this.left = left;
        this.right = right;
        this.length = left.length + right.length;
        this.depth = Math.max(left.depth, right.depth) + 1;
      }
      if (RopeSequence3)
        Append2.__proto__ = RopeSequence3;
      Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
      Append2.prototype.constructor = Append2;
      Append2.prototype.flatten = function flatten() {
        return this.left.flatten().concat(this.right.flatten());
      };
      Append2.prototype.getInner = function getInner(i2) {
        return i2 < this.left.length ? this.left.get(i2) : this.right.get(i2 - this.left.length);
      };
      Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
        var leftLen = this.left.length;
        if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
          return false;
        }
        if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
          return false;
        }
      };
      Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
        var leftLen = this.left.length;
        if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
          return false;
        }
        if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
          return false;
        }
      };
      Append2.prototype.sliceInner = function sliceInner(from2, to) {
        if (from2 == 0 && to == this.length) {
          return this;
        }
        var leftLen = this.left.length;
        if (to <= leftLen) {
          return this.left.slice(from2, to);
        }
        if (from2 >= leftLen) {
          return this.right.slice(from2 - leftLen, to - leftLen);
        }
        return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
      };
      Append2.prototype.leafAppend = function leafAppend(other) {
        var inner = this.right.leafAppend(other);
        if (inner) {
          return new Append2(this.left, inner);
        }
      };
      Append2.prototype.leafPrepend = function leafPrepend(other) {
        var inner = this.left.leafPrepend(other);
        if (inner) {
          return new Append2(inner, this.right);
        }
      };
      Append2.prototype.appendInner = function appendInner2(other) {
        if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
          return new Append2(this.left, new Append2(this.right, other));
        }
        return new Append2(this, other);
      };
      return Append2;
    }(RopeSequence);
    dist_default = RopeSequence;
  }
});

// node_modules/.pnpm/prosemirror-history@1.3.2/node_modules/prosemirror-history/dist/index.js
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i2) => {
    if (item.selection && n-- == 0) {
      cutPoint = i2;
      return false;
    }
  });
  return items.slice(cutPoint);
}
function applyTransaction(history2, state, tr2, options2) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options2, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps[tr2.steps.length - 1]), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options2, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options2.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps[tr2.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options2, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start, end) => {
    for (let i2 = 0; i2 < prevRanges.length; i2 += 2)
      if (start <= prevRanges[i2 + 1] && end >= prevRanges[i2])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(map2) {
  let result = [];
  map2.forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i2 = 0; i2 < ranges.length; i2 += 2) {
    let from2 = mapping.map(ranges[i2], 1), to = mapping.map(ranges[i2 + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, dispatch, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i2 = 0; i2 < plugins.length; i2++)
      if (plugins[i2].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
var max_empty_items, Branch, Item, HistoryState, DEPTH_OVERFLOW, cachedPreserveItems, cachedPreserveItemsPlugins, historyKey, closeHistoryKey, undo, redo;
var init_dist24 = __esm({
  "node_modules/.pnpm/prosemirror-history@1.3.2/node_modules/prosemirror-history/dist/index.js"() {
    init_dist23();
    init_dist5();
    init_dist6();
    max_empty_items = 500;
    Branch = class _Branch {
      constructor(items, eventCount) {
        this.items = items;
        this.eventCount = eventCount;
      }
      // Pop the latest event off the branch's history and apply it
      // to a document transform.
      popEvent(state, preserveItems) {
        if (this.eventCount == 0)
          return null;
        let end = this.items.length;
        for (; ; end--) {
          let next = this.items.get(end - 1);
          if (next.selection) {
            --end;
            break;
          }
        }
        let remap, mapFrom;
        if (preserveItems) {
          remap = this.remapping(end, this.items.length);
          mapFrom = remap.maps.length;
        }
        let transform = state.tr;
        let selection, remaining;
        let addAfter = [], addBefore = [];
        this.items.forEach((item, i2) => {
          if (!item.step) {
            if (!remap) {
              remap = this.remapping(end, i2 + 1);
              mapFrom = remap.maps.length;
            }
            mapFrom--;
            addBefore.push(item);
            return;
          }
          if (remap) {
            addBefore.push(new Item(item.map));
            let step = item.step.map(remap.slice(mapFrom)), map2;
            if (step && transform.maybeStep(step).doc) {
              map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
              addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
            }
            mapFrom--;
            if (map2)
              remap.appendMap(map2, mapFrom);
          } else {
            transform.maybeStep(item.step);
          }
          if (item.selection) {
            selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
            remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
            return false;
          }
        }, this.items.length, 0);
        return { remaining, transform, selection };
      }
      // Create a new branch with the given transform added.
      addTransform(transform, selection, histOptions, preserveItems) {
        let newItems = [], eventCount = this.eventCount;
        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
        for (let i2 = 0; i2 < transform.steps.length; i2++) {
          let step = transform.steps[i2].invert(transform.docs[i2]);
          let item = new Item(transform.mapping.maps[i2], step, selection), merged;
          if (merged = lastItem && lastItem.merge(item)) {
            item = merged;
            if (i2)
              newItems.pop();
            else
              oldItems = oldItems.slice(0, oldItems.length - 1);
          }
          newItems.push(item);
          if (selection) {
            eventCount++;
            selection = void 0;
          }
          if (!preserveItems)
            lastItem = item;
        }
        let overflow = eventCount - histOptions.depth;
        if (overflow > DEPTH_OVERFLOW) {
          oldItems = cutOffEvents(oldItems, overflow);
          eventCount -= overflow;
        }
        return new _Branch(oldItems.append(newItems), eventCount);
      }
      remapping(from2, to) {
        let maps = new Mapping();
        this.items.forEach((item, i2) => {
          let mirrorPos = item.mirrorOffset != null && i2 - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
          maps.appendMap(item.map, mirrorPos);
        }, from2, to);
        return maps;
      }
      addMaps(array2) {
        if (this.eventCount == 0)
          return this;
        return new _Branch(this.items.append(array2.map((map2) => new Item(map2))), this.eventCount);
      }
      // When the collab module receives remote changes, the history has
      // to know about those, so that it can adjust the steps that were
      // rebased on top of the remote changes, and include the position
      // maps for the remote changes in its array of items.
      rebased(rebasedTransform, rebasedCount) {
        if (!this.eventCount)
          return this;
        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
        let mapping = rebasedTransform.mapping;
        let newUntil = rebasedTransform.steps.length;
        let eventCount = this.eventCount;
        this.items.forEach((item) => {
          if (item.selection)
            eventCount--;
        }, start);
        let iRebased = rebasedCount;
        this.items.forEach((item) => {
          let pos = mapping.getMirror(--iRebased);
          if (pos == null)
            return;
          newUntil = Math.min(newUntil, pos);
          let map2 = mapping.maps[pos];
          if (item.step) {
            let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
            let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
            if (selection)
              eventCount++;
            rebasedItems.push(new Item(map2, step, selection));
          } else {
            rebasedItems.push(new Item(map2));
          }
        }, start);
        let newMaps = [];
        for (let i2 = rebasedCount; i2 < newUntil; i2++)
          newMaps.push(new Item(mapping.maps[i2]));
        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
        let branch = new _Branch(items, eventCount);
        if (branch.emptyItemCount() > max_empty_items)
          branch = branch.compress(this.items.length - rebasedItems.length);
        return branch;
      }
      emptyItemCount() {
        let count = 0;
        this.items.forEach((item) => {
          if (!item.step)
            count++;
        });
        return count;
      }
      // Compressing a branch means rewriting it to push the air (map-only
      // items) out. During collaboration, these naturally accumulate
      // because each remote change adds one. The `upto` argument is used
      // to ensure that only the items below a given level are compressed,
      // because `rebased` relies on a clean, untouched set of items in
      // order to associate old items with rebased steps.
      compress(upto = this.items.length) {
        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
        let items = [], events = 0;
        this.items.forEach((item, i2) => {
          if (i2 >= upto) {
            items.push(item);
            if (item.selection)
              events++;
          } else if (item.step) {
            let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
            mapFrom--;
            if (map2)
              remap.appendMap(map2, mapFrom);
            if (step) {
              let selection = item.selection && item.selection.map(remap.slice(mapFrom));
              if (selection)
                events++;
              let newItem = new Item(map2.invert(), step, selection), merged, last2 = items.length - 1;
              if (merged = items.length && items[last2].merge(newItem))
                items[last2] = merged;
              else
                items.push(newItem);
            }
          } else if (item.map) {
            mapFrom--;
          }
        }, this.items.length, 0);
        return new _Branch(dist_default.from(items.reverse()), events);
      }
    };
    Branch.empty = new Branch(dist_default.empty, 0);
    Item = class _Item {
      constructor(map2, step, selection, mirrorOffset) {
        this.map = map2;
        this.step = step;
        this.selection = selection;
        this.mirrorOffset = mirrorOffset;
      }
      merge(other) {
        if (this.step && other.step && !other.selection) {
          let step = other.step.merge(this.step);
          if (step)
            return new _Item(step.getMap().invert(), step, this.selection);
        }
      }
    };
    HistoryState = class {
      constructor(done, undone, prevRanges, prevTime, prevComposition) {
        this.done = done;
        this.undone = undone;
        this.prevRanges = prevRanges;
        this.prevTime = prevTime;
        this.prevComposition = prevComposition;
      }
    };
    DEPTH_OVERFLOW = 20;
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = null;
    historyKey = new PluginKey("history");
    closeHistoryKey = new PluginKey("closeHistory");
    undo = (state, dispatch) => {
      let hist = historyKey.getState(state);
      if (!hist || hist.done.eventCount == 0)
        return false;
      if (dispatch)
        histTransaction(hist, state, dispatch, false);
      return true;
    };
    redo = (state, dispatch) => {
      let hist = historyKey.getState(state);
      if (!hist || hist.undone.eventCount == 0)
        return false;
      if (dispatch)
        histTransaction(hist, state, dispatch, true);
      return true;
    };
  }
});

// node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/history/dist/index.js
var init_dist25 = __esm({
  "node_modules/.pnpm/@tiptap+pm@2.1.10/node_modules/@tiptap/pm/history/dist/index.js"() {
    init_dist24();
  }
});

// node_modules/.pnpm/@tiptap+extension-code-block@2.1.10_@tiptap+core@2.1.10_@tiptap+pm@2.1.10/node_modules/@tiptap/extension-code-block/dist/index.js
var backtickInputRegex, tildeInputRegex, CodeBlock;
var init_dist26 = __esm({
  "node_modules/.pnpm/@tiptap+extension-code-block@2.1.10_@tiptap+core@2.1.10_@tiptap+pm@2.1.10/node_modules/@tiptap/extension-code-block/dist/index.js"() {
    init_dist18();
    init_dist7();
    backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
    tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
    CodeBlock = Node3.create({
      name: "codeBlock",
      addOptions() {
        return {
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          HTMLAttributes: {}
        };
      },
      content: "text*",
      marks: "",
      group: "block",
      code: true,
      defining: true,
      addAttributes() {
        return {
          language: {
            default: null,
            parseHTML: (element) => {
              var _a178;
              const { languageClassPrefix } = this.options;
              const classNames = [...((_a178 = element.firstElementChild) === null || _a178 === void 0 ? void 0 : _a178.classList) || []];
              const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
              const language = languages[0];
              if (!language) {
                return null;
              }
              return language;
            },
            rendered: false
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "pre",
            preserveWhitespace: "full"
          }
        ];
      },
      renderHTML({ node, HTMLAttributes }) {
        return [
          "pre",
          mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
          [
            "code",
            {
              class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
            },
            0
          ]
        ];
      },
      addCommands() {
        return {
          setCodeBlock: (attributes) => ({ commands: commands2 }) => {
            return commands2.setNode(this.name, attributes);
          },
          toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
            return commands2.toggleNode(this.name, "paragraph", attributes);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
          // remove code block when at start of document or code block is empty
          Backspace: () => {
            const { empty: empty2, $anchor } = this.editor.state.selection;
            const isAtStart = $anchor.pos === 1;
            if (!empty2 || $anchor.parent.type.name !== this.name) {
              return false;
            }
            if (isAtStart || !$anchor.parent.textContent.length) {
              return this.editor.commands.clearNodes();
            }
            return false;
          },
          // exit node on triple enter
          Enter: ({ editor }) => {
            if (!this.options.exitOnTripleEnter) {
              return false;
            }
            const { state } = editor;
            const { selection } = state;
            const { $from, empty: empty2 } = selection;
            if (!empty2 || $from.parent.type !== this.type) {
              return false;
            }
            const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
            const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
            if (!isAtEnd || !endsWithDoubleNewline) {
              return false;
            }
            return editor.chain().command(({ tr: tr2 }) => {
              tr2.delete($from.pos - 2, $from.pos);
              return true;
            }).exitCode().run();
          },
          // exit node on arrow down
          ArrowDown: ({ editor }) => {
            if (!this.options.exitOnArrowDown) {
              return false;
            }
            const { state } = editor;
            const { selection, doc: doc3 } = state;
            const { $from, empty: empty2 } = selection;
            if (!empty2 || $from.parent.type !== this.type) {
              return false;
            }
            const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
            if (!isAtEnd) {
              return false;
            }
            const after = $from.after();
            if (after === void 0) {
              return false;
            }
            const nodeAfter = doc3.nodeAt(after);
            if (nodeAfter) {
              return false;
            }
            return editor.commands.exitCode();
          }
        };
      },
      addInputRules() {
        return [
          textblockTypeInputRule({
            find: backtickInputRegex,
            type: this.type,
            getAttributes: (match) => ({
              language: match[1]
            })
          }),
          textblockTypeInputRule({
            find: tildeInputRegex,
            type: this.type,
            getAttributes: (match) => ({
              language: match[1]
            })
          })
        ];
      },
      addProseMirrorPlugins() {
        return [
          // this plugin creates a code block for pasted content from VS Code
          // we can also detect the copied code language
          new Plugin({
            key: new PluginKey("codeBlockVSCodeHandler"),
            props: {
              handlePaste: (view, event) => {
                if (!event.clipboardData) {
                  return false;
                }
                if (this.editor.isActive(this.type.name)) {
                  return false;
                }
                const text3 = event.clipboardData.getData("text/plain");
                const vscode = event.clipboardData.getData("vscode-editor-data");
                const vscodeData = vscode ? JSON.parse(vscode) : void 0;
                const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
                if (!text3 || !language) {
                  return false;
                }
                const { tr: tr2 } = view.state;
                tr2.replaceSelectionWith(this.type.create({ language }));
                tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
                tr2.insertText(text3.replace(/\r\n?/g, "\n"));
                tr2.setMeta("paste", true);
                view.dispatch(tr2);
                return true;
              }
            }
          })
        ];
      }
    });
  }
});

// node_modules/.pnpm/@tiptap+extension-code-block-lowlight@2.1.10_@tiptap+core@2.1.10_@tiptap+extension-code-block@2.1.10_@tiptap+pm@2.1.10/node_modules/@tiptap/extension-code-block-lowlight/dist/index.js
function deepFreeze(obj) {
  if (obj instanceof Map) {
    obj.clear = obj.delete = obj.set = function() {
      throw new Error("map is read-only");
    };
  } else if (obj instanceof Set) {
    obj.add = obj.clear = obj.delete = function() {
      throw new Error("set is read-only");
    };
  }
  Object.freeze(obj);
  Object.getOwnPropertyNames(obj).forEach(function(name3) {
    var prop = obj[name3];
    if (typeof prop == "object" && !Object.isFrozen(prop)) {
      deepFreeze(prop);
    }
  });
  return obj;
}
function escapeHTML(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function inherit$1(original, ...objects) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key3 in original) {
    result[key3] = original[key3];
  }
  objects.forEach(function(obj) {
    for (const key3 in obj) {
      result[key3] = obj[key3];
    }
  });
  return (
    /** @type {T} */
    result
  );
}
function source(re3) {
  if (!re3)
    return null;
  if (typeof re3 === "string")
    return re3;
  return re3.source;
}
function lookahead(re3) {
  return concat("(?=", re3, ")");
}
function anyNumberOfTimes(re3) {
  return concat("(?:", re3, ")*");
}
function optional(re3) {
  return concat("(?:", re3, ")?");
}
function concat(...args) {
  const joined = args.map((x2) => source(x2)).join("");
  return joined;
}
function stripOptionsFromArgs(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either(...args) {
  const opts = stripOptionsFromArgs(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x2) => source(x2)).join("|") + ")";
  return joined;
}
function countMatchGroups(re3) {
  return new RegExp(re3.toString() + "|").exec("").length - 1;
}
function startsWith(re3, lexeme) {
  const match = re3 && re3.exec(lexeme);
  return match && match.index === 0;
}
function _rewriteBackreferences(regexps, { joinWith }) {
  let numCaptures = 0;
  return regexps.map((regex) => {
    numCaptures += 1;
    const offset2 = numCaptures;
    let re3 = source(regex);
    let out = "";
    while (re3.length > 0) {
      const match = BACKREF_RE.exec(re3);
      if (!match) {
        out += re3;
        break;
      }
      out += re3.substring(0, match.index);
      re3 = re3.substring(match.index + match[0].length);
      if (match[0][0] === "\\" && match[1]) {
        out += "\\" + String(Number(match[1]) + offset2);
      } else {
        out += match[0];
        if (match[0] === "(") {
          numCaptures++;
        }
      }
    }
    return out;
  }).map((re3) => `(${re3})`).join(joinWith);
}
function skipIfHasPrecedingDot(match, response) {
  const before = match.input[match.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}
function scopeClassName(mode, _parent) {
  if (mode.className !== void 0) {
    mode.scope = mode.className;
    delete mode.className;
  }
}
function beginKeywords(mode, parent) {
  if (!parent)
    return;
  if (!mode.beginKeywords)
    return;
  mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
  mode.__beforeBegin = skipIfHasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;
  if (mode.relevance === void 0)
    mode.relevance = 0;
}
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal))
    return;
  mode.illegal = either(...mode.illegal);
}
function compileMatch(mode, _parent) {
  if (!mode.match)
    return;
  if (mode.begin || mode.end)
    throw new Error("begin & end are not supported with match");
  mode.begin = mode.match;
  delete mode.match;
}
function compileRelevance(mode, _parent) {
  if (mode.relevance === void 0)
    mode.relevance = 1;
}
function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
  const compiledKeywords = /* @__PURE__ */ Object.create(null);
  if (typeof rawKeywords === "string") {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName2) {
      Object.assign(
        compiledKeywords,
        compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
      );
    });
  }
  return compiledKeywords;
  function compileList(scopeName2, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map((x2) => x2.toLowerCase());
    }
    keywordList.forEach(function(keyword) {
      const pair = keyword.split("|");
      compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
    });
  }
}
function scoreForKeyword(keyword, providedScore) {
  if (providedScore) {
    return Number(providedScore);
  }
  return commonKeyword(keyword) ? 0 : 1;
}
function commonKeyword(keyword) {
  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
}
function remapScopeNames(mode, regexes, { key: key3 }) {
  let offset2 = 0;
  const scopeNames = mode[key3];
  const emit = {};
  const positions = {};
  for (let i2 = 1; i2 <= regexes.length; i2++) {
    positions[i2 + offset2] = scopeNames[i2];
    emit[i2 + offset2] = true;
    offset2 += countMatchGroups(regexes[i2 - 1]);
  }
  mode[key3] = positions;
  mode[key3]._emit = emit;
  mode[key3]._multi = true;
}
function beginMultiClass(mode) {
  if (!Array.isArray(mode.begin))
    return;
  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error2("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error2("beginScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.begin, { key: "beginScope" });
  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
}
function endMultiClass(mode) {
  if (!Array.isArray(mode.end))
    return;
  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error2("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error2("endScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.end, { key: "endScope" });
  mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
}
function scopeSugar(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}
function MultiClass(mode) {
  scopeSugar(mode);
  if (typeof mode.beginScope === "string") {
    mode.beginScope = { _wrap: mode.beginScope };
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = { _wrap: mode.endScope };
  }
  beginMultiClass(mode);
  endMultiClass(mode);
}
function compileLanguage(language) {
  function langRe(value, global2) {
    return new RegExp(
      source(value),
      "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
    );
  }
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }
    // @ts-ignore
    addRule(re3, opts) {
      opts.position = this.position++;
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re3]);
      this.matchAt += countMatchGroups(re3) + 1;
    }
    compile() {
      if (this.regexes.length === 0) {
        this.exec = () => null;
      }
      const terminators = this.regexes.map((el) => el[1]);
      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
      this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(s2) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match = this.matcherRe.exec(s2);
      if (!match) {
        return null;
      }
      const i2 = match.findIndex((el, i3) => i3 > 0 && el !== void 0);
      const matchData = this.matchIndexes[i2];
      match.splice(0, i2);
      return Object.assign(match, matchData);
    }
  }
  class ResumableMultiRegex {
    constructor() {
      this.rules = [];
      this.multiRegexes = [];
      this.count = 0;
      this.lastIndex = 0;
      this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(index8) {
      if (this.multiRegexes[index8])
        return this.multiRegexes[index8];
      const matcher = new MultiRegex();
      this.rules.slice(index8).forEach(([re3, opts]) => matcher.addRule(re3, opts));
      matcher.compile();
      this.multiRegexes[index8] = matcher;
      return matcher;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(re3, opts) {
      this.rules.push([re3, opts]);
      if (opts.type === "begin")
        this.count++;
    }
    /** @param {string} s */
    exec(s2) {
      const m = this.getMatcher(this.regexIndex);
      m.lastIndex = this.lastIndex;
      let result = m.exec(s2);
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex)
          ;
        else {
          const m2 = this.getMatcher(0);
          m2.lastIndex = this.lastIndex + 1;
          result = m2.exec(s2);
        }
      }
      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          this.considerAll();
        }
      }
      return result;
    }
  }
  function buildModeRegex(mode) {
    const mm = new ResumableMultiRegex();
    mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
    if (mode.terminatorEnd) {
      mm.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm.addRule(mode.illegal, { type: "illegal" });
    }
    return mm;
  }
  function compileMode(mode, parent) {
    const cmode = (
      /** @type CompiledMode */
      mode
    );
    if (mode.isCompiled)
      return cmode;
    [
      scopeClassName,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      compileMatch,
      MultiClass,
      beforeMatchExt
    ].forEach((ext) => ext(mode, parent));
    language.compilerExtensions.forEach((ext) => ext(mode, parent));
    mode.__beforeBegin = null;
    [
      beginKeywords,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      compileIllegal,
      // default to 1 relevance if not specified
      compileRelevance
    ].forEach((ext) => ext(mode, parent));
    mode.isCompiled = true;
    let keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;
    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
    }
    cmode.keywordPatternRe = langRe(keywordPattern, true);
    if (parent) {
      if (!mode.begin)
        mode.begin = /\B|\b/;
      cmode.beginRe = langRe(cmode.begin);
      if (!mode.end && !mode.endsWithParent)
        mode.end = /\B|\b/;
      if (mode.end)
        cmode.endRe = langRe(cmode.end);
      cmode.terminatorEnd = source(cmode.end) || "";
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
      }
    }
    if (mode.illegal)
      cmode.illegalRe = langRe(
        /** @type {RegExp | string} */
        mode.illegal
      );
    if (!mode.contains)
      mode.contains = [];
    mode.contains = [].concat(...mode.contains.map(function(c) {
      return expandOrCloneMode(c === "self" ? mode : c);
    }));
    mode.contains.forEach(function(c) {
      compileMode(
        /** @type Mode */
        c,
        cmode
      );
    });
    if (mode.starts) {
      compileMode(mode.starts, parent);
    }
    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }
  if (!language.compilerExtensions)
    language.compilerExtensions = [];
  if (language.contains && language.contains.includes("self")) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }
  language.classNameAliases = inherit$1(language.classNameAliases || {});
  return compileMode(
    /** @type Mode */
    language
  );
}
function dependencyOnParent(mode) {
  if (!mode)
    return false;
  return mode.endsWithParent || dependencyOnParent(mode.starts);
}
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1(mode, { variants: null }, variant);
    });
  }
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }
  if (dependencyOnParent(mode)) {
    return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
  }
  if (Object.isFrozen(mode)) {
    return inherit$1(mode);
  }
  return mode;
}
function parseNodes(nodes, className = []) {
  return nodes.map((node) => {
    const classes = [...className, ...node.properties ? node.properties.className : []];
    if (node.children) {
      return parseNodes(node.children, classes);
    }
    return {
      text: node.value,
      classes
    };
  }).flat();
}
function getHighlightNodes(result) {
  return result.value || result.children || [];
}
function registered(aliasOrLanguage) {
  return Boolean(HighlightJS.getLanguage(aliasOrLanguage));
}
function getDecorations({ doc: doc3, name: name3, lowlight, defaultLanguage }) {
  const decorations = [];
  findChildren(doc3, (node) => node.type.name === name3).forEach((block) => {
    let from2 = block.pos + 1;
    const language = block.node.attrs.language || defaultLanguage;
    const languages = lowlight.listLanguages();
    const nodes = language && (languages.includes(language) || registered(language)) ? getHighlightNodes(lowlight.highlight(language, block.node.textContent)) : getHighlightNodes(lowlight.highlightAuto(block.node.textContent));
    parseNodes(nodes).forEach((node) => {
      const to = from2 + node.text.length;
      if (node.classes.length) {
        const decoration = Decoration.inline(from2, to, {
          class: node.classes.join(" ")
        });
        decorations.push(decoration);
      }
      from2 = to;
    });
  });
  return DecorationSet.create(doc3, decorations);
}
function isFunction3(param2) {
  return typeof param2 === "function";
}
function LowlightPlugin({ name: name3, lowlight, defaultLanguage }) {
  if (!["highlight", "highlightAuto", "listLanguages"].every((api) => isFunction3(lowlight[api]))) {
    throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
  }
  const lowlightPlugin = new Plugin({
    key: new PluginKey("lowlight"),
    state: {
      init: (_, { doc: doc3 }) => getDecorations({
        doc: doc3,
        name: name3,
        lowlight,
        defaultLanguage
      }),
      apply: (transaction, decorationSet, oldState, newState) => {
        const oldNodeName = oldState.selection.$head.parent.type.name;
        const newNodeName = newState.selection.$head.parent.type.name;
        const oldNodes = findChildren(oldState.doc, (node) => node.type.name === name3);
        const newNodes = findChildren(newState.doc, (node) => node.type.name === name3);
        if (transaction.docChanged && ([oldNodeName, newNodeName].includes(name3) || newNodes.length !== oldNodes.length || transaction.steps.some((step) => {
          return (
            // @ts-ignore
            step.from !== void 0 && step.to !== void 0 && oldNodes.some((node) => {
              return (
                // @ts-ignore
                node.pos >= step.from && node.pos + node.node.nodeSize <= step.to
              );
            })
          );
        }))) {
          return getDecorations({
            doc: transaction.doc,
            name: name3,
            lowlight,
            defaultLanguage
          });
        }
        return decorationSet.map(transaction.mapping, transaction.doc);
      }
    },
    props: {
      decorations(state) {
        return lowlightPlugin.getState(state);
      }
    }
  });
  return lowlightPlugin;
}
var deepFreezeEs6, Response2, SPAN_CLOSE, emitsWrappingTags, scopeToCSSClass, HTMLRenderer, newNode, TokenTree, TokenTreeEmitter, BACKREF_RE, MATCH_NOTHING_RE, IDENT_RE, UNDERSCORE_IDENT_RE, NUMBER_RE, C_NUMBER_RE, BINARY_NUMBER_RE, RE_STARTERS_RE, SHEBANG, BACKSLASH_ESCAPE, APOS_STRING_MODE, QUOTE_STRING_MODE, PHRASAL_WORDS_MODE, COMMENT, C_LINE_COMMENT_MODE, C_BLOCK_COMMENT_MODE, HASH_COMMENT_MODE, NUMBER_MODE, C_NUMBER_MODE, BINARY_NUMBER_MODE, REGEXP_MODE, TITLE_MODE, UNDERSCORE_TITLE_MODE, METHOD_GUARD, END_SAME_AS_BEGIN, MODES, beforeMatchExt, COMMON_KEYWORDS, DEFAULT_KEYWORD_SCOPE, seenDeprecations, error2, warn, deprecated, MultiClassError, version, HTMLInjectionError, escape3, inherit, NO_MATCH, MAX_KEYWORD_HITS, HLJS, highlight, core, HighlightJS, CodeBlockLowlight;
var init_dist27 = __esm({
  "node_modules/.pnpm/@tiptap+extension-code-block-lowlight@2.1.10_@tiptap+core@2.1.10_@tiptap+extension-code-block@2.1.10_@tiptap+pm@2.1.10/node_modules/@tiptap/extension-code-block-lowlight/dist/index.js"() {
    init_dist26();
    init_dist18();
    init_dist7();
    init_dist9();
    deepFreezeEs6 = { exports: {} };
    deepFreezeEs6.exports = deepFreeze;
    deepFreezeEs6.exports.default = deepFreeze;
    Response2 = class {
      /**
       * @param {CompiledMode} mode
       */
      constructor(mode) {
        if (mode.data === void 0)
          mode.data = {};
        this.data = mode.data;
        this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    };
    SPAN_CLOSE = "</span>";
    emitsWrappingTags = (node) => {
      return !!node.scope || node.sublanguage && node.language;
    };
    scopeToCSSClass = (name3, { prefix }) => {
      if (name3.includes(".")) {
        const pieces = name3.split(".");
        return [
          `${prefix}${pieces.shift()}`,
          ...pieces.map((x2, i2) => `${x2}${"_".repeat(i2 + 1)}`)
        ].join(" ");
      }
      return `${prefix}${name3}`;
    };
    HTMLRenderer = class {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(parseTree, options2) {
        this.buffer = "";
        this.classPrefix = options2.classPrefix;
        parseTree.walk(this);
      }
      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(text3) {
        this.buffer += escapeHTML(text3);
      }
      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(node) {
        if (!emitsWrappingTags(node))
          return;
        let className = "";
        if (node.sublanguage) {
          className = `language-${node.language}`;
        } else {
          className = scopeToCSSClass(node.scope, { prefix: this.classPrefix });
        }
        this.span(className);
      }
      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(node) {
        if (!emitsWrappingTags(node))
          return;
        this.buffer += SPAN_CLOSE;
      }
      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }
      // helpers
      /**
       * Builds a span element
       *
       * @param {string} className */
      span(className) {
        this.buffer += `<span class="${className}">`;
      }
    };
    newNode = (opts = {}) => {
      const result = { children: [] };
      Object.assign(result, opts);
      return result;
    };
    TokenTree = class _TokenTree {
      constructor() {
        this.rootNode = newNode();
        this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      /** @param {Node} node */
      add(node) {
        this.top.children.push(node);
      }
      /** @param {string} scope */
      openNode(scope) {
        const node = newNode({ scope });
        this.add(node);
        this.stack.push(node);
      }
      closeNode() {
        if (this.stack.length > 1) {
          return this.stack.pop();
        }
        return void 0;
      }
      closeAllNodes() {
        while (this.closeNode())
          ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(builder2) {
        return this.constructor._walk(builder2, this.rootNode);
      }
      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(builder2, node) {
        if (typeof node === "string") {
          builder2.addText(node);
        } else if (node.children) {
          builder2.openNode(node);
          node.children.forEach((child) => this._walk(builder2, child));
          builder2.closeNode(node);
        }
        return builder2;
      }
      /**
       * @param {Node} node
       */
      static _collapse(node) {
        if (typeof node === "string")
          return;
        if (!node.children)
          return;
        if (node.children.every((el) => typeof el === "string")) {
          node.children = [node.children.join("")];
        } else {
          node.children.forEach((child) => {
            _TokenTree._collapse(child);
          });
        }
      }
    };
    TokenTreeEmitter = class extends TokenTree {
      /**
       * @param {*} options
       */
      constructor(options2) {
        super();
        this.options = options2;
      }
      /**
       * @param {string} text
       * @param {string} scope
       */
      addKeyword(text3, scope) {
        if (text3 === "") {
          return;
        }
        this.openNode(scope);
        this.addText(text3);
        this.closeNode();
      }
      /**
       * @param {string} text
       */
      addText(text3) {
        if (text3 === "") {
          return;
        }
        this.add(text3);
      }
      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      addSublanguage(emitter, name3) {
        const node = emitter.root;
        node.sublanguage = true;
        node.language = name3;
        this.add(node);
      }
      toHTML() {
        const renderer = new HTMLRenderer(this, this.options);
        return renderer.value();
      }
      finalize() {
        return true;
      }
    };
    BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    MATCH_NOTHING_RE = /\b\B/;
    IDENT_RE = "[a-zA-Z]\\w*";
    UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
    NUMBER_RE = "\\b\\d+(\\.\\d+)?";
    C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
    BINARY_NUMBER_RE = "\\b(0b[01]+)";
    RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
    SHEBANG = (opts = {}) => {
      const beginShebang = /^#![ ]*\//;
      if (opts.binary) {
        opts.begin = concat(
          beginShebang,
          /.*\b/,
          opts.binary,
          /\b.*/
        );
      }
      return inherit$1({
        scope: "meta",
        begin: beginShebang,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (m, resp) => {
          if (m.index !== 0)
            resp.ignoreMatch();
        }
      }, opts);
    };
    BACKSLASH_ESCAPE = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    };
    APOS_STRING_MODE = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    QUOTE_STRING_MODE = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    PHRASAL_WORDS_MODE = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    COMMENT = function(begin, end, modeOptions = {}) {
      const mode = inherit$1(
        {
          scope: "comment",
          begin,
          end,
          contains: []
        },
        modeOptions
      );
      mode.contains.push({
        scope: "doctag",
        // hack to avoid the space from being included. the space is necessary to
        // match here to prevent the plain text rule below from gobbling up doctags
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const ENGLISH_WORD = either(
        // list of common 1 and 2 letter words in English
        "I",
        "a",
        "is",
        "so",
        "us",
        "to",
        "at",
        "if",
        "in",
        "it",
        "on",
        // note: this is not an exhaustive list of contractions, just popular ones
        /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
        // contractions - can't we'd they're let's, etc
        /[A-Za-z]+[-][a-z]+/,
        // `no-way`, etc.
        /[A-Za-z][a-z]{2,}/
        // allow capitalized words at beginning of sentences
      );
      mode.contains.push(
        {
          // TODO: how to include ", (, ) without breaking grammars that use these for
          // comment delimiters?
          // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
          // ---
          // this tries to find sequences of 3 english words in a row (without any
          // "programming" type syntax) this gives us a strong signal that we've
          // TRULY found a comment - vs perhaps scanning with the wrong language.
          // It's possible to find something that LOOKS like the start of the
          // comment - but then if there is no readable text - good chance it is a
          // false match and not a comment.
          //
          // for a visual example please see:
          // https://github.com/highlightjs/highlight.js/issues/2827
          begin: concat(
            /[ ]+/,
            // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
            "(",
            ENGLISH_WORD,
            /[.]?[:]?([.][ ]|[ ])/,
            "){3}"
          )
          // look for 3 words in a row
        }
      );
      return mode;
    };
    C_LINE_COMMENT_MODE = COMMENT("//", "$");
    C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
    HASH_COMMENT_MODE = COMMENT("#", "$");
    NUMBER_MODE = {
      scope: "number",
      begin: NUMBER_RE,
      relevance: 0
    };
    C_NUMBER_MODE = {
      scope: "number",
      begin: C_NUMBER_RE,
      relevance: 0
    };
    BINARY_NUMBER_MODE = {
      scope: "number",
      begin: BINARY_NUMBER_RE,
      relevance: 0
    };
    REGEXP_MODE = {
      // this outer rule makes sure we actually have a WHOLE regex and not simply
      // an expression such as:
      //
      //     3 / something
      //
      // (which will then blow up when regex's `illegal` sees the newline)
      begin: /(?=\/[^/\n]*\/)/,
      contains: [{
        scope: "regexp",
        begin: /\//,
        end: /\/[gimuy]*/,
        illegal: /\n/,
        contains: [
          BACKSLASH_ESCAPE,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [BACKSLASH_ESCAPE]
          }
        ]
      }]
    };
    TITLE_MODE = {
      scope: "title",
      begin: IDENT_RE,
      relevance: 0
    };
    UNDERSCORE_TITLE_MODE = {
      scope: "title",
      begin: UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    METHOD_GUARD = {
      // excludes method names from keyword processing
      begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    END_SAME_AS_BEGIN = function(mode) {
      return Object.assign(
        mode,
        {
          /** @type {ModeCallback} */
          "on:begin": (m, resp) => {
            resp.data._beginMatch = m[1];
          },
          /** @type {ModeCallback} */
          "on:end": (m, resp) => {
            if (resp.data._beginMatch !== m[1])
              resp.ignoreMatch();
          }
        }
      );
    };
    MODES = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      MATCH_NOTHING_RE,
      IDENT_RE,
      UNDERSCORE_IDENT_RE,
      NUMBER_RE,
      C_NUMBER_RE,
      BINARY_NUMBER_RE,
      RE_STARTERS_RE,
      SHEBANG,
      BACKSLASH_ESCAPE,
      APOS_STRING_MODE,
      QUOTE_STRING_MODE,
      PHRASAL_WORDS_MODE,
      COMMENT,
      C_LINE_COMMENT_MODE,
      C_BLOCK_COMMENT_MODE,
      HASH_COMMENT_MODE,
      NUMBER_MODE,
      C_NUMBER_MODE,
      BINARY_NUMBER_MODE,
      REGEXP_MODE,
      TITLE_MODE,
      UNDERSCORE_TITLE_MODE,
      METHOD_GUARD,
      END_SAME_AS_BEGIN
    });
    beforeMatchExt = (mode, parent) => {
      if (!mode.beforeMatch)
        return;
      if (mode.starts)
        throw new Error("beforeMatch cannot be used with starts");
      const originalMode = Object.assign({}, mode);
      Object.keys(mode).forEach((key3) => {
        delete mode[key3];
      });
      mode.keywords = originalMode.keywords;
      mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
      mode.starts = {
        relevance: 0,
        contains: [
          Object.assign(originalMode, { endsParent: true })
        ]
      };
      mode.relevance = 0;
      delete originalMode.beforeMatch;
    };
    COMMON_KEYWORDS = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      // common variable name
      "list",
      // common variable name
      "value"
      // common variable name
    ];
    DEFAULT_KEYWORD_SCOPE = "keyword";
    seenDeprecations = {};
    error2 = (message) => {
      console.error(message);
    };
    warn = (message, ...args) => {
      console.log(`WARN: ${message}`, ...args);
    };
    deprecated = (version2, message) => {
      if (seenDeprecations[`${version2}/${message}`])
        return;
      console.log(`Deprecated as of ${version2}. ${message}`);
      seenDeprecations[`${version2}/${message}`] = true;
    };
    MultiClassError = new Error();
    version = "11.6.0";
    HTMLInjectionError = class extends Error {
      constructor(reason, html) {
        super(reason);
        this.name = "HTMLInjectionError";
        this.html = html;
      }
    };
    escape3 = escapeHTML;
    inherit = inherit$1;
    NO_MATCH = Symbol("nomatch");
    MAX_KEYWORD_HITS = 7;
    HLJS = function(hljs) {
      const languages = /* @__PURE__ */ Object.create(null);
      const aliases = /* @__PURE__ */ Object.create(null);
      const plugins = [];
      let SAFE_MODE = true;
      const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
      let options2 = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: TokenTreeEmitter
      };
      function shouldNotHighlight(languageName) {
        return options2.noHighlightRe.test(languageName);
      }
      function blockLanguage(block) {
        let classes = block.className + " ";
        classes += block.parentNode ? block.parentNode.className : "";
        const match = options2.languageDetectRe.exec(classes);
        if (match) {
          const language = getLanguage(match[1]);
          if (!language) {
            warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
            warn("Falling back to no-highlight mode for this block.", block);
          }
          return language ? match[1] : "no-highlight";
        }
        return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
      }
      function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
        let code = "";
        let languageName = "";
        if (typeof optionsOrCode === "object") {
          code = codeOrLanguageName;
          ignoreIllegals = optionsOrCode.ignoreIllegals;
          languageName = optionsOrCode.language;
        } else {
          deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
          deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
          languageName = codeOrLanguageName;
          code = optionsOrCode;
        }
        if (ignoreIllegals === void 0) {
          ignoreIllegals = true;
        }
        const context = {
          code,
          language: languageName
        };
        fire("before:highlight", context);
        const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
        result.code = context.code;
        fire("after:highlight", result);
        return result;
      }
      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
        const keywordHits = /* @__PURE__ */ Object.create(null);
        function keywordData(mode, matchText) {
          return mode.keywords[matchText];
        }
        function processKeywords() {
          if (!top.keywords) {
            emitter.addText(modeBuffer);
            return;
          }
          let lastIndex = 0;
          top.keywordPatternRe.lastIndex = 0;
          let match = top.keywordPatternRe.exec(modeBuffer);
          let buf = "";
          while (match) {
            buf += modeBuffer.substring(lastIndex, match.index);
            const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
            const data = keywordData(top, word);
            if (data) {
              const [kind, keywordRelevance] = data;
              emitter.addText(buf);
              buf = "";
              keywordHits[word] = (keywordHits[word] || 0) + 1;
              if (keywordHits[word] <= MAX_KEYWORD_HITS)
                relevance += keywordRelevance;
              if (kind.startsWith("_")) {
                buf += match[0];
              } else {
                const cssClass = language.classNameAliases[kind] || kind;
                emitter.addKeyword(match[0], cssClass);
              }
            } else {
              buf += match[0];
            }
            lastIndex = top.keywordPatternRe.lastIndex;
            match = top.keywordPatternRe.exec(modeBuffer);
          }
          buf += modeBuffer.substring(lastIndex);
          emitter.addText(buf);
        }
        function processSubLanguage() {
          if (modeBuffer === "")
            return;
          let result2 = null;
          if (typeof top.subLanguage === "string") {
            if (!languages[top.subLanguage]) {
              emitter.addText(modeBuffer);
              return;
            }
            result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
            continuations[top.subLanguage] = /** @type {CompiledMode} */
            result2._top;
          } else {
            result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
          }
          if (top.relevance > 0) {
            relevance += result2.relevance;
          }
          emitter.addSublanguage(result2._emitter, result2.language);
        }
        function processBuffer() {
          if (top.subLanguage != null) {
            processSubLanguage();
          } else {
            processKeywords();
          }
          modeBuffer = "";
        }
        function emitMultiClass(scope, match) {
          let i2 = 1;
          const max2 = match.length - 1;
          while (i2 <= max2) {
            if (!scope._emit[i2]) {
              i2++;
              continue;
            }
            const klass = language.classNameAliases[scope[i2]] || scope[i2];
            const text3 = match[i2];
            if (klass) {
              emitter.addKeyword(text3, klass);
            } else {
              modeBuffer = text3;
              processKeywords();
              modeBuffer = "";
            }
            i2++;
          }
        }
        function startNewMode(mode, match) {
          if (mode.scope && typeof mode.scope === "string") {
            emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
          }
          if (mode.beginScope) {
            if (mode.beginScope._wrap) {
              emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
              modeBuffer = "";
            } else if (mode.beginScope._multi) {
              emitMultiClass(mode.beginScope, match);
              modeBuffer = "";
            }
          }
          top = Object.create(mode, { parent: { value: top } });
          return top;
        }
        function endOfMode(mode, match, matchPlusRemainder) {
          let matched = startsWith(mode.endRe, matchPlusRemainder);
          if (matched) {
            if (mode["on:end"]) {
              const resp = new Response2(mode);
              mode["on:end"](match, resp);
              if (resp.isMatchIgnored)
                matched = false;
            }
            if (matched) {
              while (mode.endsParent && mode.parent) {
                mode = mode.parent;
              }
              return mode;
            }
          }
          if (mode.endsWithParent) {
            return endOfMode(mode.parent, match, matchPlusRemainder);
          }
        }
        function doIgnore(lexeme) {
          if (top.matcher.regexIndex === 0) {
            modeBuffer += lexeme[0];
            return 1;
          } else {
            resumeScanAtSamePosition = true;
            return 0;
          }
        }
        function doBeginMatch(match) {
          const lexeme = match[0];
          const newMode = match.rule;
          const resp = new Response2(newMode);
          const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
          for (const cb of beforeCallbacks) {
            if (!cb)
              continue;
            cb(match, resp);
            if (resp.isMatchIgnored)
              return doIgnore(lexeme);
          }
          if (newMode.skip) {
            modeBuffer += lexeme;
          } else {
            if (newMode.excludeBegin) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (!newMode.returnBegin && !newMode.excludeBegin) {
              modeBuffer = lexeme;
            }
          }
          startNewMode(newMode, match);
          return newMode.returnBegin ? 0 : lexeme.length;
        }
        function doEndMatch(match) {
          const lexeme = match[0];
          const matchPlusRemainder = codeToHighlight.substring(match.index);
          const endMode = endOfMode(top, match, matchPlusRemainder);
          if (!endMode) {
            return NO_MATCH;
          }
          const origin = top;
          if (top.endScope && top.endScope._wrap) {
            processBuffer();
            emitter.addKeyword(lexeme, top.endScope._wrap);
          } else if (top.endScope && top.endScope._multi) {
            processBuffer();
            emitMultiClass(top.endScope, match);
          } else if (origin.skip) {
            modeBuffer += lexeme;
          } else {
            if (!(origin.returnEnd || origin.excludeEnd)) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (origin.excludeEnd) {
              modeBuffer = lexeme;
            }
          }
          do {
            if (top.scope) {
              emitter.closeNode();
            }
            if (!top.skip && !top.subLanguage) {
              relevance += top.relevance;
            }
            top = top.parent;
          } while (top !== endMode.parent);
          if (endMode.starts) {
            startNewMode(endMode.starts, match);
          }
          return origin.returnEnd ? 0 : lexeme.length;
        }
        function processContinuations() {
          const list = [];
          for (let current = top; current !== language; current = current.parent) {
            if (current.scope) {
              list.unshift(current.scope);
            }
          }
          list.forEach((item) => emitter.openNode(item));
        }
        let lastMatch = {};
        function processLexeme(textBeforeMatch, match) {
          const lexeme = match && match[0];
          modeBuffer += textBeforeMatch;
          if (lexeme == null) {
            processBuffer();
            return 0;
          }
          if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
            if (!SAFE_MODE) {
              const err = new Error(`0 width match regex (${languageName})`);
              err.languageName = languageName;
              err.badRule = lastMatch.rule;
              throw err;
            }
            return 1;
          }
          lastMatch = match;
          if (match.type === "begin") {
            return doBeginMatch(match);
          } else if (match.type === "illegal" && !ignoreIllegals) {
            const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
            err.mode = top;
            throw err;
          } else if (match.type === "end") {
            const processed = doEndMatch(match);
            if (processed !== NO_MATCH) {
              return processed;
            }
          }
          if (match.type === "illegal" && lexeme === "") {
            return 1;
          }
          if (iterations > 1e5 && iterations > match.index * 3) {
            const err = new Error("potential infinite loop, way more iterations than matches");
            throw err;
          }
          modeBuffer += lexeme;
          return lexeme.length;
        }
        const language = getLanguage(languageName);
        if (!language) {
          error2(LANGUAGE_NOT_FOUND.replace("{}", languageName));
          throw new Error('Unknown language: "' + languageName + '"');
        }
        const md = compileLanguage(language);
        let result = "";
        let top = continuation || md;
        const continuations = {};
        const emitter = new options2.__emitter(options2);
        processContinuations();
        let modeBuffer = "";
        let relevance = 0;
        let index8 = 0;
        let iterations = 0;
        let resumeScanAtSamePosition = false;
        try {
          top.matcher.considerAll();
          for (; ; ) {
            iterations++;
            if (resumeScanAtSamePosition) {
              resumeScanAtSamePosition = false;
            } else {
              top.matcher.considerAll();
            }
            top.matcher.lastIndex = index8;
            const match = top.matcher.exec(codeToHighlight);
            if (!match)
              break;
            const beforeMatch = codeToHighlight.substring(index8, match.index);
            const processedCount = processLexeme(beforeMatch, match);
            index8 = match.index + processedCount;
          }
          processLexeme(codeToHighlight.substring(index8));
          emitter.closeAllNodes();
          emitter.finalize();
          result = emitter.toHTML();
          return {
            language: languageName,
            value: result,
            relevance,
            illegal: false,
            _emitter: emitter,
            _top: top
          };
        } catch (err) {
          if (err.message && err.message.includes("Illegal")) {
            return {
              language: languageName,
              value: escape3(codeToHighlight),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: err.message,
                index: index8,
                context: codeToHighlight.slice(index8 - 100, index8 + 100),
                mode: err.mode,
                resultSoFar: result
              },
              _emitter: emitter
            };
          } else if (SAFE_MODE) {
            return {
              language: languageName,
              value: escape3(codeToHighlight),
              illegal: false,
              relevance: 0,
              errorRaised: err,
              _emitter: emitter,
              _top: top
            };
          } else {
            throw err;
          }
        }
      }
      function justTextHighlightResult(code) {
        const result = {
          value: escape3(code),
          illegal: false,
          relevance: 0,
          _top: PLAINTEXT_LANGUAGE,
          _emitter: new options2.__emitter(options2)
        };
        result._emitter.addText(code);
        return result;
      }
      function highlightAuto(code, languageSubset) {
        languageSubset = languageSubset || options2.languages || Object.keys(languages);
        const plaintext = justTextHighlightResult(code);
        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
          (name3) => _highlight(name3, code, false)
        );
        results.unshift(plaintext);
        const sorted = results.sort((a2, b) => {
          if (a2.relevance !== b.relevance)
            return b.relevance - a2.relevance;
          if (a2.language && b.language) {
            if (getLanguage(a2.language).supersetOf === b.language) {
              return 1;
            } else if (getLanguage(b.language).supersetOf === a2.language) {
              return -1;
            }
          }
          return 0;
        });
        const [best, secondBest] = sorted;
        const result = best;
        result.secondBest = secondBest;
        return result;
      }
      function updateClassName(element, currentLang, resultLang) {
        const language = currentLang && aliases[currentLang] || resultLang;
        element.classList.add("hljs");
        element.classList.add(`language-${language}`);
      }
      function highlightElement(element) {
        let node = null;
        const language = blockLanguage(element);
        if (shouldNotHighlight(language))
          return;
        fire(
          "before:highlightElement",
          { el: element, language }
        );
        if (element.children.length > 0) {
          if (!options2.ignoreUnescapedHTML) {
            console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
            console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
            console.warn("The element with unescaped HTML:");
            console.warn(element);
          }
          if (options2.throwUnescapedHTML) {
            const err = new HTMLInjectionError(
              "One of your code blocks includes unescaped HTML.",
              element.innerHTML
            );
            throw err;
          }
        }
        node = element;
        const text3 = node.textContent;
        const result = language ? highlight2(text3, { language, ignoreIllegals: true }) : highlightAuto(text3);
        element.innerHTML = result.value;
        updateClassName(element, language, result.language);
        element.result = {
          language: result.language,
          // TODO: remove with version 11.0
          re: result.relevance,
          relevance: result.relevance
        };
        if (result.secondBest) {
          element.secondBest = {
            language: result.secondBest.language,
            relevance: result.secondBest.relevance
          };
        }
        fire("after:highlightElement", { el: element, result, text: text3 });
      }
      function configure(userOptions) {
        options2 = inherit(options2, userOptions);
      }
      const initHighlighting = () => {
        highlightAll();
        deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      };
      function initHighlightingOnLoad() {
        highlightAll();
        deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      }
      let wantsHighlight = false;
      function highlightAll() {
        if (document.readyState === "loading") {
          wantsHighlight = true;
          return;
        }
        const blocks = document.querySelectorAll(options2.cssSelector);
        blocks.forEach(highlightElement);
      }
      function boot() {
        if (wantsHighlight)
          highlightAll();
      }
      if (typeof window !== "undefined" && window.addEventListener) {
        window.addEventListener("DOMContentLoaded", boot, false);
      }
      function registerLanguage(languageName, languageDefinition) {
        let lang = null;
        try {
          lang = languageDefinition(hljs);
        } catch (error$1) {
          error2("Language definition for '{}' could not be registered.".replace("{}", languageName));
          if (!SAFE_MODE) {
            throw error$1;
          } else {
            error2(error$1);
          }
          lang = PLAINTEXT_LANGUAGE;
        }
        if (!lang.name)
          lang.name = languageName;
        languages[languageName] = lang;
        lang.rawDefinition = languageDefinition.bind(null, hljs);
        if (lang.aliases) {
          registerAliases(lang.aliases, { languageName });
        }
      }
      function unregisterLanguage(languageName) {
        delete languages[languageName];
        for (const alias of Object.keys(aliases)) {
          if (aliases[alias] === languageName) {
            delete aliases[alias];
          }
        }
      }
      function listLanguages() {
        return Object.keys(languages);
      }
      function getLanguage(name3) {
        name3 = (name3 || "").toLowerCase();
        return languages[name3] || languages[aliases[name3]];
      }
      function registerAliases(aliasList, { languageName }) {
        if (typeof aliasList === "string") {
          aliasList = [aliasList];
        }
        aliasList.forEach((alias) => {
          aliases[alias.toLowerCase()] = languageName;
        });
      }
      function autoDetection(name3) {
        const lang = getLanguage(name3);
        return lang && !lang.disableAutodetect;
      }
      function upgradePluginAPI(plugin) {
        if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
          plugin["before:highlightElement"] = (data) => {
            plugin["before:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
        if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
          plugin["after:highlightElement"] = (data) => {
            plugin["after:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
      }
      function addPlugin(plugin) {
        upgradePluginAPI(plugin);
        plugins.push(plugin);
      }
      function fire(event, args) {
        const cb = event;
        plugins.forEach(function(plugin) {
          if (plugin[cb]) {
            plugin[cb](args);
          }
        });
      }
      function deprecateHighlightBlock(el) {
        deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
        deprecated("10.7.0", "Please use highlightElement now.");
        return highlightElement(el);
      }
      Object.assign(hljs, {
        highlight: highlight2,
        highlightAuto,
        highlightAll,
        highlightElement,
        // TODO: Remove with v12 API
        highlightBlock: deprecateHighlightBlock,
        configure,
        initHighlighting,
        initHighlightingOnLoad,
        registerLanguage,
        unregisterLanguage,
        listLanguages,
        getLanguage,
        registerAliases,
        autoDetection,
        inherit,
        addPlugin
      });
      hljs.debugMode = function() {
        SAFE_MODE = false;
      };
      hljs.safeMode = function() {
        SAFE_MODE = true;
      };
      hljs.versionString = version;
      hljs.regex = {
        concat,
        lookahead,
        either,
        optional,
        anyNumberOfTimes
      };
      for (const key3 in MODES) {
        if (typeof MODES[key3] === "object") {
          deepFreezeEs6.exports(MODES[key3]);
        }
      }
      Object.assign(hljs, MODES);
      return hljs;
    };
    highlight = HLJS({});
    core = highlight;
    highlight.HighlightJS = highlight;
    highlight.default = highlight;
    HighlightJS = core;
    CodeBlockLowlight = CodeBlock.extend({
      addOptions() {
        var _a178;
        return {
          ...(_a178 = this.parent) === null || _a178 === void 0 ? void 0 : _a178.call(this),
          lowlight: {},
          defaultLanguage: null
        };
      },
      addProseMirrorPlugins() {
        var _a178;
        return [
          ...((_a178 = this.parent) === null || _a178 === void 0 ? void 0 : _a178.call(this)) || [],
          LowlightPlugin({
            name: this.name,
            lowlight: this.options.lowlight,
            defaultLanguage: this.options.defaultLanguage
          })
        ];
      }
    });
  }
});

// node_modules/.pnpm/linkifyjs@4.1.1/node_modules/linkifyjs/dist/linkify.es.js
function registerGroup(name3, groups) {
  if (!(name3 in groups)) {
    groups[name3] = [];
  }
  return groups[name3];
}
function addToGroups(t, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t) < 0) {
      group.push(t);
    }
  }
}
function flagsForToken(t, groups) {
  const result = {};
  for (const c in groups) {
    if (groups[c].indexOf(t) >= 0) {
      result[c] = true;
    }
  }
  return result;
}
function State(token) {
  if (token === void 0) {
    token = null;
  }
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
function init$2(customSchemes) {
  if (customSchemes === void 0) {
    customSchemes = [];
  }
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, ASCII_LETTER, Word);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, LETTER, UWord);
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, NL, NL$1, {
    [whitespace]: true
  });
  tt(Ws, NL);
  tr(Ws, SPACE, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
  for (let i2 = 0; i2 < tlds.length; i2++) {
    fastts(Start, tlds[i2], TLD, WORD, wordjr);
  }
  for (let i2 = 0; i2 < utlds.length; i2++) {
    fastts(Start, utlds[i2], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a2, b) => a2[0] > b[0] ? 1 : -1);
  for (let i2 = 0; i2 < customSchemes.length; i2++) {
    const sch = customSchemes[i2][0];
    const optionalSlashSlash = customSchemes[i2][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign({
      groups
    }, tk)
  };
}
function run$1(start, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index8 = 0;
  while (index8 < len) {
    let first2 = str.charCodeAt(index8);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index8 + 1 === len || (second = str.charCodeAt(index8 + 1)) < 56320 || second > 57343 ? str[index8] : str.slice(index8, index8 + 2);
    result.push(char);
    index8 += char.length;
  }
  return result;
}
function fastts(state, input, t, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i2 = 0; i2 < len - 1; i2++) {
    const char = input[i2];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack = [];
  let i2 = 0;
  let digits = "0123456789";
  while (i2 < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i2 + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack.join(""));
      for (let popCount = parseInt(encoded.substring(i2, i2 + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i2 += popDigitCount;
    } else {
      stack.push(encoded[i2]);
      i2++;
    }
  }
  return words;
}
function Options(opts, defaultRender) {
  if (defaultRender === void 0) {
    defaultRender = null;
  }
  let o = assign({}, defaults2);
  if (opts) {
    o = assign(o, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i2 = 0; i2 < ignoredTags.length; i2++) {
    uppercaseIgnoredTags.push(ignoredTags[i2].toUpperCase());
  }
  this.o = o;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
function noop3(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p2 in props) {
    Token.prototype[p2] = props[p2];
  }
  Token.t = type;
  return Token;
}
function init$1(_ref) {
  let {
    groups
  } = _ref;
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, EQUALS, HYPHEN, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const UrlOpenbrace = tt(Url$1, OPENBRACE);
  const UrlOpenbracket = tt(Url$1, OPENBRACKET);
  const UrlOpenanglebracket = tt(Url$1, OPENANGLEBRACKET);
  const UrlOpenparen = tt(Url$1, OPENPAREN);
  tt(UrlNonaccept, OPENBRACE, UrlOpenbrace);
  tt(UrlNonaccept, OPENBRACKET, UrlOpenbracket);
  tt(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);
  tt(UrlNonaccept, OPENPAREN, UrlOpenparen);
  tt(UrlOpenbrace, CLOSEBRACE, Url$1);
  tt(UrlOpenbracket, CLOSEBRACKET, Url$1);
  tt(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);
  tt(UrlOpenparen, CLOSEPAREN, Url$1);
  tt(UrlOpenbrace, CLOSEBRACE, Url$1);
  const UrlOpenbraceQ = makeState(Url);
  const UrlOpenbracketQ = makeState(Url);
  const UrlOpenanglebracketQ = makeState(Url);
  const UrlOpenparenQ = makeState(Url);
  ta(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);
  ta(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);
  ta(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);
  ta(UrlOpenparen, qsAccepting, UrlOpenparenQ);
  const UrlOpenbraceSyms = makeState();
  const UrlOpenbracketSyms = makeState();
  const UrlOpenanglebracketSyms = makeState();
  const UrlOpenparenSyms = makeState();
  ta(UrlOpenbrace, qsNonAccepting);
  ta(UrlOpenbracket, qsNonAccepting);
  ta(UrlOpenanglebracket, qsNonAccepting);
  ta(UrlOpenparen, qsNonAccepting);
  ta(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);
  ta(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);
  ta(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);
  ta(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);
  ta(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);
  ta(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);
  ta(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);
  ta(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);
  ta(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);
  ta(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);
  ta(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);
  ta(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);
  ta(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);
  ta(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);
  ta(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);
  ta(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms);
  tt(UrlOpenbracketQ, CLOSEBRACKET, Url$1);
  tt(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);
  tt(UrlOpenparenQ, CLOSEPAREN, Url$1);
  tt(UrlOpenbraceQ, CLOSEBRACE, Url$1);
  tt(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);
  tt(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);
  tt(UrlOpenparenSyms, CLOSEPAREN, Url$1);
  tt(UrlOpenbraceSyms, CLOSEPAREN, Url$1);
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL$1, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run2(start, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
function reset2() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
}
function registerCustomProtocol(scheme2, optionalSlashSlash) {
  if (optionalSlashSlash === void 0) {
    optionalSlashSlash = false;
  }
  if (INIT.initialized) {
    warn2(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error('linkifyjs: incorrect scheme format.\n 1. Must only contain digits, lowercase ASCII letters or "-"\n 2. Cannot start or end with "-"\n 3. "-" cannot repeat');
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init2() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i2 = 0; i2 < INIT.tokenQueue.length; i2++) {
    INIT.tokenQueue[i2][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i2 = 0; i2 < INIT.pluginQueue.length; i2++) {
    INIT.pluginQueue[i2][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init2();
  }
  return run2(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
function find(str, type, opts) {
  if (type === void 0) {
    type = null;
  }
  if (opts === void 0) {
    opts = null;
  }
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options2 = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i2 = 0; i2 < tokens.length; i2++) {
    const token = tokens[i2];
    if (token.isLink && (!type || token.t === type)) {
      filtered.push(token.toFormattedObject(options2));
    }
  }
  return filtered;
}
var encodedTlds, encodedUtlds, assign, numeric, ascii, alpha, asciinumeric, alphanumeric, domain, emoji, scheme, slashscheme, whitespace, ta, tr, ts, tt, WORD, UWORD, LOCALHOST, TLD, UTLD, SCHEME, SLASH_SCHEME, NUM, WS, NL$1, OPENBRACE, OPENBRACKET, OPENANGLEBRACKET, OPENPAREN, CLOSEBRACE, CLOSEBRACKET, CLOSEANGLEBRACKET, CLOSEPAREN, AMPERSAND, APOSTROPHE, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, COLON, COMMA, DOLLAR, DOT, EQUALS, EXCLAMATION, HYPHEN, PERCENT, PIPE, PLUS, POUND, QUERY, QUOTE, SEMI, SLASH, TILDE, UNDERSCORE, EMOJI$1, SYM, tk, ASCII_LETTER, LETTER, EMOJI, DIGIT, SPACE, NL, EMOJI_VARIATION, EMOJI_JOINER, tlds, utlds, defaults2, Email, Text, Nl, Url, makeState, warn2, warnAdvice, INIT;
var init_linkify_es = __esm({
  "node_modules/.pnpm/linkifyjs@4.1.1/node_modules/linkifyjs/dist/linkify.es.js"() {
    encodedTlds = "aaa1rp3barth4b0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re2s2c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y0eats7k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking0channel11l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t0isalat7u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0at2delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d0network8tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0eles2s3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster5ia3d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0cys3drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7serati6ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic3tual5v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rthwesternmutual14on4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cher3ks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w0time7i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0channel7ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u0elos6wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
    encodedUtlds = "\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u062A\u0635\u0627\u0644\u0627\u062A6\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2";
    assign = (target, properties) => {
      for (const key3 in properties) {
        target[key3] = properties[key3];
      }
      return target;
    };
    numeric = "numeric";
    ascii = "ascii";
    alpha = "alpha";
    asciinumeric = "asciinumeric";
    alphanumeric = "alphanumeric";
    domain = "domain";
    emoji = "emoji";
    scheme = "scheme";
    slashscheme = "slashscheme";
    whitespace = "whitespace";
    State.groups = {};
    State.prototype = {
      accepts() {
        return !!this.t;
      },
      /**
       * Follow an existing transition from the given input to the next state.
       * Does not mutate.
       * @param {string} input character or token type to transition on
       * @returns {?State<T>} the next state, if any
       */
      go(input) {
        const state = this;
        const nextState = state.j[input];
        if (nextState) {
          return nextState;
        }
        for (let i2 = 0; i2 < state.jr.length; i2++) {
          const regex = state.jr[i2][0];
          const nextState2 = state.jr[i2][1];
          if (nextState2 && regex.test(input)) {
            return nextState2;
          }
        }
        return state.jd;
      },
      /**
       * Whether the state has a transition for the given input. Set the second
       * argument to true to only look for an exact match (and not a default or
       * regular-expression-based transition)
       * @param {string} input
       * @param {boolean} exactOnly
       */
      has(input, exactOnly) {
        if (exactOnly === void 0) {
          exactOnly = false;
        }
        return exactOnly ? input in this.j : !!this.go(input);
      },
      /**
       * Short for "transition all"; create a transition from the array of items
       * in the given list to the same final resulting state.
       * @param {string | string[]} inputs Group of inputs to transition on
       * @param {Transition<T> | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       */
      ta(inputs, next, flags, groups) {
        for (let i2 = 0; i2 < inputs.length; i2++) {
          this.tt(inputs[i2], next, flags, groups);
        }
      },
      /**
       * Short for "take regexp transition"; defines a transition for this state
       * when it encounters a token which matches the given regular expression
       * @param {RegExp} regexp Regular expression transition (populate first)
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      tr(regexp, next, flags, groups) {
        groups = groups || State.groups;
        let nextState;
        if (next && next.j) {
          nextState = next;
        } else {
          nextState = new State(next);
          if (flags && groups) {
            addToGroups(next, flags, groups);
          }
        }
        this.jr.push([regexp, nextState]);
        return nextState;
      },
      /**
       * Short for "take transitions", will take as many sequential transitions as
       * the length of the given input and returns the
       * resulting final state.
       * @param {string | string[]} input
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      ts(input, next, flags, groups) {
        let state = this;
        const len = input.length;
        if (!len) {
          return state;
        }
        for (let i2 = 0; i2 < len - 1; i2++) {
          state = state.tt(input[i2]);
        }
        return state.tt(input[len - 1], next, flags, groups);
      },
      /**
       * Short for "take transition", this is a method for building/working with
       * state machines.
       *
       * If a state already exists for the given input, returns it.
       *
       * If a token is specified, that state will emit that token when reached by
       * the linkify engine.
       *
       * If no state exists, it will be initialized with some default transitions
       * that resemble existing default transitions.
       *
       * If a state is given for the second argument, that state will be
       * transitioned to on the given input regardless of what that input
       * previously did.
       *
       * Specify a token group flags to define groups that this token belongs to.
       * The token will be added to corresponding entires in the given groups
       * object.
       *
       * @param {string} input character, token type to transition on
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of groups
       * @returns {State<T>} taken after the given input
       */
      tt(input, next, flags, groups) {
        groups = groups || State.groups;
        const state = this;
        if (next && next.j) {
          state.j[input] = next;
          return next;
        }
        const t = next;
        let nextState, templateState = state.go(input);
        if (templateState) {
          nextState = new State();
          assign(nextState.j, templateState.j);
          nextState.jr.push.apply(nextState.jr, templateState.jr);
          nextState.jd = templateState.jd;
          nextState.t = templateState.t;
        } else {
          nextState = new State();
        }
        if (t) {
          if (groups) {
            if (nextState.t && typeof nextState.t === "string") {
              const allFlags = assign(flagsForToken(nextState.t, groups), flags);
              addToGroups(t, allFlags, groups);
            } else if (flags) {
              addToGroups(t, flags, groups);
            }
          }
          nextState.t = t;
        }
        state.j[input] = nextState;
        return nextState;
      }
    };
    ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
    tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
    ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
    tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
    WORD = "WORD";
    UWORD = "UWORD";
    LOCALHOST = "LOCALHOST";
    TLD = "TLD";
    UTLD = "UTLD";
    SCHEME = "SCHEME";
    SLASH_SCHEME = "SLASH_SCHEME";
    NUM = "NUM";
    WS = "WS";
    NL$1 = "NL";
    OPENBRACE = "OPENBRACE";
    OPENBRACKET = "OPENBRACKET";
    OPENANGLEBRACKET = "OPENANGLEBRACKET";
    OPENPAREN = "OPENPAREN";
    CLOSEBRACE = "CLOSEBRACE";
    CLOSEBRACKET = "CLOSEBRACKET";
    CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
    CLOSEPAREN = "CLOSEPAREN";
    AMPERSAND = "AMPERSAND";
    APOSTROPHE = "APOSTROPHE";
    ASTERISK = "ASTERISK";
    AT = "AT";
    BACKSLASH = "BACKSLASH";
    BACKTICK = "BACKTICK";
    CARET = "CARET";
    COLON = "COLON";
    COMMA = "COMMA";
    DOLLAR = "DOLLAR";
    DOT = "DOT";
    EQUALS = "EQUALS";
    EXCLAMATION = "EXCLAMATION";
    HYPHEN = "HYPHEN";
    PERCENT = "PERCENT";
    PIPE = "PIPE";
    PLUS = "PLUS";
    POUND = "POUND";
    QUERY = "QUERY";
    QUOTE = "QUOTE";
    SEMI = "SEMI";
    SLASH = "SLASH";
    TILDE = "TILDE";
    UNDERSCORE = "UNDERSCORE";
    EMOJI$1 = "EMOJI";
    SYM = "SYM";
    tk = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      WORD,
      UWORD,
      LOCALHOST,
      TLD,
      UTLD,
      SCHEME,
      SLASH_SCHEME,
      NUM,
      WS,
      NL: NL$1,
      OPENBRACE,
      OPENBRACKET,
      OPENANGLEBRACKET,
      OPENPAREN,
      CLOSEBRACE,
      CLOSEBRACKET,
      CLOSEANGLEBRACKET,
      CLOSEPAREN,
      AMPERSAND,
      APOSTROPHE,
      ASTERISK,
      AT,
      BACKSLASH,
      BACKTICK,
      CARET,
      COLON,
      COMMA,
      DOLLAR,
      DOT,
      EQUALS,
      EXCLAMATION,
      HYPHEN,
      PERCENT,
      PIPE,
      PLUS,
      POUND,
      QUERY,
      QUOTE,
      SEMI,
      SLASH,
      TILDE,
      UNDERSCORE,
      EMOJI: EMOJI$1,
      SYM
    });
    ASCII_LETTER = /[a-z]/;
    LETTER = /\p{L}/u;
    EMOJI = /\p{Emoji}/u;
    DIGIT = /\d/;
    SPACE = /\s/;
    NL = "\n";
    EMOJI_VARIATION = "\uFE0F";
    EMOJI_JOINER = "\u200D";
    tlds = null;
    utlds = null;
    defaults2 = {
      defaultProtocol: "http",
      events: null,
      format: noop3,
      formatHref: noop3,
      nl2br: false,
      tagName: "a",
      target: null,
      rel: null,
      validate: true,
      truncate: Infinity,
      className: null,
      attributes: null,
      ignoreTags: [],
      render: null
    };
    Options.prototype = {
      o: defaults2,
      /**
       * @type string[]
       */
      ignoreTags: [],
      /**
       * @param {IntermediateRepresentation} ir
       * @returns {any}
       */
      defaultRender(ir) {
        return ir;
      },
      /**
       * Returns true or false based on whether a token should be displayed as a
       * link based on the user options.
       * @param {MultiToken} token
       * @returns {boolean}
       */
      check(token) {
        return this.get("validate", token.toString(), token);
      },
      // Private methods
      /**
       * Resolve an option's value based on the value of the option and the given
       * params. If operator and token are specified and the target option is
       * callable, automatically calls the function with the given argument.
       * @template {keyof Opts} K
       * @param {K} key Name of option to use
       * @param {string} [operator] will be passed to the target option if it's a
       * function. If not specified, RAW function value gets returned
       * @param {MultiToken} [token] The token from linkify.tokenize
       * @returns {Opts[K] | any}
       */
      get(key3, operator, token) {
        const isCallable = operator != null;
        let option = this.o[key3];
        if (!option) {
          return option;
        }
        if (typeof option === "object") {
          option = token.t in option ? option[token.t] : defaults2[key3];
          if (typeof option === "function" && isCallable) {
            option = option(operator, token);
          }
        } else if (typeof option === "function" && isCallable) {
          option = option(operator, token.t, token);
        }
        return option;
      },
      /**
       * @template {keyof Opts} L
       * @param {L} key Name of options object to use
       * @param {string} [operator]
       * @param {MultiToken} [token]
       * @returns {Opts[L] | any}
       */
      getObj(key3, operator, token) {
        let obj = this.o[key3];
        if (typeof obj === "function" && operator != null) {
          obj = obj(operator, token.t, token);
        }
        return obj;
      },
      /**
       * Convert the given token to a rendered element that may be added to the
       * calling-interface's DOM
       * @param {MultiToken} token Token to render to an HTML element
       * @returns {any} Render result; e.g., HTML string, DOM element, React
       *   Component, etc.
       */
      render(token) {
        const ir = token.render(this);
        const renderFn = this.get("render", null, token) || this.defaultRender;
        return renderFn(ir, token.t, token);
      }
    };
    MultiToken.prototype = {
      isLink: false,
      /**
       * Return the string this token represents.
       * @return {string}
       */
      toString() {
        return this.v;
      },
      /**
       * What should the value for this token be in the `href` HTML attribute?
       * Returns the `.toString` value by default.
       * @param {string} [scheme]
       * @return {string}
      */
      toHref(scheme2) {
        return this.toString();
      },
      /**
       * @param {Options} options Formatting options
       * @returns {string}
       */
      toFormattedString(options2) {
        const val = this.toString();
        const truncate = options2.get("truncate", val, this);
        const formatted = options2.get("format", val, this);
        return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "\u2026" : formatted;
      },
      /**
       *
       * @param {Options} options
       * @returns {string}
       */
      toFormattedHref(options2) {
        return options2.get("formatHref", this.toHref(options2.get("defaultProtocol")), this);
      },
      /**
       * The start index of this token in the original input string
       * @returns {number}
       */
      startIndex() {
        return this.tk[0].s;
      },
      /**
       * The end index of this token in the original input string (up to this
       * index but not including it)
       * @returns {number}
       */
      endIndex() {
        return this.tk[this.tk.length - 1].e;
      },
      /**
      	Returns an object  of relevant values for this token, which includes keys
      	* type - Kind of token ('url', 'email', etc.)
      	* value - Original text
      	* href - The value that should be added to the anchor tag's href
      		attribute
      		@method toObject
      	@param {string} [protocol] `'http'` by default
      */
      toObject(protocol2) {
        if (protocol2 === void 0) {
          protocol2 = defaults2.defaultProtocol;
        }
        return {
          type: this.t,
          value: this.toString(),
          isLink: this.isLink,
          href: this.toHref(protocol2),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       *
       * @param {Options} options Formatting option
       */
      toFormattedObject(options2) {
        return {
          type: this.t,
          value: this.toFormattedString(options2),
          isLink: this.isLink,
          href: this.toFormattedHref(options2),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       * Whether this token should be rendered as a link according to the given options
       * @param {Options} options
       * @returns {boolean}
       */
      validate(options2) {
        return options2.get("validate", this.toString(), this);
      },
      /**
       * Return an object that represents how this link should be rendered.
       * @param {Options} options Formattinng options
       */
      render(options2) {
        const token = this;
        const href = this.toHref(options2.get("defaultProtocol"));
        const formattedHref = options2.get("formatHref", href, this);
        const tagName = options2.get("tagName", href, token);
        const content = this.toFormattedString(options2);
        const attributes = {};
        const className = options2.get("className", href, token);
        const target = options2.get("target", href, token);
        const rel = options2.get("rel", href, token);
        const attrs = options2.getObj("attributes", href, token);
        const eventListeners = options2.getObj("events", href, token);
        attributes.href = formattedHref;
        if (className) {
          attributes.class = className;
        }
        if (target) {
          attributes.target = target;
        }
        if (rel) {
          attributes.rel = rel;
        }
        if (attrs) {
          assign(attributes, attrs);
        }
        return {
          tagName,
          attributes,
          content,
          eventListeners
        };
      }
    };
    Email = createTokenClass("email", {
      isLink: true,
      toHref() {
        return "mailto:" + this.toString();
      }
    });
    Text = createTokenClass("text");
    Nl = createTokenClass("nl");
    Url = createTokenClass("url", {
      isLink: true,
      /**
      	Lowercases relevant parts of the domain and adds the protocol if
      	required. Note that this will not escape unsafe HTML characters in the
      	URL.
      		@param {string} [scheme] default scheme (e.g., 'https')
      	@return {string} the full href
      */
      toHref(scheme2) {
        if (scheme2 === void 0) {
          scheme2 = defaults2.defaultProtocol;
        }
        return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
      },
      /**
       * Check whether this URL token has a protocol
       * @return {boolean}
       */
      hasProtocol() {
        const tokens = this.tk;
        return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
      }
    });
    makeState = (arg) => new State(arg);
    warn2 = typeof console !== "undefined" && console && console.warn || (() => {
    });
    warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
    INIT = {
      scanner: null,
      parser: null,
      tokenQueue: [],
      pluginQueue: [],
      customSchemes: [],
      initialized: false
    };
  }
});

// node_modules/.pnpm/@tiptap+extension-link@2.1.10_@tiptap+core@2.1.10_@tiptap+pm@2.1.10/node_modules/@tiptap/extension-link/dist/index.js
function autolink(options2) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr2 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
        } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s2) => s2 !== "");
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          find(lastWordBeforeSpace).filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => {
            if (options2.validate) {
              return options2.validate(link.value);
            }
            return true;
          }).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options2.type)) {
              return;
            }
            tr2.addMark(link.from, link.to, options2.type.create({
              href: link.href
            }));
          });
        }
      });
      if (!tr2.steps.length) {
        return;
      }
      return tr2;
    }
  });
}
function clickHandler(options2) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a178, _b10;
        if (event.button !== 0) {
          return false;
        }
        const eventTarget = event.target;
        if (eventTarget.nodeName !== "A") {
          return false;
        }
        const attrs = getAttributes(view.state, options2.type.name);
        const link = event.target;
        const href = (_a178 = link === null || link === void 0 ? void 0 : link.href) !== null && _a178 !== void 0 ? _a178 : attrs.href;
        const target = (_b10 = link === null || link === void 0 ? void 0 : link.target) !== null && _b10 !== void 0 ? _b10 : attrs.target;
        if (link && href) {
          if (view.editable) {
            window.open(href, target);
          }
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options2) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice2) => {
        var _a178, _b10;
        const { state } = view;
        const { selection } = state;
        if (state.doc.resolve(selection.from).parent.type.spec.code) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        let isAlreadyLink = false;
        slice2.content.descendants((node) => {
          if (node.marks.some((mark) => mark.type.name === options2.type.name)) {
            isAlreadyLink = true;
          }
        });
        if (isAlreadyLink) {
          return;
        }
        const link = find(textContent).find((item) => item.isLink && item.value === textContent);
        if (!selection.empty && options2.linkOnPaste) {
          const pastedLink = (link === null || link === void 0 ? void 0 : link.href) || null;
          if (pastedLink) {
            options2.editor.commands.setMark(options2.type, { href: pastedLink });
            return true;
          }
        }
        const firstChildIsText = ((_a178 = slice2.content.firstChild) === null || _a178 === void 0 ? void 0 : _a178.type.name) === "text";
        const firstChildContainsLinkMark = (_b10 = slice2.content.firstChild) === null || _b10 === void 0 ? void 0 : _b10.marks.some((mark) => mark.type.name === options2.type.name);
        if (firstChildIsText && firstChildContainsLinkMark || !options2.linkOnPaste) {
          return false;
        }
        if (link && selection.empty) {
          options2.editor.commands.insertContent(`<a href="${link.href}">${link.href}</a>`);
          return true;
        }
        const { tr: tr2 } = state;
        let deleteOnly = false;
        if (!selection.empty) {
          deleteOnly = true;
          tr2.delete(selection.from, selection.to);
        }
        let currentPos = selection.from;
        let fragmentLinks = [];
        slice2.content.forEach((node) => {
          fragmentLinks = find(node.textContent);
          tr2.insert(currentPos - 1, node);
          if (fragmentLinks.length > 0) {
            deleteOnly = false;
            fragmentLinks.forEach((fragmentLink) => {
              const linkStart = currentPos + fragmentLink.start;
              const linkEnd = currentPos + fragmentLink.end;
              const hasMark = tr2.doc.rangeHasMark(linkStart, linkEnd, options2.type);
              if (!hasMark) {
                tr2.addMark(linkStart, linkEnd, options2.type.create({ href: fragmentLink.href }));
              }
            });
          }
          currentPos += node.nodeSize;
        });
        const hasFragmentLinks = fragmentLinks.length > 0;
        if (tr2.docChanged && !deleteOnly && hasFragmentLinks) {
          options2.editor.view.dispatch(tr2);
          return true;
        }
        return false;
      }
    }
  });
}
var Link;
var init_dist28 = __esm({
  "node_modules/.pnpm/@tiptap+extension-link@2.1.10_@tiptap+core@2.1.10_@tiptap+pm@2.1.10/node_modules/@tiptap/extension-link/dist/index.js"() {
    init_dist18();
    init_linkify_es();
    init_dist7();
    Link = Mark2.create({
      name: "link",
      priority: 1e3,
      keepOnSplit: false,
      onCreate() {
        this.options.protocols.forEach((protocol2) => {
          if (typeof protocol2 === "string") {
            registerCustomProtocol(protocol2);
            return;
          }
          registerCustomProtocol(protocol2.scheme, protocol2.optionalSlashes);
        });
      },
      onDestroy() {
        reset2();
      },
      inclusive() {
        return this.options.autolink;
      },
      addOptions() {
        return {
          openOnClick: true,
          linkOnPaste: true,
          autolink: true,
          protocols: [],
          HTMLAttributes: {
            target: "_blank",
            rel: "noopener noreferrer nofollow",
            class: null
          },
          validate: void 0
        };
      },
      addAttributes() {
        return {
          href: {
            default: null
          },
          target: {
            default: this.options.HTMLAttributes.target
          },
          rel: {
            default: this.options.HTMLAttributes.rel
          },
          class: {
            default: this.options.HTMLAttributes.class
          }
        };
      },
      parseHTML() {
        return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setLink: (attributes) => ({ chain }) => {
            return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
          },
          toggleLink: (attributes) => ({ chain }) => {
            return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
          },
          unsetLink: () => ({ chain }) => {
            return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
          }
        };
      },
      addProseMirrorPlugins() {
        const plugins = [];
        if (this.options.autolink) {
          plugins.push(autolink({
            type: this.type,
            validate: this.options.validate
          }));
        }
        if (this.options.openOnClick) {
          plugins.push(clickHandler({
            type: this.type
          }));
        }
        plugins.push(pasteHandler({
          editor: this.editor,
          type: this.type,
          linkOnPaste: this.options.linkOnPaste
        }));
        return plugins;
      }
    });
  }
});

// node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/es/languages/css.js
function css2(hljs) {
  const regex = hljs.regex;
  const modes = MODES2(hljs);
  const VENDOR_PREFIX = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ };
  const AT_MODIFIERS = "and or not only";
  const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
  const IDENT_RE4 = "[a-zA-Z-][a-zA-Z0-9_-]*";
  const STRINGS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: true,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      modes.BLOCK_COMMENT,
      VENDOR_PREFIX,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      modes.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + IDENT_RE4,
        relevance: 0
      },
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + PSEUDO_CLASSES.join("|") + ")" },
          { begin: ":(:)?(" + PSEUDO_ELEMENTS.join("|") + ")" }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      modes.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
      },
      // attribute values
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          modes.BLOCK_COMMENT,
          modes.HEXCOLOR,
          modes.IMPORTANT,
          modes.CSS_NUMBER_MODE,
          ...STRINGS,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            // from keywords
            keywords: { built_in: "url data-uri" },
            contains: [
              ...STRINGS,
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: true,
                excludeEnd: true
              }
            ]
          },
          modes.FUNCTION_DISPATCH
        ]
      },
      {
        begin: regex.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        // break on Less variables @var: ...
        contains: [
          {
            className: "keyword",
            begin: AT_PROPERTY_RE
          },
          {
            begin: /\s/,
            endsWithParent: true,
            excludeEnd: true,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: AT_MODIFIERS,
              attribute: MEDIA_FEATURES.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...STRINGS,
              modes.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + TAGS.join("|") + ")\\b"
      }
    ]
  };
}
var MODES2, TAGS, MEDIA_FEATURES, PSEUDO_CLASSES, PSEUDO_ELEMENTS, ATTRIBUTES;
var init_css = __esm({
  "node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/es/languages/css.js"() {
    MODES2 = (hljs) => {
      return {
        IMPORTANT: {
          scope: "meta",
          begin: "!important"
        },
        BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: {
          scope: "number",
          begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
        },
        FUNCTION_DISPATCH: {
          className: "built_in",
          begin: /[\w-]+(?=\()/
        },
        ATTRIBUTE_SELECTOR_MODE: {
          scope: "selector-attr",
          begin: /\[/,
          end: /\]/,
          illegal: "$",
          contains: [
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE
          ]
        },
        CSS_NUMBER_MODE: {
          scope: "number",
          begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
          relevance: 0
        },
        CSS_VARIABLE: {
          className: "attr",
          begin: /--[A-Za-z][A-Za-z0-9_-]*/
        }
      };
    };
    TAGS = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "p",
      "q",
      "quote",
      "samp",
      "section",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ];
    MEDIA_FEATURES = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ];
    PSEUDO_CLASSES = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ];
    PSEUDO_ELEMENTS = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ];
    ATTRIBUTES = [
      "align-content",
      "align-items",
      "align-self",
      "all",
      "animation",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-timing-function",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-repeat",
      "background-size",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-decoration-break",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "direction",
      "display",
      "empty-cells",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-size",
      "font-size-adjust",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-variant",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "gap",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "inline-size",
      "isolation",
      "justify-content",
      "left",
      "letter-spacing",
      "line-break",
      "line-height",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "pointer-events",
      "position",
      "quotes",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "row-gap",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-style",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-transform",
      "text-underline-position",
      "top",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "unicode-bidi",
      "vertical-align",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "z-index"
      // reverse makes sure longer attributes `font-weight` are matched fully
      // instead of getting false positives on say `font`
    ].reverse();
  }
});

// node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/es/languages/javascript.js
function javascript(hljs) {
  const regex = hljs.regex;
  const hasClosingTag = (match, { after }) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };
  const IDENT_RE$1 = IDENT_RE2;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        nextChar === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        nextChar === ","
      ) {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      let m;
      const afterMatch = match.input.substring(afterMatchIndex);
      if (m = afterMatch.match(/^\s*=/)) {
        response.ignoreMatch();
        return;
      }
      if (m = afterMatch.match(/^\s+extends\s+/)) {
        if (m.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  const KEYWORDS$1 = {
    $pattern: IDENT_RE2,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS,
    "variable.language": BUILT_IN_VARIABLES
  };
  const decimalDigits = "[0-9](_?[0-9])*";
  const frac = `\\.(${decimalDigits})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
      // DecimalBigIntegerLiteral
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$1,
    contains: []
    // defined later
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "css"
    }
  };
  const GRAPHQL_TEMPLATE = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "graphql"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    "\\*/",
    {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            // eat spaces (not newlines) so we can find
            // types or variables
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT2 = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    GRAPHQL_TEMPLATE,
    TEMPLATE_STRING,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    NUMBER
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$1,
    contains: [
      "self"
    ].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$1,
          /\s+/,
          /extends/,
          /\s+/,
          regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$1
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: regex.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...TYPES,
        ...ERROR_TYPES
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$1,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list) {
    return regex.concat("(?!", list.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: regex.concat(
      /\b/,
      noneOf([
        ...BUILT_IN_GLOBALS,
        "super",
        "import"
      ]),
      IDENT_RE$1,
      regex.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: regex.concat(/\./, regex.lookahead(
      regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)
    )),
    end: IDENT_RE$1,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$1,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$1,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      regex.lookahead(FUNC_LEAD_IN_RE)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$1,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT2,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$1 + regex.lookahead(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        // "value" container
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT2,
          hljs.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + IDENT_RE$1,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
var IDENT_RE2, KEYWORDS, LITERALS, TYPES, ERROR_TYPES, BUILT_IN_GLOBALS, BUILT_IN_VARIABLES, BUILT_INS;
var init_javascript = __esm({
  "node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/es/languages/javascript.js"() {
    IDENT_RE2 = "[A-Za-z$_][0-9A-Za-z$_]*";
    KEYWORDS = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends"
    ];
    LITERALS = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ];
    TYPES = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ];
    ERROR_TYPES = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ];
    BUILT_IN_GLOBALS = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ];
    BUILT_IN_VARIABLES = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ];
    BUILT_INS = [].concat(
      BUILT_IN_GLOBALS,
      TYPES,
      ERROR_TYPES
    );
  }
});

// node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/es/languages/typescript.js
function javascript2(hljs) {
  const regex = hljs.regex;
  const hasClosingTag = (match, { after }) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };
  const IDENT_RE$1 = IDENT_RE3;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        nextChar === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        nextChar === ","
      ) {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      let m;
      const afterMatch = match.input.substring(afterMatchIndex);
      if (m = afterMatch.match(/^\s*=/)) {
        response.ignoreMatch();
        return;
      }
      if (m = afterMatch.match(/^\s+extends\s+/)) {
        if (m.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  const KEYWORDS$1 = {
    $pattern: IDENT_RE3,
    keyword: KEYWORDS2,
    literal: LITERALS2,
    built_in: BUILT_INS2,
    "variable.language": BUILT_IN_VARIABLES2
  };
  const decimalDigits = "[0-9](_?[0-9])*";
  const frac = `\\.(${decimalDigits})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
      // DecimalBigIntegerLiteral
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$1,
    contains: []
    // defined later
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "css"
    }
  };
  const GRAPHQL_TEMPLATE = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "graphql"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    "\\*/",
    {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            // eat spaces (not newlines) so we can find
            // types or variables
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT2 = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    GRAPHQL_TEMPLATE,
    TEMPLATE_STRING,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    NUMBER
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$1,
    contains: [
      "self"
    ].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$1,
          /\s+/,
          /extends/,
          /\s+/,
          regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$1
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: regex.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...TYPES2,
        ...ERROR_TYPES2
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$1,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list) {
    return regex.concat("(?!", list.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: regex.concat(
      /\b/,
      noneOf([
        ...BUILT_IN_GLOBALS2,
        "super",
        "import"
      ]),
      IDENT_RE$1,
      regex.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: regex.concat(/\./, regex.lookahead(
      regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)
    )),
    end: IDENT_RE$1,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$1,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$1,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      regex.lookahead(FUNC_LEAD_IN_RE)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$1,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT2,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$1 + regex.lookahead(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        // "value" container
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT2,
          hljs.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + IDENT_RE$1,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function typescript(hljs) {
  const tsLanguage = javascript2(hljs);
  const IDENT_RE$1 = IDENT_RE3;
  const TYPES3 = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ];
  const NAMESPACE = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: true,
    contains: [tsLanguage.exports.CLASS_REFERENCE]
  };
  const INTERFACE = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: true,
    keywords: {
      keyword: "interface extends",
      built_in: TYPES3
    },
    contains: [tsLanguage.exports.CLASS_REFERENCE]
  };
  const USE_STRICT = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  };
  const TS_SPECIFIC_KEYWORDS = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ];
  const KEYWORDS$1 = {
    $pattern: IDENT_RE3,
    keyword: KEYWORDS2.concat(TS_SPECIFIC_KEYWORDS),
    literal: LITERALS2,
    built_in: BUILT_INS2.concat(TYPES3),
    "variable.language": BUILT_IN_VARIABLES2
  };
  const DECORATOR = {
    className: "meta",
    begin: "@" + IDENT_RE$1
  };
  const swapMode = (mode, label, replacement2) => {
    const indx = mode.contains.findIndex((m) => m.label === label);
    if (indx === -1) {
      throw new Error("can not find mode to replace");
    }
    mode.contains.splice(indx, 1, replacement2);
  };
  Object.assign(tsLanguage.keywords, KEYWORDS$1);
  tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
  tsLanguage.contains = tsLanguage.contains.concat([
    DECORATOR,
    NAMESPACE,
    INTERFACE
  ]);
  swapMode(tsLanguage, "shebang", hljs.SHEBANG());
  swapMode(tsLanguage, "use_strict", USE_STRICT);
  const functionDeclaration = tsLanguage.contains.find((m) => m.label === "func.def");
  functionDeclaration.relevance = 0;
  Object.assign(tsLanguage, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  });
  return tsLanguage;
}
var IDENT_RE3, KEYWORDS2, LITERALS2, TYPES2, ERROR_TYPES2, BUILT_IN_GLOBALS2, BUILT_IN_VARIABLES2, BUILT_INS2;
var init_typescript = __esm({
  "node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/es/languages/typescript.js"() {
    IDENT_RE3 = "[A-Za-z$_][0-9A-Za-z$_]*";
    KEYWORDS2 = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends"
    ];
    LITERALS2 = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ];
    TYPES2 = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ];
    ERROR_TYPES2 = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ];
    BUILT_IN_GLOBALS2 = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ];
    BUILT_IN_VARIABLES2 = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ];
    BUILT_INS2 = [].concat(
      BUILT_IN_GLOBALS2,
      TYPES2,
      ERROR_TYPES2
    );
  }
});

// node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/es/languages/xml.js
function xml(hljs) {
  const regex = hljs.regex;
  const TAG_NAME_RE = regex.concat(/[\p{L}_]/u, regex.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u);
  const XML_IDENT_RE = /[\p{L}0-9._:-]+/u;
  const XML_ENTITIES = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  };
  const XML_META_KEYWORDS = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  };
  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
    begin: /\(/,
    end: /\)/
  });
  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: "string" });
  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" });
  const TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: true,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [XML_ENTITIES]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [XML_ENTITIES]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: true,
    unicodeRegex: true,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          XML_META_KEYWORDS,
          QUOTE_META_STRING_MODE,
          APOS_META_STRING_MODE,
          XML_META_PAR_KEYWORDS,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  XML_META_KEYWORDS,
                  XML_META_PAR_KEYWORDS,
                  QUOTE_META_STRING_MODE,
                  APOS_META_STRING_MODE
                ]
              }
            ]
          }
        ]
      },
      hljs.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      XML_ENTITIES,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              QUOTE_META_STRING_MODE
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/style>/,
          returnEnd: true,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/script>/,
          returnEnd: true,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: regex.concat(
          /</,
          regex.lookahead(regex.concat(
            TAG_NAME_RE,
            // <tag/>
            // <tag>
            // <tag ...
            regex.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0,
            starts: TAG_INTERNALS
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: regex.concat(
          /<\//,
          regex.lookahead(regex.concat(
            TAG_NAME_RE,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: true
          }
        ]
      }
    ]
  };
}
var init_xml = __esm({
  "node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/es/languages/xml.js"() {
  }
});

// node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/default.js
function ok() {
}
var init_default = __esm({
  "node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/default.js"() {
  }
});

// node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/lib/core.js
var require_core = __commonJS({
  "node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/lib/core.js"(exports, module) {
    function deepFreeze2(obj) {
      if (obj instanceof Map) {
        obj.clear = obj.delete = obj.set = function() {
          throw new Error("map is read-only");
        };
      } else if (obj instanceof Set) {
        obj.add = obj.clear = obj.delete = function() {
          throw new Error("set is read-only");
        };
      }
      Object.freeze(obj);
      Object.getOwnPropertyNames(obj).forEach((name3) => {
        const prop = obj[name3];
        const type = typeof prop;
        if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
          deepFreeze2(prop);
        }
      });
      return obj;
    }
    var Response3 = class {
      /**
       * @param {CompiledMode} mode
       */
      constructor(mode) {
        if (mode.data === void 0)
          mode.data = {};
        this.data = mode.data;
        this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    };
    function escapeHTML2(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function inherit$12(original, ...objects) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key3 in original) {
        result[key3] = original[key3];
      }
      objects.forEach(function(obj) {
        for (const key3 in obj) {
          result[key3] = obj[key3];
        }
      });
      return (
        /** @type {T} */
        result
      );
    }
    var SPAN_CLOSE2 = "</span>";
    var emitsWrappingTags2 = (node) => {
      return !!node.scope;
    };
    var scopeToCSSClass2 = (name3, { prefix }) => {
      if (name3.startsWith("language:")) {
        return name3.replace("language:", "language-");
      }
      if (name3.includes(".")) {
        const pieces = name3.split(".");
        return [
          `${prefix}${pieces.shift()}`,
          ...pieces.map((x2, i2) => `${x2}${"_".repeat(i2 + 1)}`)
        ].join(" ");
      }
      return `${prefix}${name3}`;
    };
    var HTMLRenderer2 = class {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(parseTree, options2) {
        this.buffer = "";
        this.classPrefix = options2.classPrefix;
        parseTree.walk(this);
      }
      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(text3) {
        this.buffer += escapeHTML2(text3);
      }
      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(node) {
        if (!emitsWrappingTags2(node))
          return;
        const className = scopeToCSSClass2(
          node.scope,
          { prefix: this.classPrefix }
        );
        this.span(className);
      }
      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(node) {
        if (!emitsWrappingTags2(node))
          return;
        this.buffer += SPAN_CLOSE2;
      }
      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }
      // helpers
      /**
       * Builds a span element
       *
       * @param {string} className */
      span(className) {
        this.buffer += `<span class="${className}">`;
      }
    };
    var newNode2 = (opts = {}) => {
      const result = { children: [] };
      Object.assign(result, opts);
      return result;
    };
    var TokenTree2 = class _TokenTree {
      constructor() {
        this.rootNode = newNode2();
        this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      /** @param {Node} node */
      add(node) {
        this.top.children.push(node);
      }
      /** @param {string} scope */
      openNode(scope) {
        const node = newNode2({ scope });
        this.add(node);
        this.stack.push(node);
      }
      closeNode() {
        if (this.stack.length > 1) {
          return this.stack.pop();
        }
        return void 0;
      }
      closeAllNodes() {
        while (this.closeNode())
          ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(builder2) {
        return this.constructor._walk(builder2, this.rootNode);
      }
      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(builder2, node) {
        if (typeof node === "string") {
          builder2.addText(node);
        } else if (node.children) {
          builder2.openNode(node);
          node.children.forEach((child) => this._walk(builder2, child));
          builder2.closeNode(node);
        }
        return builder2;
      }
      /**
       * @param {Node} node
       */
      static _collapse(node) {
        if (typeof node === "string")
          return;
        if (!node.children)
          return;
        if (node.children.every((el) => typeof el === "string")) {
          node.children = [node.children.join("")];
        } else {
          node.children.forEach((child) => {
            _TokenTree._collapse(child);
          });
        }
      }
    };
    var TokenTreeEmitter2 = class extends TokenTree2 {
      /**
       * @param {*} options
       */
      constructor(options2) {
        super();
        this.options = options2;
      }
      /**
       * @param {string} text
       */
      addText(text3) {
        if (text3 === "") {
          return;
        }
        this.add(text3);
      }
      /** @param {string} scope */
      startScope(scope) {
        this.openNode(scope);
      }
      endScope() {
        this.closeNode();
      }
      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      __addSublanguage(emitter, name3) {
        const node = emitter.root;
        if (name3)
          node.scope = `language:${name3}`;
        this.add(node);
      }
      toHTML() {
        const renderer = new HTMLRenderer2(this, this.options);
        return renderer.value();
      }
      finalize() {
        this.closeAllNodes();
        return true;
      }
    };
    function source2(re3) {
      if (!re3)
        return null;
      if (typeof re3 === "string")
        return re3;
      return re3.source;
    }
    function lookahead2(re3) {
      return concat2("(?=", re3, ")");
    }
    function anyNumberOfTimes2(re3) {
      return concat2("(?:", re3, ")*");
    }
    function optional2(re3) {
      return concat2("(?:", re3, ")?");
    }
    function concat2(...args) {
      const joined = args.map((x2) => source2(x2)).join("");
      return joined;
    }
    function stripOptionsFromArgs2(args) {
      const opts = args[args.length - 1];
      if (typeof opts === "object" && opts.constructor === Object) {
        args.splice(args.length - 1, 1);
        return opts;
      } else {
        return {};
      }
    }
    function either2(...args) {
      const opts = stripOptionsFromArgs2(args);
      const joined = "(" + (opts.capture ? "" : "?:") + args.map((x2) => source2(x2)).join("|") + ")";
      return joined;
    }
    function countMatchGroups2(re3) {
      return new RegExp(re3.toString() + "|").exec("").length - 1;
    }
    function startsWith2(re3, lexeme) {
      const match = re3 && re3.exec(lexeme);
      return match && match.index === 0;
    }
    var BACKREF_RE2 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function _rewriteBackreferences2(regexps, { joinWith }) {
      let numCaptures = 0;
      return regexps.map((regex) => {
        numCaptures += 1;
        const offset2 = numCaptures;
        let re3 = source2(regex);
        let out = "";
        while (re3.length > 0) {
          const match = BACKREF_RE2.exec(re3);
          if (!match) {
            out += re3;
            break;
          }
          out += re3.substring(0, match.index);
          re3 = re3.substring(match.index + match[0].length);
          if (match[0][0] === "\\" && match[1]) {
            out += "\\" + String(Number(match[1]) + offset2);
          } else {
            out += match[0];
            if (match[0] === "(") {
              numCaptures++;
            }
          }
        }
        return out;
      }).map((re3) => `(${re3})`).join(joinWith);
    }
    var MATCH_NOTHING_RE2 = /\b\B/;
    var IDENT_RE4 = "[a-zA-Z]\\w*";
    var UNDERSCORE_IDENT_RE2 = "[a-zA-Z_]\\w*";
    var NUMBER_RE2 = "\\b\\d+(\\.\\d+)?";
    var C_NUMBER_RE2 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
    var BINARY_NUMBER_RE2 = "\\b(0b[01]+)";
    var RE_STARTERS_RE2 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
    var SHEBANG2 = (opts = {}) => {
      const beginShebang = /^#![ ]*\//;
      if (opts.binary) {
        opts.begin = concat2(
          beginShebang,
          /.*\b/,
          opts.binary,
          /\b.*/
        );
      }
      return inherit$12({
        scope: "meta",
        begin: beginShebang,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (m, resp) => {
          if (m.index !== 0)
            resp.ignoreMatch();
        }
      }, opts);
    };
    var BACKSLASH_ESCAPE2 = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    };
    var APOS_STRING_MODE2 = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE2]
    };
    var QUOTE_STRING_MODE2 = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE2]
    };
    var PHRASAL_WORDS_MODE2 = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    var COMMENT2 = function(begin, end, modeOptions = {}) {
      const mode = inherit$12(
        {
          scope: "comment",
          begin,
          end,
          contains: []
        },
        modeOptions
      );
      mode.contains.push({
        scope: "doctag",
        // hack to avoid the space from being included. the space is necessary to
        // match here to prevent the plain text rule below from gobbling up doctags
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const ENGLISH_WORD = either2(
        // list of common 1 and 2 letter words in English
        "I",
        "a",
        "is",
        "so",
        "us",
        "to",
        "at",
        "if",
        "in",
        "it",
        "on",
        // note: this is not an exhaustive list of contractions, just popular ones
        /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
        // contractions - can't we'd they're let's, etc
        /[A-Za-z]+[-][a-z]+/,
        // `no-way`, etc.
        /[A-Za-z][a-z]{2,}/
        // allow capitalized words at beginning of sentences
      );
      mode.contains.push(
        {
          // TODO: how to include ", (, ) without breaking grammars that use these for
          // comment delimiters?
          // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
          // ---
          // this tries to find sequences of 3 english words in a row (without any
          // "programming" type syntax) this gives us a strong signal that we've
          // TRULY found a comment - vs perhaps scanning with the wrong language.
          // It's possible to find something that LOOKS like the start of the
          // comment - but then if there is no readable text - good chance it is a
          // false match and not a comment.
          //
          // for a visual example please see:
          // https://github.com/highlightjs/highlight.js/issues/2827
          begin: concat2(
            /[ ]+/,
            // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
            "(",
            ENGLISH_WORD,
            /[.]?[:]?([.][ ]|[ ])/,
            "){3}"
          )
          // look for 3 words in a row
        }
      );
      return mode;
    };
    var C_LINE_COMMENT_MODE2 = COMMENT2("//", "$");
    var C_BLOCK_COMMENT_MODE2 = COMMENT2("/\\*", "\\*/");
    var HASH_COMMENT_MODE2 = COMMENT2("#", "$");
    var NUMBER_MODE2 = {
      scope: "number",
      begin: NUMBER_RE2,
      relevance: 0
    };
    var C_NUMBER_MODE2 = {
      scope: "number",
      begin: C_NUMBER_RE2,
      relevance: 0
    };
    var BINARY_NUMBER_MODE2 = {
      scope: "number",
      begin: BINARY_NUMBER_RE2,
      relevance: 0
    };
    var REGEXP_MODE2 = {
      // this outer rule makes sure we actually have a WHOLE regex and not simply
      // an expression such as:
      //
      //     3 / something
      //
      // (which will then blow up when regex's `illegal` sees the newline)
      begin: /(?=\/[^/\n]*\/)/,
      contains: [{
        scope: "regexp",
        begin: /\//,
        end: /\/[gimuy]*/,
        illegal: /\n/,
        contains: [
          BACKSLASH_ESCAPE2,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [BACKSLASH_ESCAPE2]
          }
        ]
      }]
    };
    var TITLE_MODE2 = {
      scope: "title",
      begin: IDENT_RE4,
      relevance: 0
    };
    var UNDERSCORE_TITLE_MODE2 = {
      scope: "title",
      begin: UNDERSCORE_IDENT_RE2,
      relevance: 0
    };
    var METHOD_GUARD2 = {
      // excludes method names from keyword processing
      begin: "\\.\\s*" + UNDERSCORE_IDENT_RE2,
      relevance: 0
    };
    var END_SAME_AS_BEGIN2 = function(mode) {
      return Object.assign(
        mode,
        {
          /** @type {ModeCallback} */
          "on:begin": (m, resp) => {
            resp.data._beginMatch = m[1];
          },
          /** @type {ModeCallback} */
          "on:end": (m, resp) => {
            if (resp.data._beginMatch !== m[1])
              resp.ignoreMatch();
          }
        }
      );
    };
    var MODES3 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      MATCH_NOTHING_RE: MATCH_NOTHING_RE2,
      IDENT_RE: IDENT_RE4,
      UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE2,
      NUMBER_RE: NUMBER_RE2,
      C_NUMBER_RE: C_NUMBER_RE2,
      BINARY_NUMBER_RE: BINARY_NUMBER_RE2,
      RE_STARTERS_RE: RE_STARTERS_RE2,
      SHEBANG: SHEBANG2,
      BACKSLASH_ESCAPE: BACKSLASH_ESCAPE2,
      APOS_STRING_MODE: APOS_STRING_MODE2,
      QUOTE_STRING_MODE: QUOTE_STRING_MODE2,
      PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE2,
      COMMENT: COMMENT2,
      C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE2,
      C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE2,
      HASH_COMMENT_MODE: HASH_COMMENT_MODE2,
      NUMBER_MODE: NUMBER_MODE2,
      C_NUMBER_MODE: C_NUMBER_MODE2,
      BINARY_NUMBER_MODE: BINARY_NUMBER_MODE2,
      REGEXP_MODE: REGEXP_MODE2,
      TITLE_MODE: TITLE_MODE2,
      UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE2,
      METHOD_GUARD: METHOD_GUARD2,
      END_SAME_AS_BEGIN: END_SAME_AS_BEGIN2
    });
    function skipIfHasPrecedingDot2(match, response) {
      const before = match.input[match.index - 1];
      if (before === ".") {
        response.ignoreMatch();
      }
    }
    function scopeClassName2(mode, _parent) {
      if (mode.className !== void 0) {
        mode.scope = mode.className;
        delete mode.className;
      }
    }
    function beginKeywords2(mode, parent) {
      if (!parent)
        return;
      if (!mode.beginKeywords)
        return;
      mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
      mode.__beforeBegin = skipIfHasPrecedingDot2;
      mode.keywords = mode.keywords || mode.beginKeywords;
      delete mode.beginKeywords;
      if (mode.relevance === void 0)
        mode.relevance = 0;
    }
    function compileIllegal2(mode, _parent) {
      if (!Array.isArray(mode.illegal))
        return;
      mode.illegal = either2(...mode.illegal);
    }
    function compileMatch2(mode, _parent) {
      if (!mode.match)
        return;
      if (mode.begin || mode.end)
        throw new Error("begin & end are not supported with match");
      mode.begin = mode.match;
      delete mode.match;
    }
    function compileRelevance2(mode, _parent) {
      if (mode.relevance === void 0)
        mode.relevance = 1;
    }
    var beforeMatchExt2 = (mode, parent) => {
      if (!mode.beforeMatch)
        return;
      if (mode.starts)
        throw new Error("beforeMatch cannot be used with starts");
      const originalMode = Object.assign({}, mode);
      Object.keys(mode).forEach((key3) => {
        delete mode[key3];
      });
      mode.keywords = originalMode.keywords;
      mode.begin = concat2(originalMode.beforeMatch, lookahead2(originalMode.begin));
      mode.starts = {
        relevance: 0,
        contains: [
          Object.assign(originalMode, { endsParent: true })
        ]
      };
      mode.relevance = 0;
      delete originalMode.beforeMatch;
    };
    var COMMON_KEYWORDS2 = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      // common variable name
      "list",
      // common variable name
      "value"
      // common variable name
    ];
    var DEFAULT_KEYWORD_SCOPE2 = "keyword";
    function compileKeywords2(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE2) {
      const compiledKeywords = /* @__PURE__ */ Object.create(null);
      if (typeof rawKeywords === "string") {
        compileList(scopeName, rawKeywords.split(" "));
      } else if (Array.isArray(rawKeywords)) {
        compileList(scopeName, rawKeywords);
      } else {
        Object.keys(rawKeywords).forEach(function(scopeName2) {
          Object.assign(
            compiledKeywords,
            compileKeywords2(rawKeywords[scopeName2], caseInsensitive, scopeName2)
          );
        });
      }
      return compiledKeywords;
      function compileList(scopeName2, keywordList) {
        if (caseInsensitive) {
          keywordList = keywordList.map((x2) => x2.toLowerCase());
        }
        keywordList.forEach(function(keyword) {
          const pair = keyword.split("|");
          compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword2(pair[0], pair[1])];
        });
      }
    }
    function scoreForKeyword2(keyword, providedScore) {
      if (providedScore) {
        return Number(providedScore);
      }
      return commonKeyword2(keyword) ? 0 : 1;
    }
    function commonKeyword2(keyword) {
      return COMMON_KEYWORDS2.includes(keyword.toLowerCase());
    }
    var seenDeprecations2 = {};
    var error3 = (message) => {
      console.error(message);
    };
    var warn3 = (message, ...args) => {
      console.log(`WARN: ${message}`, ...args);
    };
    var deprecated2 = (version3, message) => {
      if (seenDeprecations2[`${version3}/${message}`])
        return;
      console.log(`Deprecated as of ${version3}. ${message}`);
      seenDeprecations2[`${version3}/${message}`] = true;
    };
    var MultiClassError2 = new Error();
    function remapScopeNames2(mode, regexes, { key: key3 }) {
      let offset2 = 0;
      const scopeNames = mode[key3];
      const emit = {};
      const positions = {};
      for (let i2 = 1; i2 <= regexes.length; i2++) {
        positions[i2 + offset2] = scopeNames[i2];
        emit[i2 + offset2] = true;
        offset2 += countMatchGroups2(regexes[i2 - 1]);
      }
      mode[key3] = positions;
      mode[key3]._emit = emit;
      mode[key3]._multi = true;
    }
    function beginMultiClass2(mode) {
      if (!Array.isArray(mode.begin))
        return;
      if (mode.skip || mode.excludeBegin || mode.returnBegin) {
        error3("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
        throw MultiClassError2;
      }
      if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
        error3("beginScope must be object");
        throw MultiClassError2;
      }
      remapScopeNames2(mode, mode.begin, { key: "beginScope" });
      mode.begin = _rewriteBackreferences2(mode.begin, { joinWith: "" });
    }
    function endMultiClass2(mode) {
      if (!Array.isArray(mode.end))
        return;
      if (mode.skip || mode.excludeEnd || mode.returnEnd) {
        error3("skip, excludeEnd, returnEnd not compatible with endScope: {}");
        throw MultiClassError2;
      }
      if (typeof mode.endScope !== "object" || mode.endScope === null) {
        error3("endScope must be object");
        throw MultiClassError2;
      }
      remapScopeNames2(mode, mode.end, { key: "endScope" });
      mode.end = _rewriteBackreferences2(mode.end, { joinWith: "" });
    }
    function scopeSugar2(mode) {
      if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
        mode.beginScope = mode.scope;
        delete mode.scope;
      }
    }
    function MultiClass2(mode) {
      scopeSugar2(mode);
      if (typeof mode.beginScope === "string") {
        mode.beginScope = { _wrap: mode.beginScope };
      }
      if (typeof mode.endScope === "string") {
        mode.endScope = { _wrap: mode.endScope };
      }
      beginMultiClass2(mode);
      endMultiClass2(mode);
    }
    function compileLanguage2(language) {
      function langRe(value, global2) {
        return new RegExp(
          source2(value),
          "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
        );
      }
      class MultiRegex {
        constructor() {
          this.matchIndexes = {};
          this.regexes = [];
          this.matchAt = 1;
          this.position = 0;
        }
        // @ts-ignore
        addRule(re3, opts) {
          opts.position = this.position++;
          this.matchIndexes[this.matchAt] = opts;
          this.regexes.push([opts, re3]);
          this.matchAt += countMatchGroups2(re3) + 1;
        }
        compile() {
          if (this.regexes.length === 0) {
            this.exec = () => null;
          }
          const terminators = this.regexes.map((el) => el[1]);
          this.matcherRe = langRe(_rewriteBackreferences2(terminators, { joinWith: "|" }), true);
          this.lastIndex = 0;
        }
        /** @param {string} s */
        exec(s2) {
          this.matcherRe.lastIndex = this.lastIndex;
          const match = this.matcherRe.exec(s2);
          if (!match) {
            return null;
          }
          const i2 = match.findIndex((el, i3) => i3 > 0 && el !== void 0);
          const matchData = this.matchIndexes[i2];
          match.splice(0, i2);
          return Object.assign(match, matchData);
        }
      }
      class ResumableMultiRegex {
        constructor() {
          this.rules = [];
          this.multiRegexes = [];
          this.count = 0;
          this.lastIndex = 0;
          this.regexIndex = 0;
        }
        // @ts-ignore
        getMatcher(index8) {
          if (this.multiRegexes[index8])
            return this.multiRegexes[index8];
          const matcher = new MultiRegex();
          this.rules.slice(index8).forEach(([re3, opts]) => matcher.addRule(re3, opts));
          matcher.compile();
          this.multiRegexes[index8] = matcher;
          return matcher;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        // @ts-ignore
        addRule(re3, opts) {
          this.rules.push([re3, opts]);
          if (opts.type === "begin")
            this.count++;
        }
        /** @param {string} s */
        exec(s2) {
          const m = this.getMatcher(this.regexIndex);
          m.lastIndex = this.lastIndex;
          let result = m.exec(s2);
          if (this.resumingScanAtSamePosition()) {
            if (result && result.index === this.lastIndex)
              ;
            else {
              const m2 = this.getMatcher(0);
              m2.lastIndex = this.lastIndex + 1;
              result = m2.exec(s2);
            }
          }
          if (result) {
            this.regexIndex += result.position + 1;
            if (this.regexIndex === this.count) {
              this.considerAll();
            }
          }
          return result;
        }
      }
      function buildModeRegex(mode) {
        const mm = new ResumableMultiRegex();
        mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
        if (mode.terminatorEnd) {
          mm.addRule(mode.terminatorEnd, { type: "end" });
        }
        if (mode.illegal) {
          mm.addRule(mode.illegal, { type: "illegal" });
        }
        return mm;
      }
      function compileMode(mode, parent) {
        const cmode = (
          /** @type CompiledMode */
          mode
        );
        if (mode.isCompiled)
          return cmode;
        [
          scopeClassName2,
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          compileMatch2,
          MultiClass2,
          beforeMatchExt2
        ].forEach((ext) => ext(mode, parent));
        language.compilerExtensions.forEach((ext) => ext(mode, parent));
        mode.__beforeBegin = null;
        [
          beginKeywords2,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          compileIllegal2,
          // default to 1 relevance if not specified
          compileRelevance2
        ].forEach((ext) => ext(mode, parent));
        mode.isCompiled = true;
        let keywordPattern = null;
        if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
          mode.keywords = Object.assign({}, mode.keywords);
          keywordPattern = mode.keywords.$pattern;
          delete mode.keywords.$pattern;
        }
        keywordPattern = keywordPattern || /\w+/;
        if (mode.keywords) {
          mode.keywords = compileKeywords2(mode.keywords, language.case_insensitive);
        }
        cmode.keywordPatternRe = langRe(keywordPattern, true);
        if (parent) {
          if (!mode.begin)
            mode.begin = /\B|\b/;
          cmode.beginRe = langRe(cmode.begin);
          if (!mode.end && !mode.endsWithParent)
            mode.end = /\B|\b/;
          if (mode.end)
            cmode.endRe = langRe(cmode.end);
          cmode.terminatorEnd = source2(cmode.end) || "";
          if (mode.endsWithParent && parent.terminatorEnd) {
            cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
          }
        }
        if (mode.illegal)
          cmode.illegalRe = langRe(
            /** @type {RegExp | string} */
            mode.illegal
          );
        if (!mode.contains)
          mode.contains = [];
        mode.contains = [].concat(...mode.contains.map(function(c) {
          return expandOrCloneMode2(c === "self" ? mode : c);
        }));
        mode.contains.forEach(function(c) {
          compileMode(
            /** @type Mode */
            c,
            cmode
          );
        });
        if (mode.starts) {
          compileMode(mode.starts, parent);
        }
        cmode.matcher = buildModeRegex(cmode);
        return cmode;
      }
      if (!language.compilerExtensions)
        language.compilerExtensions = [];
      if (language.contains && language.contains.includes("self")) {
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      }
      language.classNameAliases = inherit$12(language.classNameAliases || {});
      return compileMode(
        /** @type Mode */
        language
      );
    }
    function dependencyOnParent2(mode) {
      if (!mode)
        return false;
      return mode.endsWithParent || dependencyOnParent2(mode.starts);
    }
    function expandOrCloneMode2(mode) {
      if (mode.variants && !mode.cachedVariants) {
        mode.cachedVariants = mode.variants.map(function(variant) {
          return inherit$12(mode, { variants: null }, variant);
        });
      }
      if (mode.cachedVariants) {
        return mode.cachedVariants;
      }
      if (dependencyOnParent2(mode)) {
        return inherit$12(mode, { starts: mode.starts ? inherit$12(mode.starts) : null });
      }
      if (Object.isFrozen(mode)) {
        return inherit$12(mode);
      }
      return mode;
    }
    var version2 = "11.8.0";
    var HTMLInjectionError2 = class extends Error {
      constructor(reason, html) {
        super(reason);
        this.name = "HTMLInjectionError";
        this.html = html;
      }
    };
    var escape4 = escapeHTML2;
    var inherit2 = inherit$12;
    var NO_MATCH2 = Symbol("nomatch");
    var MAX_KEYWORD_HITS2 = 7;
    var HLJS2 = function(hljs) {
      const languages = /* @__PURE__ */ Object.create(null);
      const aliases = /* @__PURE__ */ Object.create(null);
      const plugins = [];
      let SAFE_MODE = true;
      const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
      let options2 = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: TokenTreeEmitter2
      };
      function shouldNotHighlight(languageName) {
        return options2.noHighlightRe.test(languageName);
      }
      function blockLanguage(block) {
        let classes = block.className + " ";
        classes += block.parentNode ? block.parentNode.className : "";
        const match = options2.languageDetectRe.exec(classes);
        if (match) {
          const language = getLanguage(match[1]);
          if (!language) {
            warn3(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
            warn3("Falling back to no-highlight mode for this block.", block);
          }
          return language ? match[1] : "no-highlight";
        }
        return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
      }
      function highlight3(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
        let code = "";
        let languageName = "";
        if (typeof optionsOrCode === "object") {
          code = codeOrLanguageName;
          ignoreIllegals = optionsOrCode.ignoreIllegals;
          languageName = optionsOrCode.language;
        } else {
          deprecated2("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
          deprecated2("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
          languageName = codeOrLanguageName;
          code = optionsOrCode;
        }
        if (ignoreIllegals === void 0) {
          ignoreIllegals = true;
        }
        const context = {
          code,
          language: languageName
        };
        fire("before:highlight", context);
        const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
        result.code = context.code;
        fire("after:highlight", result);
        return result;
      }
      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
        const keywordHits = /* @__PURE__ */ Object.create(null);
        function keywordData(mode, matchText) {
          return mode.keywords[matchText];
        }
        function processKeywords() {
          if (!top.keywords) {
            emitter.addText(modeBuffer);
            return;
          }
          let lastIndex = 0;
          top.keywordPatternRe.lastIndex = 0;
          let match = top.keywordPatternRe.exec(modeBuffer);
          let buf = "";
          while (match) {
            buf += modeBuffer.substring(lastIndex, match.index);
            const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
            const data = keywordData(top, word);
            if (data) {
              const [kind, keywordRelevance] = data;
              emitter.addText(buf);
              buf = "";
              keywordHits[word] = (keywordHits[word] || 0) + 1;
              if (keywordHits[word] <= MAX_KEYWORD_HITS2)
                relevance += keywordRelevance;
              if (kind.startsWith("_")) {
                buf += match[0];
              } else {
                const cssClass = language.classNameAliases[kind] || kind;
                emitKeyword(match[0], cssClass);
              }
            } else {
              buf += match[0];
            }
            lastIndex = top.keywordPatternRe.lastIndex;
            match = top.keywordPatternRe.exec(modeBuffer);
          }
          buf += modeBuffer.substring(lastIndex);
          emitter.addText(buf);
        }
        function processSubLanguage() {
          if (modeBuffer === "")
            return;
          let result2 = null;
          if (typeof top.subLanguage === "string") {
            if (!languages[top.subLanguage]) {
              emitter.addText(modeBuffer);
              return;
            }
            result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
            continuations[top.subLanguage] = /** @type {CompiledMode} */
            result2._top;
          } else {
            result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
          }
          if (top.relevance > 0) {
            relevance += result2.relevance;
          }
          emitter.__addSublanguage(result2._emitter, result2.language);
        }
        function processBuffer() {
          if (top.subLanguage != null) {
            processSubLanguage();
          } else {
            processKeywords();
          }
          modeBuffer = "";
        }
        function emitKeyword(keyword, scope) {
          if (keyword === "")
            return;
          emitter.startScope(scope);
          emitter.addText(keyword);
          emitter.endScope();
        }
        function emitMultiClass(scope, match) {
          let i2 = 1;
          const max2 = match.length - 1;
          while (i2 <= max2) {
            if (!scope._emit[i2]) {
              i2++;
              continue;
            }
            const klass = language.classNameAliases[scope[i2]] || scope[i2];
            const text3 = match[i2];
            if (klass) {
              emitKeyword(text3, klass);
            } else {
              modeBuffer = text3;
              processKeywords();
              modeBuffer = "";
            }
            i2++;
          }
        }
        function startNewMode(mode, match) {
          if (mode.scope && typeof mode.scope === "string") {
            emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
          }
          if (mode.beginScope) {
            if (mode.beginScope._wrap) {
              emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
              modeBuffer = "";
            } else if (mode.beginScope._multi) {
              emitMultiClass(mode.beginScope, match);
              modeBuffer = "";
            }
          }
          top = Object.create(mode, { parent: { value: top } });
          return top;
        }
        function endOfMode(mode, match, matchPlusRemainder) {
          let matched = startsWith2(mode.endRe, matchPlusRemainder);
          if (matched) {
            if (mode["on:end"]) {
              const resp = new Response3(mode);
              mode["on:end"](match, resp);
              if (resp.isMatchIgnored)
                matched = false;
            }
            if (matched) {
              while (mode.endsParent && mode.parent) {
                mode = mode.parent;
              }
              return mode;
            }
          }
          if (mode.endsWithParent) {
            return endOfMode(mode.parent, match, matchPlusRemainder);
          }
        }
        function doIgnore(lexeme) {
          if (top.matcher.regexIndex === 0) {
            modeBuffer += lexeme[0];
            return 1;
          } else {
            resumeScanAtSamePosition = true;
            return 0;
          }
        }
        function doBeginMatch(match) {
          const lexeme = match[0];
          const newMode = match.rule;
          const resp = new Response3(newMode);
          const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
          for (const cb of beforeCallbacks) {
            if (!cb)
              continue;
            cb(match, resp);
            if (resp.isMatchIgnored)
              return doIgnore(lexeme);
          }
          if (newMode.skip) {
            modeBuffer += lexeme;
          } else {
            if (newMode.excludeBegin) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (!newMode.returnBegin && !newMode.excludeBegin) {
              modeBuffer = lexeme;
            }
          }
          startNewMode(newMode, match);
          return newMode.returnBegin ? 0 : lexeme.length;
        }
        function doEndMatch(match) {
          const lexeme = match[0];
          const matchPlusRemainder = codeToHighlight.substring(match.index);
          const endMode = endOfMode(top, match, matchPlusRemainder);
          if (!endMode) {
            return NO_MATCH2;
          }
          const origin = top;
          if (top.endScope && top.endScope._wrap) {
            processBuffer();
            emitKeyword(lexeme, top.endScope._wrap);
          } else if (top.endScope && top.endScope._multi) {
            processBuffer();
            emitMultiClass(top.endScope, match);
          } else if (origin.skip) {
            modeBuffer += lexeme;
          } else {
            if (!(origin.returnEnd || origin.excludeEnd)) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (origin.excludeEnd) {
              modeBuffer = lexeme;
            }
          }
          do {
            if (top.scope) {
              emitter.closeNode();
            }
            if (!top.skip && !top.subLanguage) {
              relevance += top.relevance;
            }
            top = top.parent;
          } while (top !== endMode.parent);
          if (endMode.starts) {
            startNewMode(endMode.starts, match);
          }
          return origin.returnEnd ? 0 : lexeme.length;
        }
        function processContinuations() {
          const list = [];
          for (let current = top; current !== language; current = current.parent) {
            if (current.scope) {
              list.unshift(current.scope);
            }
          }
          list.forEach((item) => emitter.openNode(item));
        }
        let lastMatch = {};
        function processLexeme(textBeforeMatch, match) {
          const lexeme = match && match[0];
          modeBuffer += textBeforeMatch;
          if (lexeme == null) {
            processBuffer();
            return 0;
          }
          if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
            if (!SAFE_MODE) {
              const err = new Error(`0 width match regex (${languageName})`);
              err.languageName = languageName;
              err.badRule = lastMatch.rule;
              throw err;
            }
            return 1;
          }
          lastMatch = match;
          if (match.type === "begin") {
            return doBeginMatch(match);
          } else if (match.type === "illegal" && !ignoreIllegals) {
            const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
            err.mode = top;
            throw err;
          } else if (match.type === "end") {
            const processed = doEndMatch(match);
            if (processed !== NO_MATCH2) {
              return processed;
            }
          }
          if (match.type === "illegal" && lexeme === "") {
            return 1;
          }
          if (iterations > 1e5 && iterations > match.index * 3) {
            const err = new Error("potential infinite loop, way more iterations than matches");
            throw err;
          }
          modeBuffer += lexeme;
          return lexeme.length;
        }
        const language = getLanguage(languageName);
        if (!language) {
          error3(LANGUAGE_NOT_FOUND.replace("{}", languageName));
          throw new Error('Unknown language: "' + languageName + '"');
        }
        const md = compileLanguage2(language);
        let result = "";
        let top = continuation || md;
        const continuations = {};
        const emitter = new options2.__emitter(options2);
        processContinuations();
        let modeBuffer = "";
        let relevance = 0;
        let index8 = 0;
        let iterations = 0;
        let resumeScanAtSamePosition = false;
        try {
          if (!language.__emitTokens) {
            top.matcher.considerAll();
            for (; ; ) {
              iterations++;
              if (resumeScanAtSamePosition) {
                resumeScanAtSamePosition = false;
              } else {
                top.matcher.considerAll();
              }
              top.matcher.lastIndex = index8;
              const match = top.matcher.exec(codeToHighlight);
              if (!match)
                break;
              const beforeMatch = codeToHighlight.substring(index8, match.index);
              const processedCount = processLexeme(beforeMatch, match);
              index8 = match.index + processedCount;
            }
            processLexeme(codeToHighlight.substring(index8));
          } else {
            language.__emitTokens(codeToHighlight, emitter);
          }
          emitter.finalize();
          result = emitter.toHTML();
          return {
            language: languageName,
            value: result,
            relevance,
            illegal: false,
            _emitter: emitter,
            _top: top
          };
        } catch (err) {
          if (err.message && err.message.includes("Illegal")) {
            return {
              language: languageName,
              value: escape4(codeToHighlight),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: err.message,
                index: index8,
                context: codeToHighlight.slice(index8 - 100, index8 + 100),
                mode: err.mode,
                resultSoFar: result
              },
              _emitter: emitter
            };
          } else if (SAFE_MODE) {
            return {
              language: languageName,
              value: escape4(codeToHighlight),
              illegal: false,
              relevance: 0,
              errorRaised: err,
              _emitter: emitter,
              _top: top
            };
          } else {
            throw err;
          }
        }
      }
      function justTextHighlightResult(code) {
        const result = {
          value: escape4(code),
          illegal: false,
          relevance: 0,
          _top: PLAINTEXT_LANGUAGE,
          _emitter: new options2.__emitter(options2)
        };
        result._emitter.addText(code);
        return result;
      }
      function highlightAuto(code, languageSubset) {
        languageSubset = languageSubset || options2.languages || Object.keys(languages);
        const plaintext = justTextHighlightResult(code);
        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
          (name3) => _highlight(name3, code, false)
        );
        results.unshift(plaintext);
        const sorted = results.sort((a2, b) => {
          if (a2.relevance !== b.relevance)
            return b.relevance - a2.relevance;
          if (a2.language && b.language) {
            if (getLanguage(a2.language).supersetOf === b.language) {
              return 1;
            } else if (getLanguage(b.language).supersetOf === a2.language) {
              return -1;
            }
          }
          return 0;
        });
        const [best, secondBest] = sorted;
        const result = best;
        result.secondBest = secondBest;
        return result;
      }
      function updateClassName(element, currentLang, resultLang) {
        const language = currentLang && aliases[currentLang] || resultLang;
        element.classList.add("hljs");
        element.classList.add(`language-${language}`);
      }
      function highlightElement(element) {
        let node = null;
        const language = blockLanguage(element);
        if (shouldNotHighlight(language))
          return;
        fire(
          "before:highlightElement",
          { el: element, language }
        );
        if (element.children.length > 0) {
          if (!options2.ignoreUnescapedHTML) {
            console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
            console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
            console.warn("The element with unescaped HTML:");
            console.warn(element);
          }
          if (options2.throwUnescapedHTML) {
            const err = new HTMLInjectionError2(
              "One of your code blocks includes unescaped HTML.",
              element.innerHTML
            );
            throw err;
          }
        }
        node = element;
        const text3 = node.textContent;
        const result = language ? highlight3(text3, { language, ignoreIllegals: true }) : highlightAuto(text3);
        element.innerHTML = result.value;
        updateClassName(element, language, result.language);
        element.result = {
          language: result.language,
          // TODO: remove with version 11.0
          re: result.relevance,
          relevance: result.relevance
        };
        if (result.secondBest) {
          element.secondBest = {
            language: result.secondBest.language,
            relevance: result.secondBest.relevance
          };
        }
        fire("after:highlightElement", { el: element, result, text: text3 });
      }
      function configure(userOptions) {
        options2 = inherit2(options2, userOptions);
      }
      const initHighlighting = () => {
        highlightAll();
        deprecated2("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      };
      function initHighlightingOnLoad() {
        highlightAll();
        deprecated2("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      }
      let wantsHighlight = false;
      function highlightAll() {
        if (document.readyState === "loading") {
          wantsHighlight = true;
          return;
        }
        const blocks = document.querySelectorAll(options2.cssSelector);
        blocks.forEach(highlightElement);
      }
      function boot() {
        if (wantsHighlight)
          highlightAll();
      }
      if (typeof window !== "undefined" && window.addEventListener) {
        window.addEventListener("DOMContentLoaded", boot, false);
      }
      function registerLanguage(languageName, languageDefinition) {
        let lang = null;
        try {
          lang = languageDefinition(hljs);
        } catch (error$1) {
          error3("Language definition for '{}' could not be registered.".replace("{}", languageName));
          if (!SAFE_MODE) {
            throw error$1;
          } else {
            error3(error$1);
          }
          lang = PLAINTEXT_LANGUAGE;
        }
        if (!lang.name)
          lang.name = languageName;
        languages[languageName] = lang;
        lang.rawDefinition = languageDefinition.bind(null, hljs);
        if (lang.aliases) {
          registerAliases(lang.aliases, { languageName });
        }
      }
      function unregisterLanguage(languageName) {
        delete languages[languageName];
        for (const alias of Object.keys(aliases)) {
          if (aliases[alias] === languageName) {
            delete aliases[alias];
          }
        }
      }
      function listLanguages() {
        return Object.keys(languages);
      }
      function getLanguage(name3) {
        name3 = (name3 || "").toLowerCase();
        return languages[name3] || languages[aliases[name3]];
      }
      function registerAliases(aliasList, { languageName }) {
        if (typeof aliasList === "string") {
          aliasList = [aliasList];
        }
        aliasList.forEach((alias) => {
          aliases[alias.toLowerCase()] = languageName;
        });
      }
      function autoDetection(name3) {
        const lang = getLanguage(name3);
        return lang && !lang.disableAutodetect;
      }
      function upgradePluginAPI(plugin) {
        if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
          plugin["before:highlightElement"] = (data) => {
            plugin["before:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
        if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
          plugin["after:highlightElement"] = (data) => {
            plugin["after:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
      }
      function addPlugin(plugin) {
        upgradePluginAPI(plugin);
        plugins.push(plugin);
      }
      function removePlugin(plugin) {
        const index8 = plugins.indexOf(plugin);
        if (index8 !== -1) {
          plugins.splice(index8, 1);
        }
      }
      function fire(event, args) {
        const cb = event;
        plugins.forEach(function(plugin) {
          if (plugin[cb]) {
            plugin[cb](args);
          }
        });
      }
      function deprecateHighlightBlock(el) {
        deprecated2("10.7.0", "highlightBlock will be removed entirely in v12.0");
        deprecated2("10.7.0", "Please use highlightElement now.");
        return highlightElement(el);
      }
      Object.assign(hljs, {
        highlight: highlight3,
        highlightAuto,
        highlightAll,
        highlightElement,
        // TODO: Remove with v12 API
        highlightBlock: deprecateHighlightBlock,
        configure,
        initHighlighting,
        initHighlightingOnLoad,
        registerLanguage,
        unregisterLanguage,
        listLanguages,
        getLanguage,
        registerAliases,
        autoDetection,
        inherit: inherit2,
        addPlugin,
        removePlugin
      });
      hljs.debugMode = function() {
        SAFE_MODE = false;
      };
      hljs.safeMode = function() {
        SAFE_MODE = true;
      };
      hljs.versionString = version2;
      hljs.regex = {
        concat: concat2,
        lookahead: lookahead2,
        either: either2,
        optional: optional2,
        anyNumberOfTimes: anyNumberOfTimes2
      };
      for (const key3 in MODES3) {
        if (typeof MODES3[key3] === "object") {
          deepFreeze2(MODES3[key3]);
        }
      }
      Object.assign(hljs, MODES3);
      return hljs;
    };
    var highlight2 = HLJS2({});
    highlight2.newInstance = () => HLJS2({});
    module.exports = highlight2;
    highlight2.HighlightJS = highlight2;
    highlight2.default = highlight2;
  }
});

// node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/es/core.js
var import_core4, core_default;
var init_core = __esm({
  "node_modules/.pnpm/highlight.js@11.8.0/node_modules/highlight.js/es/core.js"() {
    import_core4 = __toESM(require_core(), 1);
    core_default = import_core4.default;
  }
});

// node_modules/.pnpm/lowlight@3.0.0/node_modules/lowlight/lib/index.js
function createLowlight(grammars) {
  const high = core_default.newInstance();
  if (grammars) {
    register(grammars);
  }
  return {
    highlight: highlight2,
    highlightAuto,
    listLanguages,
    register,
    registerAlias,
    registered: registered2
  };
  function highlight2(language, value, options2) {
    ok(typeof language === "string", "expected `string` as `name`");
    ok(typeof value === "string", "expected `string` as `value`");
    const settings = options2 || emptyOptions;
    const prefix = typeof settings.prefix === "string" ? settings.prefix : defaultPrefix;
    if (!high.getLanguage(language)) {
      throw new Error("Unknown language: `" + language + "` is not registered");
    }
    high.configure({ __emitter: HastEmitter, classPrefix: prefix });
    const result = (
      /** @type {HighlightResult & {_emitter: HastEmitter}} */
      high.highlight(value, { ignoreIllegals: true, language })
    );
    if (result.errorRaised) {
      throw new Error("Could not highlight with `Highlight.js`", {
        cause: result.errorRaised
      });
    }
    const root = result._emitter.root;
    const data = (
      /** @type {RootData} */
      root.data
    );
    data.language = result.language;
    data.relevance = result.relevance;
    return root;
  }
  function highlightAuto(value, options2) {
    ok(typeof value === "string", "expected `string` as `value`");
    const settings = options2 || emptyOptions;
    const subset = settings.subset || listLanguages();
    let index8 = -1;
    let relevance = 0;
    let result;
    while (++index8 < subset.length) {
      const name3 = subset[index8];
      if (!high.getLanguage(name3))
        continue;
      const current = highlight2(name3, value, options2);
      if (current.data && current.data.relevance !== void 0 && current.data.relevance > relevance) {
        relevance = current.data.relevance;
        result = current;
      }
    }
    return result || {
      type: "root",
      children: [],
      data: { language: void 0, relevance }
    };
  }
  function listLanguages() {
    return high.listLanguages();
  }
  function register(grammarsOrName, grammar) {
    if (typeof grammarsOrName === "string") {
      ok(grammar !== void 0, "expected `grammar`");
      high.registerLanguage(grammarsOrName, grammar);
    } else {
      let name3;
      for (name3 in grammarsOrName) {
        if (Object.hasOwn(grammarsOrName, name3)) {
          high.registerLanguage(name3, grammarsOrName[name3]);
        }
      }
    }
  }
  function registerAlias(aliasesOrName, alias) {
    if (typeof aliasesOrName === "string") {
      ok(alias !== void 0);
      high.registerAliases(
        // Note: copy needed because hljs doesn’t accept readonly arrays yet.
        typeof alias === "string" ? alias : [...alias],
        { languageName: aliasesOrName }
      );
    } else {
      let key3;
      for (key3 in aliasesOrName) {
        if (Object.hasOwn(aliasesOrName, key3)) {
          const aliases = aliasesOrName[key3];
          high.registerAliases(
            // Note: copy needed because hljs doesn’t accept readonly arrays yet.
            typeof aliases === "string" ? aliases : [...aliases],
            { languageName: key3 }
          );
        }
      }
    }
  }
  function registered2(aliasOrName) {
    return Boolean(high.getLanguage(aliasOrName));
  }
}
var emptyOptions, defaultPrefix, HastEmitter;
var init_lib2 = __esm({
  "node_modules/.pnpm/lowlight@3.0.0/node_modules/lowlight/lib/index.js"() {
    init_default();
    init_core();
    emptyOptions = {};
    defaultPrefix = "hljs-";
    HastEmitter = class {
      /**
       * @param {Readonly<HljsOptions>} options
       *   Configuration.
       * @returns
       *   Instance.
       */
      constructor(options2) {
        this.options = options2;
        this.root = {
          type: "root",
          children: [],
          data: { language: void 0, relevance: 0 }
        };
        this.stack = [this.root];
      }
      /**
       * @param {string} value
       *   Text to add.
       * @returns {undefined}
       *   Nothing.
       *
       */
      addText(value) {
        if (value === "")
          return;
        const current = this.stack[this.stack.length - 1];
        const tail = current.children[current.children.length - 1];
        if (tail && tail.type === "text") {
          tail.value += value;
        } else {
          current.children.push({ type: "text", value });
        }
      }
      /**
       *
       * @param {unknown} rawName
       *   Name to add.
       * @returns {undefined}
       *   Nothing.
       */
      startScope(rawName) {
        this.openNode(String(rawName));
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      endScope() {
        this.closeNode();
      }
      /**
       * @param {HastEmitter} other
       *   Other emitter.
       * @param {string} name
       *   Name of the sublanguage.
       * @returns {undefined}
       *   Nothing.
       */
      __addSublanguage(other, name3) {
        const current = this.stack[this.stack.length - 1];
        const results = (
          /** @type {Array<ElementContent>} */
          other.root.children
        );
        if (name3) {
          current.children.push({
            type: "element",
            tagName: "span",
            properties: { className: [name3] },
            children: results
          });
        } else {
          current.children.push(...results);
        }
      }
      /**
       * @param {string} name
       *   Name to add.
       * @returns {undefined}
       *   Nothing.
       */
      openNode(name3) {
        const self = this;
        const className = name3.split(".").map(function(d, i2) {
          return i2 ? d + "_".repeat(i2) : self.options.classPrefix + d;
        });
        const current = this.stack[this.stack.length - 1];
        const child = {
          type: "element",
          tagName: "span",
          properties: { className },
          children: []
        };
        current.children.push(child);
        this.stack.push(child);
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      closeNode() {
        this.stack.pop();
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      finalize() {
      }
      /**
       * @returns {string}
       *   Nothing.
       */
      toHTML() {
        return "";
      }
    };
  }
});

// node_modules/.pnpm/lowlight@3.0.0/node_modules/lowlight/index.js
var init_lowlight = __esm({
  "node_modules/.pnpm/lowlight@3.0.0/node_modules/lowlight/index.js"() {
    init_lib2();
  }
});

// .svelte-kit/output/server/entries/pages/(authed)/_itemId_/_page.svelte.js
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => Page2
});
var CheckCircled, CheckCircled$1, NoteTitle, inputRegex$5, starInputRegex$1, starPasteRegex$1, underscoreInputRegex$1, underscorePasteRegex$1, ListItem, TextStyle, inputRegex$4, inputRegex$3, pasteRegex$1, starInputRegex, starPasteRegex, underscoreInputRegex, underscorePasteRegex, inputRegex$2, inputRegex$1, pasteRegex, inputRegex, TipTap, Page2;
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/(authed)/_itemId_/_page.svelte.js"() {
    init_ssr();
    init_Toaster_svelte_svelte_type_style_lang();
    init_stores();
    init_dist18();
    init_dist7();
    init_dist20();
    init_dist22();
    init_dist25();
    init_dist9();
    init_dist27();
    init_dist28();
    init_css();
    init_javascript();
    init_typescript();
    init_xml();
    init_lowlight();
    CheckCircled = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size2 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size2 !== void 0)
        $$bindings.size(size2);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size2) },
          { height: escape_attribute_value(size2) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M7.49991 0.877045C3.84222 0.877045 0.877075 3.84219 0.877075 7.49988C0.877075 11.1575 3.84222 14.1227 7.49991 14.1227C11.1576 14.1227 14.1227 11.1575 14.1227 7.49988C14.1227 3.84219 11.1576 0.877045 7.49991 0.877045ZM1.82708 7.49988C1.82708 4.36686 4.36689 1.82704 7.49991 1.82704C10.6329 1.82704 13.1727 4.36686 13.1727 7.49988C13.1727 10.6329 10.6329 13.1727 7.49991 13.1727C4.36689 13.1727 1.82708 10.6329 1.82708 7.49988ZM10.1589 5.53774C10.3178 5.31191 10.2636 5.00001 10.0378 4.84109C9.81194 4.68217 9.50004 4.73642 9.34112 4.96225L6.51977 8.97154L5.35681 7.78706C5.16334 7.59002 4.84677 7.58711 4.64973 7.78058C4.45268 7.97404 4.44978 8.29061 4.64325 8.48765L6.22658 10.1003C6.33054 10.2062 6.47617 10.2604 6.62407 10.2483C6.77197 10.2363 6.90686 10.1591 6.99226 10.0377L10.1589 5.53774Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    CheckCircled$1 = CheckCircled;
    NoteTitle = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { note } = $$props;
      let name3 = note.name;
      if ($$props.note === void 0 && $$bindings.note && note !== void 0)
        $$bindings.note(note);
      {
        {
          name3 = note.name;
        }
      }
      return `<input type="text" class="w-full py-6 px-4 text-3xl font-semibold bg-transparent border-b border-neutral-700 focus:outline-none" placeholder="Title" maxlength="75"${add_attribute("value", name3, 0)}>`;
    });
    inputRegex$5 = /^\s*>\s$/;
    Node3.create({
      name: "blockquote",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      group: "block",
      defining: true,
      parseHTML() {
        return [{ tag: "blockquote" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setBlockquote: () => ({ commands: commands2 }) => {
            return commands2.wrapIn(this.name);
          },
          toggleBlockquote: () => ({ commands: commands2 }) => {
            return commands2.toggleWrap(this.name);
          },
          unsetBlockquote: () => ({ commands: commands2 }) => {
            return commands2.lift(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        };
      },
      addInputRules() {
        return [
          wrappingInputRule({
            find: inputRegex$5,
            type: this.type
          })
        ];
      }
    });
    starInputRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
    starPasteRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
    underscoreInputRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
    underscorePasteRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
    Mark2.create({
      name: "bold",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "strong"
          },
          {
            tag: "b",
            getAttrs: (node) => node.style.fontWeight !== "normal" && null
          },
          {
            style: "font-weight",
            getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setBold: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleBold: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetBold: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-b": () => this.editor.commands.toggleBold(),
          "Mod-B": () => this.editor.commands.toggleBold()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: starInputRegex$1,
            type: this.type
          }),
          markInputRule({
            find: underscoreInputRegex$1,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: starPasteRegex$1,
            type: this.type
          }),
          markPasteRule({
            find: underscorePasteRegex$1,
            type: this.type
          })
        ];
      }
    });
    ListItem = Node3.create({
      name: "listItem",
      addOptions() {
        return {
          HTMLAttributes: {},
          bulletListTypeName: "bulletList",
          orderedListTypeName: "orderedList"
        };
      },
      content: "paragraph block*",
      defining: true,
      parseHTML() {
        return [
          {
            tag: "li"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addKeyboardShortcuts() {
        return {
          Enter: () => this.editor.commands.splitListItem(this.name),
          Tab: () => this.editor.commands.sinkListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
      }
    });
    TextStyle = Mark2.create({
      name: "textStyle",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "span",
            getAttrs: (element) => {
              const hasStyles = element.hasAttribute("style");
              if (!hasStyles) {
                return false;
              }
              return {};
            }
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
            const attributes = getMarkAttributes(state, this.type);
            const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
            if (hasStyles) {
              return true;
            }
            return commands2.unsetMark(this.name);
          }
        };
      }
    });
    inputRegex$4 = /^\s*([-+*])\s$/;
    Node3.create({
      name: "bulletList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [{ tag: "ul" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          toggleBulletList: () => ({ commands: commands2, chain }) => {
            if (this.options.keepAttributes) {
              return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();
            }
            return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        };
      },
      addInputRules() {
        let inputRule = wrappingInputRule({
          find: inputRegex$4,
          type: this.type
        });
        if (this.options.keepMarks || this.options.keepAttributes) {
          inputRule = wrappingInputRule({
            find: inputRegex$4,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: () => {
              return this.editor.getAttributes(TextStyle.name);
            },
            editor: this.editor
          });
        }
        return [inputRule];
      }
    });
    Extension.create({
      name: "characterCount",
      addOptions() {
        return {
          limit: null,
          mode: "textSize"
        };
      },
      addStorage() {
        return {
          characters: () => 0,
          words: () => 0
        };
      },
      onBeforeCreate() {
        this.storage.characters = (options2) => {
          const node = options2?.node || this.editor.state.doc;
          const mode = options2?.mode || this.options.mode;
          if (mode === "textSize") {
            const text3 = node.textBetween(0, node.content.size, void 0, " ");
            return text3.length;
          }
          return node.nodeSize;
        };
        this.storage.words = (options2) => {
          const node = options2?.node || this.editor.state.doc;
          const text3 = node.textBetween(0, node.content.size, " ", " ");
          const words = text3.split(" ").filter((word) => word !== "");
          return words.length;
        };
      },
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("characterCount"),
            filterTransaction: (transaction, state) => {
              const limit = this.options.limit;
              if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {
                return true;
              }
              const oldSize = this.storage.characters({ node: state.doc });
              const newSize = this.storage.characters({ node: transaction.doc });
              if (newSize <= limit) {
                return true;
              }
              if (oldSize > limit && newSize > limit && newSize <= oldSize) {
                return true;
              }
              if (oldSize > limit && newSize > limit && newSize > oldSize) {
                return false;
              }
              const isPaste = transaction.getMeta("paste");
              if (!isPaste) {
                return false;
              }
              const pos = transaction.selection.$head.pos;
              const over = newSize - limit;
              const from2 = pos - over;
              const to = pos;
              transaction.deleteRange(from2, to);
              const updatedSize = this.storage.characters({ node: transaction.doc });
              if (updatedSize > limit) {
                return false;
              }
              return true;
            }
          })
        ];
      }
    });
    inputRegex$3 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
    pasteRegex$1 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
    Mark2.create({
      name: "code",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      excludes: "_",
      code: true,
      exitable: true,
      parseHTML() {
        return [{ tag: "code" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setCode: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleCode: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetCode: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-e": () => this.editor.commands.toggleCode()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: inputRegex$3,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: pasteRegex$1,
            type: this.type
          })
        ];
      }
    });
    Node3.create({
      name: "doc",
      topNode: true,
      content: "block+"
    });
    Extension.create({
      name: "dropCursor",
      addOptions() {
        return {
          color: "currentColor",
          width: 1,
          class: void 0
        };
      },
      addProseMirrorPlugins() {
        return [dropCursor(this.options)];
      }
    });
    Extension.create({
      name: "gapCursor",
      addProseMirrorPlugins() {
        return [gapCursor()];
      },
      extendNodeSchema(extension) {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        return {
          allowGapCursor: callOrReturn(getExtensionField(extension, "allowGapCursor", context)) ?? null
        };
      }
    });
    Node3.create({
      name: "hardBreak",
      addOptions() {
        return {
          keepMarks: true,
          HTMLAttributes: {}
        };
      },
      inline: true,
      group: "inline",
      selectable: false,
      parseHTML() {
        return [{ tag: "br" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
      },
      renderText() {
        return "\n";
      },
      addCommands() {
        return {
          setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
            return commands2.first([
              () => commands2.exitCode(),
              () => commands2.command(() => {
                const { selection, storedMarks } = state;
                if (selection.$from.parent.type.spec.isolating) {
                  return false;
                }
                const { keepMarks } = this.options;
                const { splittableMarks } = editor.extensionManager;
                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
                return chain().insertContent({ type: this.name }).command(({ tr: tr2, dispatch }) => {
                  if (dispatch && marks && keepMarks) {
                    const filteredMarks = marks.filter(
                      (mark) => splittableMarks.includes(mark.type.name)
                    );
                    tr2.ensureMarks(filteredMarks);
                  }
                  return true;
                }).run();
              })
            ]);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Enter": () => this.editor.commands.setHardBreak(),
          "Shift-Enter": () => this.editor.commands.setHardBreak()
        };
      }
    });
    Node3.create({
      name: "heading",
      addOptions() {
        return {
          levels: [1, 2, 3, 4, 5, 6],
          HTMLAttributes: {}
        };
      },
      content: "inline*",
      group: "block",
      defining: true,
      addAttributes() {
        return {
          level: {
            default: 1,
            rendered: false
          }
        };
      },
      parseHTML() {
        return this.options.levels.map((level) => ({
          tag: `h${level}`,
          attrs: { level }
        }));
      },
      renderHTML({ node, HTMLAttributes }) {
        const hasLevel = this.options.levels.includes(node.attrs.level);
        const level = hasLevel ? node.attrs.level : this.options.levels[0];
        return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setHeading: (attributes) => ({ commands: commands2 }) => {
            if (!this.options.levels.includes(attributes.level)) {
              return false;
            }
            return commands2.setNode(this.name, attributes);
          },
          toggleHeading: (attributes) => ({ commands: commands2 }) => {
            if (!this.options.levels.includes(attributes.level)) {
              return false;
            }
            return commands2.toggleNode(this.name, "paragraph", attributes);
          }
        };
      },
      addKeyboardShortcuts() {
        return this.options.levels.reduce(
          (items, level) => ({
            ...items,
            ...{
              [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
            }
          }),
          {}
        );
      },
      addInputRules() {
        return this.options.levels.map((level) => {
          return textblockTypeInputRule({
            find: new RegExp(`^(#{1,${level}})\\s$`),
            type: this.type,
            getAttributes: {
              level
            }
          });
        });
      }
    });
    Extension.create({
      name: "history",
      addOptions() {
        return {
          depth: 100,
          newGroupDelay: 500
        };
      },
      addCommands() {
        return {
          undo: () => ({ state, dispatch }) => {
            return undo(state, dispatch);
          },
          redo: () => ({ state, dispatch }) => {
            return redo(state, dispatch);
          }
        };
      },
      addProseMirrorPlugins() {
        return [history(this.options)];
      },
      addKeyboardShortcuts() {
        return {
          "Mod-z": () => this.editor.commands.undo(),
          "Mod-Z": () => this.editor.commands.undo(),
          "Mod-y": () => this.editor.commands.redo(),
          "Mod-Y": () => this.editor.commands.redo(),
          "Shift-Mod-z": () => this.editor.commands.redo(),
          "Shift-Mod-Z": () => this.editor.commands.redo(),
          // Russian keyboard layouts
          "Mod-\u044F": () => this.editor.commands.undo(),
          "Shift-Mod-\u044F": () => this.editor.commands.redo()
        };
      }
    });
    Node3.create({
      name: "horizontalRule",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      parseHTML() {
        return [{ tag: "hr" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
      },
      addCommands() {
        return {
          setHorizontalRule: () => ({ chain, state }) => {
            const { $to: $originTo } = state.selection;
            const currentChain = chain();
            if ($originTo.parentOffset === 0) {
              currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), { type: this.name });
            } else {
              currentChain.insertContent({ type: this.name });
            }
            return currentChain.command(({ tr: tr2, dispatch }) => {
              if (dispatch) {
                const { $to } = tr2.selection;
                const posAfter = $to.end();
                if ($to.nodeAfter) {
                  if ($to.nodeAfter.isTextblock) {
                    tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
                  } else if ($to.nodeAfter.isBlock) {
                    tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
                  } else {
                    tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
                  }
                } else {
                  const node = $to.parent.type.contentMatch.defaultType?.create();
                  if (node) {
                    tr2.insert(posAfter, node);
                    tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
                  }
                }
                tr2.scrollIntoView();
              }
              return true;
            }).run();
          }
        };
      },
      addInputRules() {
        return [
          nodeInputRule({
            find: /^(?:---|—-|___\s|\*\*\*\s)$/,
            type: this.type
          })
        ];
      }
    });
    starInputRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
    starPasteRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
    underscoreInputRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
    underscorePasteRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
    Mark2.create({
      name: "italic",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "em"
          },
          {
            tag: "i",
            getAttrs: (node) => node.style.fontStyle !== "normal" && null
          },
          {
            style: "font-style=italic"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setItalic: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleItalic: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetItalic: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-i": () => this.editor.commands.toggleItalic(),
          "Mod-I": () => this.editor.commands.toggleItalic()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: starInputRegex,
            type: this.type
          }),
          markInputRule({
            find: underscoreInputRegex,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: starPasteRegex,
            type: this.type
          }),
          markPasteRule({
            find: underscorePasteRegex,
            type: this.type
          })
        ];
      }
    });
    inputRegex$2 = /^(\d+)\.\s$/;
    Node3.create({
      name: "orderedList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      addAttributes() {
        return {
          start: {
            default: 1,
            parseHTML: (element) => {
              return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
            }
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "ol"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        const { start, ...attributesWithoutStart } = HTMLAttributes;
        return start === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          toggleOrderedList: () => ({ commands: commands2, chain }) => {
            if (this.options.keepAttributes) {
              return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();
            }
            return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        };
      },
      addInputRules() {
        let inputRule = wrappingInputRule({
          find: inputRegex$2,
          type: this.type,
          getAttributes: (match) => ({ start: +match[1] }),
          joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
        });
        if (this.options.keepMarks || this.options.keepAttributes) {
          inputRule = wrappingInputRule({
            find: inputRegex$2,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: (match) => ({
              start: +match[1],
              ...this.editor.getAttributes(TextStyle.name)
            }),
            joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
            editor: this.editor
          });
        }
        return [inputRule];
      }
    });
    Node3.create({
      name: "paragraph",
      priority: 1e3,
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      content: "inline*",
      parseHTML() {
        return [{ tag: "p" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setParagraph: () => ({ commands: commands2 }) => {
            return commands2.setNode(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-0": () => this.editor.commands.setParagraph()
        };
      }
    });
    Extension.create({
      name: "placeholder",
      addOptions() {
        return {
          emptyEditorClass: "is-editor-empty",
          emptyNodeClass: "is-empty",
          placeholder: "Write something \u2026",
          showOnlyWhenEditable: true,
          considerAnyAsEmpty: false,
          showOnlyCurrent: true,
          includeChildren: false
        };
      },
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("placeholder"),
            props: {
              decorations: ({ doc: doc3, selection }) => {
                const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
                const { anchor } = selection;
                const decorations = [];
                if (!active) {
                  return null;
                }
                const { firstChild } = doc3.content;
                const isLeaf = firstChild && firstChild.type.isLeaf;
                const isAtom = firstChild && firstChild.isAtom;
                const isValidNode = this.options.considerAnyAsEmpty ? true : firstChild && firstChild.type.name === doc3.type.contentMatch.defaultType?.name;
                const isEmptyDoc = doc3.content.childCount <= 1 && firstChild && isValidNode && firstChild.nodeSize <= 2 && (!isLeaf || !isAtom);
                doc3.descendants((node, pos) => {
                  const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
                  const isEmpty = !node.isLeaf && !node.childCount;
                  if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                    const classes = [this.options.emptyNodeClass];
                    if (isEmptyDoc) {
                      classes.push(this.options.emptyEditorClass);
                    }
                    const decoration = Decoration.node(pos, pos + node.nodeSize, {
                      class: classes.join(" "),
                      "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                        editor: this.editor,
                        node,
                        pos,
                        hasAnchor
                      }) : this.options.placeholder
                    });
                    decorations.push(decoration);
                  }
                  return this.options.includeChildren;
                });
                return DecorationSet.create(doc3, decorations);
              }
            }
          })
        ];
      }
    });
    inputRegex$1 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
    pasteRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
    Mark2.create({
      name: "strike",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "s"
          },
          {
            tag: "del"
          },
          {
            tag: "strike"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (style) => style.includes("line-through") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setStrike: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleStrike: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetStrike: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        const shortcuts = {};
        if (isMacOS()) {
          shortcuts["Mod-Shift-s"] = () => this.editor.commands.toggleStrike();
        } else {
          shortcuts["Ctrl-Shift-s"] = () => this.editor.commands.toggleStrike();
        }
        return shortcuts;
      },
      addInputRules() {
        return [
          markInputRule({
            find: inputRegex$1,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: pasteRegex,
            type: this.type
          })
        ];
      }
    });
    inputRegex = /^\s*(-\[ ?\])\s*$/;
    Node3.create({
      name: "taskItem",
      addOptions() {
        return {
          nested: false,
          HTMLAttributes: {},
          taskListTypeName: "taskList"
        };
      },
      content() {
        return this.options.nested ? "paragraph block*" : "paragraph+";
      },
      defining: true,
      addAttributes() {
        return {
          checked: {
            default: false,
            keepOnSplit: false,
            parseHTML: (element) => element.getAttribute("data-checked") === "true",
            renderHTML: (attributes) => ({
              "data-checked": attributes.checked
            })
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: `li[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ node, HTMLAttributes }) {
        return [
          "li",
          mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
            "data-type": this.name
          }),
          [
            "label",
            [
              "input",
              {
                type: "checkbox",
                checked: node.attrs.checked ? "checked" : null
              }
            ],
            ["span"]
          ],
          ["div", 0]
        ];
      },
      addKeyboardShortcuts() {
        const shortcuts = {
          Enter: () => this.editor.commands.splitListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
        if (!this.options.nested) {
          return shortcuts;
        }
        return {
          ...shortcuts,
          Tab: () => this.editor.commands.sinkListItem(this.name)
        };
      },
      addNodeView() {
        return ({ node, HTMLAttributes, getPos, editor }) => {
          const listItem = document.createElement("li");
          const checkboxWrapper = document.createElement("label");
          const checkboxStyler = document.createElement("span");
          const checkbox = document.createElement("input");
          const content = document.createElement("div");
          checkboxWrapper.contentEditable = "false";
          checkbox.type = "checkbox";
          checkbox.addEventListener("change", (event) => {
            if (!editor.isEditable && !this.options.onReadOnlyChecked) {
              checkbox.checked = !checkbox.checked;
              return;
            }
            const { checked } = event.target;
            if (editor.isEditable && typeof getPos === "function") {
              editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: tr2 }) => {
                const position = getPos();
                const currentNode = tr2.doc.nodeAt(position);
                tr2.setNodeMarkup(position, void 0, {
                  ...currentNode?.attrs,
                  checked
                });
                return true;
              }).run();
            }
            if (!editor.isEditable && this.options.onReadOnlyChecked) {
              if (!this.options.onReadOnlyChecked(node, checked)) {
                checkbox.checked = !checkbox.checked;
              }
            }
          });
          Object.entries(this.options.HTMLAttributes).forEach(([key3, value]) => {
            listItem.setAttribute(key3, value);
          });
          listItem.dataset.checked = node.attrs.checked;
          if (node.attrs.checked) {
            checkbox.setAttribute("checked", "checked");
          }
          checkboxWrapper.append(checkbox, checkboxStyler);
          listItem.append(checkboxWrapper, content);
          Object.entries(HTMLAttributes).forEach(([key3, value]) => {
            listItem.setAttribute(key3, value);
          });
          return {
            dom: listItem,
            contentDOM: content,
            update: (updatedNode) => {
              if (updatedNode.type !== this.type) {
                return false;
              }
              listItem.dataset.checked = updatedNode.attrs.checked;
              if (updatedNode.attrs.checked) {
                checkbox.setAttribute("checked", "checked");
              } else {
                checkbox.removeAttribute("checked");
              }
              return true;
            }
          };
        };
      },
      addInputRules() {
        return [
          wrappingInputRule({
            find: inputRegex,
            type: this.type,
            getAttributes: (match) => ({
              checked: match[match.length - 1] === "x"
            })
          })
        ];
      }
    });
    Node3.create({
      name: "taskList",
      addOptions() {
        return {
          itemTypeName: "taskItem",
          HTMLAttributes: {}
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          {
            tag: `ul[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return [
          "ul",
          mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }),
          0
        ];
      },
      addCommands() {
        return {
          toggleTaskList: () => ({ commands: commands2 }) => {
            return commands2.toggleList(this.name, this.options.itemTypeName);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
        };
      }
    });
    Node3.create({
      name: "text",
      group: "inline"
    });
    TipTap = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$unsubscribe_page;
      $$unsubscribe_page = subscribe(page, (value) => value);
      let { content } = $$props;
      createLowlight({ html: xml, css: css2, js: javascript, ts: typescript });
      let element;
      onDestroy(() => {
      });
      if ($$props.content === void 0 && $$bindings.content && content !== void 0)
        $$bindings.content(content);
      $$unsubscribe_page();
      return `<div${add_attribute("this", element, 0)}></div> <div class="fixed bottom-0 right-0 px-3 py-2 rounded-md shadow-md bg-popover flex items-center justify-center gap-2 text-xs text-popover-foreground"><span>${escape(0)} characters</span> <span>${escape(0)} words</span> ${`${validate_component(CheckCircled$1, "CheckCircled").$$render($$result, { size: 16, color: "green" }, {}, {})}`}</div>`;
    });
    Page2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data } = $$props;
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      return `<div class="overflow-y-scroll h-full">${validate_component(NoteTitle, "NoteTitle").$$render($$result, { note: data.note }, {}, {})} <div class="md:pt-6 md:px-5 xl:px-6 pt-3 px-4 text-sm md:text-base">${validate_component(TipTap, "TipTap").$$render($$result, { content: data.note.file?.content ?? "" }, {}, {})}</div></div> ${$$result.head += `<!-- HEAD_svelte-1fbok04_START -->${$$result.title = `<title>Vault</title>`, ""}<!-- HEAD_svelte-1fbok04_END -->`, ""}`;
    });
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports5 = {};
__export(__exports5, {
  component: () => component5,
  fonts: () => fonts5,
  imports: () => imports5,
  index: () => index5,
  server: () => page_server_ts_exports2,
  server_id: () => server_id3,
  stylesheets: () => stylesheets5
});
var index5, component_cache5, component5, server_id3, imports5, stylesheets5, fonts5;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    init_page_server_ts2();
    index5 = 4;
    component5 = async () => component_cache5 ?? (component_cache5 = (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default);
    server_id3 = "src/routes/(authed)/[itemId]/+page.server.ts";
    imports5 = ["_app/immutable/nodes/4.6ce3f004.js", "_app/immutable/chunks/scheduler.e51e3a72.js", "_app/immutable/chunks/index.70313ae9.js", "_app/immutable/chunks/navigation.2b543295.js", "_app/immutable/chunks/singletons.844f0d64.js", "_app/immutable/chunks/index.6cb2aa35.js", "_app/immutable/chunks/Toaster.svelte_svelte_type_style_lang.7ad7c14e.js", "_app/immutable/chunks/stores.7848577e.js", "_app/immutable/chunks/spread.8a54911c.js"];
    stylesheets5 = ["_app/immutable/assets/4.ec81a1b1.css", "_app/immutable/assets/Toaster.37b6ac62.css"];
    fonts5 = [];
  }
});

// .svelte-kit/output/server/entries/pages/(unauthed)/signin/_page.server.ts.js
var page_server_ts_exports3 = {};
__export(page_server_ts_exports3, {
  actions: () => actions2,
  load: () => load3
});
var load3, actions2;
var init_page_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/pages/(unauthed)/signin/_page.server.ts.js"() {
    init_lucia();
    init_chunks();
    load3 = async ({ locals }) => {
      const session2 = await locals.auth.validate();
      if (session2)
        throw redirect(302, "/");
      return {};
    };
    actions2 = {
      default: async ({ request, locals }) => {
        const formData = await request.formData();
        const email = formData.get("email");
        const password = formData.get("password");
        if (typeof email !== "string" || email.length < 1 || email.length > 31) {
          return fail(400, {
            message: "Invalid email"
          });
        }
        if (typeof password !== "string" || password.length < 1 || password.length > 255) {
          return fail(400, {
            message: "Invalid password"
          });
        }
        try {
          const key3 = await auth.useKey("email", email.toLowerCase(), password);
          const session2 = await auth.createSession({
            userId: key3.userId,
            attributes: {}
          });
          locals.auth.setSession(session2);
        } catch (e) {
          if (e instanceof LuciaError && (e.message === "AUTH_INVALID_KEY_ID" || e.message === "AUTH_INVALID_PASSWORD")) {
            return fail(400, {
              message: "Incorrect email or password"
            });
          }
          return fail(500, {
            message: "An unknown error occurred"
          });
        }
        throw redirect(302, "/");
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/(unauthed)/signin/_page.svelte.js
var page_svelte_exports3 = {};
__export(page_svelte_exports3, {
  default: () => Page3
});
var Page3;
var init_page_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/(unauthed)/signin/_page.svelte.js"() {
    init_ssr();
    Page3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<h1 data-svelte-h="svelte-gn9sfy">Sign in</h1> <form method="post" data-svelte-h="svelte-1eci1os"><label for="email">email</label> <input name="email" id="email"><br> <label for="password">Password</label> <input type="password" name="password" id="password"><br> <input type="submit"></form> <a href="/signup" data-svelte-h="svelte-1cpnm5p">Create an account</a>`;
    });
  }
});

// .svelte-kit/output/server/nodes/5.js
var __exports6 = {};
__export(__exports6, {
  component: () => component6,
  fonts: () => fonts6,
  imports: () => imports6,
  index: () => index6,
  server: () => page_server_ts_exports3,
  server_id: () => server_id4,
  stylesheets: () => stylesheets6
});
var index6, component_cache6, component6, server_id4, imports6, stylesheets6, fonts6;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    init_page_server_ts3();
    index6 = 5;
    component6 = async () => component_cache6 ?? (component_cache6 = (await Promise.resolve().then(() => (init_page_svelte3(), page_svelte_exports3))).default);
    server_id4 = "src/routes/(unauthed)/signin/+page.server.ts";
    imports6 = ["_app/immutable/nodes/5.66e01a69.js", "_app/immutable/chunks/scheduler.e51e3a72.js", "_app/immutable/chunks/index.70313ae9.js", "_app/immutable/chunks/forms.74b24cae.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.844f0d64.js", "_app/immutable/chunks/index.6cb2aa35.js", "_app/immutable/chunks/navigation.2b543295.js"];
    stylesheets6 = [];
    fonts6 = [];
  }
});

// .svelte-kit/output/server/entries/pages/(unauthed)/signup/_page.server.ts.js
var page_server_ts_exports4 = {};
__export(page_server_ts_exports4, {
  actions: () => actions3,
  load: () => load4
});
var load4, actions3;
var init_page_server_ts4 = __esm({
  ".svelte-kit/output/server/entries/pages/(unauthed)/signup/_page.server.ts.js"() {
    init_lucia();
    init_chunks();
    load4 = async ({ locals }) => {
      const session2 = await locals.auth.validate();
      if (session2)
        throw redirect(302, "/");
      return {};
    };
    actions3 = {
      default: async ({ request, locals }) => {
        const formData = await request.formData();
        const email = formData.get("email");
        const password = formData.get("password");
        if (typeof email !== "string" || email.length < 4 || email.length > 31) {
          return fail(400, {
            message: "Invalid email"
          });
        }
        if (typeof password !== "string" || password.length < 6 || password.length > 255) {
          return fail(400, {
            message: "Invalid password"
          });
        }
        try {
          const user2 = await auth.createUser({
            key: {
              providerId: "email",
              // auth method
              providerUserId: email.toLowerCase(),
              // unique id when using "email" auth method
              password
              // hashed by Lucia
            },
            attributes: {
              email
            }
          });
          const session2 = await auth.createSession({
            userId: user2.userId,
            attributes: {}
          });
          locals.auth.setSession(session2);
        } catch (e) {
          return fail(500, {
            message: "An unknown error occurred"
          });
        }
        throw redirect(302, "/");
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/(unauthed)/signup/_page.svelte.js
var page_svelte_exports4 = {};
__export(page_svelte_exports4, {
  default: () => Page4
});
var Page4;
var init_page_svelte4 = __esm({
  ".svelte-kit/output/server/entries/pages/(unauthed)/signup/_page.svelte.js"() {
    init_ssr();
    Page4 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<h1 data-svelte-h="svelte-13vjqy4">Sign up</h1> <form method="post" data-svelte-h="svelte-1eci1os"><label for="email">email</label> <input name="email" id="email"><br> <label for="password">Password</label> <input type="password" name="password" id="password"><br> <input type="submit"></form> <a href="/login" data-svelte-h="svelte-1wr9uf8">Sign in</a>`;
    });
  }
});

// .svelte-kit/output/server/nodes/6.js
var __exports7 = {};
__export(__exports7, {
  component: () => component7,
  fonts: () => fonts7,
  imports: () => imports7,
  index: () => index7,
  server: () => page_server_ts_exports4,
  server_id: () => server_id5,
  stylesheets: () => stylesheets7
});
var index7, component_cache7, component7, server_id5, imports7, stylesheets7, fonts7;
var init__7 = __esm({
  ".svelte-kit/output/server/nodes/6.js"() {
    init_page_server_ts4();
    index7 = 6;
    component7 = async () => component_cache7 ?? (component_cache7 = (await Promise.resolve().then(() => (init_page_svelte4(), page_svelte_exports4))).default);
    server_id5 = "src/routes/(unauthed)/signup/+page.server.ts";
    imports7 = ["_app/immutable/nodes/6.4a456aa4.js", "_app/immutable/chunks/scheduler.e51e3a72.js", "_app/immutable/chunks/index.70313ae9.js", "_app/immutable/chunks/forms.74b24cae.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.844f0d64.js", "_app/immutable/chunks/index.6cb2aa35.js", "_app/immutable/chunks/navigation.2b543295.js"];
    stylesheets7 = [];
    fonts7 = [];
  }
});

// .svelte-kit/output/server/entries/endpoints/api/file/_server.ts.js
var server_ts_exports = {};
__export(server_ts_exports, {
  POST: () => POST
});
async function POST({ locals, request }) {
  const session2 = await locals.auth.validate();
  if (!session2)
    throw error(401, "Unauthorized");
  const userId = session2.user.userId;
  const body = await request.json();
  const parsedBody = schema2.safeParse(body);
  if (!parsedBody.success) {
    throw error(400, parsedBody.error.message);
  }
  const item = await db.query.itemsTable.findFirst({
    where: (table, { eq: eq2 }) => eq2(table.id, parsedBody.data.itemId),
    with: {
      file: true
    }
  });
  if (!item)
    throw error(404, "Item not found");
  if (item && item.userId !== userId)
    throw error(401, "Unauthorized");
  if (!item.file) {
    await Promise.all([
      db.insert(filesTable).values({
        id: (0, import_cuid22.createId)(),
        content: parsedBody.data.content,
        itemId: parsedBody.data.itemId
      }),
      db.update(itemsTable).set({
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(itemsTable.id, parsedBody.data.itemId))
    ]);
  } else {
    await Promise.all([
      db.update(filesTable).set({
        content: parsedBody.data.content
      }).where(eq(filesTable.id, item.file.id)),
      db.update(itemsTable).set({
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(itemsTable.id, parsedBody.data.itemId))
    ]);
  }
  return new Response();
}
var import_cuid22, schema2;
var init_server_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/file/_server.ts.js"() {
    init_index3();
    import_cuid22 = __toESM(require_cuid2(), 1);
    init_chunks();
    init_drizzle_orm();
    init_lib();
    schema2 = z.object({
      itemId: z.string().min(1),
      content: z.string()
    });
  }
});

// .svelte-kit/output/server/entries/endpoints/api/item/_server.ts.js
var server_ts_exports2 = {};
__export(server_ts_exports2, {
  PUT: () => PUT
});
async function PUT({ locals, request }) {
  const session2 = await locals.auth.validate();
  if (!session2)
    throw error(401, "Unauthorized");
  const userId = session2.user.userId;
  const body = await request.json();
  const parsedBody = editItemSchema.safeParse(body);
  if (!parsedBody.success) {
    throw error(400, parsedBody.error.message);
  }
  const item = await db.query.itemsTable.findFirst({
    where: (table, { eq: eq2, and: and2 }) => and2(eq2(table.id, parsedBody.data.itemId), eq2(table.userId, userId))
  });
  if (!item)
    throw error(404, "Item not found");
  await db.update(itemsTable).set({
    name: parsedBody.data.name
  }).where(eq(itemsTable.id, parsedBody.data.itemId));
  return new Response();
}
var editItemSchema;
var init_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/item/_server.ts.js"() {
    init_index3();
    init_chunks();
    init_drizzle_orm();
    init_lib();
    editItemSchema = z.object({
      name: z.string().min(1),
      itemId: z.string().min(1)
    });
  }
});

// .svelte-kit/output/server/entries/endpoints/api/seed/_server.ts.js
var server_ts_exports3 = {};
__export(server_ts_exports3, {
  POST: () => POST2
});
async function POST2({ locals }) {
  const session2 = await locals.auth.validate();
  if (!session2)
    throw error(401, "Unauthorized");
  const userId = session2.user.userId;
  const folder1Id = (0, import_cuid23.createId)();
  await db.insert(itemsTable).values({
    id: folder1Id,
    userId,
    name: "Folder 1",
    parentId: null,
    type: "folder"
  });
  const folder2Id = (0, import_cuid23.createId)();
  await db.insert(itemsTable).values({
    id: folder2Id,
    userId,
    name: "Folder 1 1",
    parentId: folder1Id,
    type: "folder"
  });
  const folder3Id = (0, import_cuid23.createId)();
  await db.insert(itemsTable).values({
    id: folder3Id,
    userId,
    name: "Folder 1 1 1",
    parentId: folder2Id,
    type: "folder"
  });
  await Promise.all([
    db.insert(itemsTable).values({
      id: (0, import_cuid23.createId)(),
      userId,
      name: "File 1 1",
      parentId: folder1Id,
      type: "file"
    }),
    db.insert(itemsTable).values({
      id: (0, import_cuid23.createId)(),
      userId,
      name: "File 1 1 1",
      parentId: folder2Id,
      type: "file"
    }),
    db.insert(itemsTable).values({
      id: (0, import_cuid23.createId)(),
      userId,
      name: "File 1 1 2",
      parentId: folder2Id,
      type: "file"
    }),
    db.insert(itemsTable).values({
      id: (0, import_cuid23.createId)(),
      userId,
      name: "File 1 1 1 1",
      parentId: folder3Id,
      type: "file"
    }),
    db.insert(itemsTable).values({
      id: (0, import_cuid23.createId)(),
      userId,
      name: "File 1",
      parentId: null,
      type: "file"
    }),
    db.insert(itemsTable).values({
      id: (0, import_cuid23.createId)(),
      userId,
      name: "File 2",
      parentId: null,
      type: "file"
    })
  ]);
  return new Response();
}
var import_cuid23;
var init_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/seed/_server.ts.js"() {
    init_index3();
    import_cuid23 = __toESM(require_cuid2(), 1);
    init_chunks();
  }
});

// .svelte-kit/output/server/chunks/internal.js
init_ssr();
init_shared_server();
var base = "";
var assets = base;
var initial = { base, assets };
function reset() {
  base = initial.base;
  assets = initial.assets;
}
function afterUpdate() {
}
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page: page2 } = $$props;
  let { constructors } = $$props;
  let { components = [] } = $$props;
  let { form } = $$props;
  let { data_0 = null } = $$props;
  let { data_1 = null } = $$props;
  let { data_2 = null } = $$props;
  {
    setContext("__svelte__", stores);
  }
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
    $$bindings.page(page2);
  if ($$props.constructors === void 0 && $$bindings.constructors && constructors !== void 0)
    $$bindings.constructors(constructors);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.form === void 0 && $$bindings.form && form !== void 0)
    $$bindings.form(form);
  if ($$props.data_0 === void 0 && $$bindings.data_0 && data_0 !== void 0)
    $$bindings.data_0(data_0);
  if ($$props.data_1 === void 0 && $$bindings.data_1 && data_1 !== void 0)
    $$bindings.data_1(data_1);
  if ($$props.data_2 === void 0 && $$bindings.data_2 && data_2 !== void 0)
    $$bindings.data_2(data_2);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    {
      stores.page.set(page2);
    }
    $$rendered = `  ${constructors[1] ? `${validate_component(constructors[0] || missing_component, "svelte:component").$$render(
      $$result,
      { data: data_0, this: components[0] },
      {
        this: ($$value) => {
          components[0] = $$value;
          $$settled = false;
        }
      },
      {
        default: () => {
          return `${constructors[2] ? `${validate_component(constructors[1] || missing_component, "svelte:component").$$render(
            $$result,
            { data: data_1, this: components[1] },
            {
              this: ($$value) => {
                components[1] = $$value;
                $$settled = false;
              }
            },
            {
              default: () => {
                return `${validate_component(constructors[2] || missing_component, "svelte:component").$$render(
                  $$result,
                  { data: data_2, form, this: components[2] },
                  {
                    this: ($$value) => {
                      components[2] = $$value;
                      $$settled = false;
                    }
                  },
                  {}
                )}`;
              }
            }
          )}` : `${validate_component(constructors[1] || missing_component, "svelte:component").$$render(
            $$result,
            { data: data_1, form, this: components[1] },
            {
              this: ($$value) => {
                components[1] = $$value;
                $$settled = false;
              }
            },
            {}
          )}`}`;
        }
      }
    )}` : `${validate_component(constructors[0] || missing_component, "svelte:component").$$render(
      $$result,
      { data: data_0, form, this: components[0] },
      {
        this: ($$value) => {
          components[0] = $$value;
          $$settled = false;
        }
      },
      {}
    )}`} ${``}`;
  } while (!$$settled);
  return $$rendered;
});
var options = {
  app_template_contains_nonce: false,
  csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, "reportOnly": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
  csrf_check_origin: true,
  track_server_fetches: false,
  embedded: false,
  env_public_prefix: "PUBLIC_",
  env_private_prefix: "",
  hooks: null,
  // added lazily, via `get_hooks`
  preload_strategy: "modulepreload",
  root: Root,
  service_worker: false,
  templates: {
    app: ({ head, body, assets: assets2, nonce, env }) => '<!DOCTYPE html>\r\n<html lang="en">\r\n	<head>\r\n		<meta charset="utf-8" />\r\n		<link rel="icon" href="' + assets2 + '/favicon.png" />\r\n		<meta name="viewport" content="width=device-width" />\r\n		' + head + '\r\n	</head>\r\n	<body data-sveltekit-preload-data="hover">\r\n		<div style="display: contents">' + body + "</div>\r\n	</body>\r\n</html>\r\n",
    error: ({ status, message }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<title>' + message + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
					Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + status + '</span>\n			<div class="message">\n				<h1>' + message + "</h1>\n			</div>\n		</div>\n	</body>\n</html>\n"
  },
  version_hash: "sce6dw"
};
function get_hooks() {
  return Promise.resolve().then(() => (init_hooks_server(), hooks_server_exports));
}

// .svelte-kit/output/server/index.js
init_chunks();
init_index2();
init_shared_server();
var DEV = false;
var SVELTE_KIT_ASSETS = "/_svelte_kit_assets";
var ENDPOINT_METHODS = /* @__PURE__ */ new Set([
  "GET",
  "POST",
  "PUT",
  "PATCH",
  "DELETE",
  "OPTIONS",
  "HEAD"
]);
var PAGE_METHODS = /* @__PURE__ */ new Set(["GET", "POST", "HEAD"]);
function negotiate(accept, types) {
  const parts = [];
  accept.split(",").forEach((str, i2) => {
    const match = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q = "1"] = match;
      parts.push({ type, subtype, q: +q, i: i2 });
    }
  });
  parts.sort((a2, b) => {
    if (a2.q !== b.q) {
      return b.q - a2.q;
    }
    if (a2.subtype === "*" !== (b.subtype === "*")) {
      return a2.subtype === "*" ? 1 : -1;
    }
    if (a2.type === "*" !== (b.type === "*")) {
      return a2.type === "*" ? 1 : -1;
    }
    return a2.i - b.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex(
      (part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*")
    );
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
function is_content_type(request, ...types) {
  const type = request.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return types.includes(type.toLowerCase());
}
function is_form_content_type(request) {
  return is_content_type(
    request,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
}
function exec(match, params, matchers) {
  const result = {};
  const values = match.slice(1);
  let buffered = 0;
  for (let i2 = 0; i2 < params.length; i2 += 1) {
    const param2 = params[i2];
    let value = values[i2 - buffered];
    if (param2.chained && param2.rest && buffered) {
      value = values.slice(i2 - buffered, i2 + 1).filter((s2) => s2).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param2.rest)
        result[param2.name] = "";
      continue;
    }
    if (!param2.matcher || matchers[param2.matcher](value)) {
      result[param2.name] = value;
      const next_param = params[i2 + 1];
      const next_value = values[i2 + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param2.chained) {
        buffered = 0;
      }
      continue;
    }
    if (param2.optional && param2.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered)
    return;
  return result;
}
function coalesce_to_error(err) {
  return err instanceof Error || err && /** @type {any} */
  err.name && /** @type {any} */
  err.message ? (
    /** @type {Error} */
    err
  ) : new Error(JSON.stringify(err));
}
function normalize_error(error22) {
  return (
    /** @type {import('../runtime/control.js').Redirect | import('../runtime/control.js').HttpError | Error} */
    error22
  );
}
function method_not_allowed(mod, method) {
  return text2(`${method} method not allowed`, {
    status: 405,
    headers: {
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: allowed_methods(mod).join(", ")
    }
  });
}
function allowed_methods(mod) {
  const allowed = Array.from(ENDPOINT_METHODS).filter((method) => method in mod);
  if ("GET" in mod || "HEAD" in mod)
    allowed.push("HEAD");
  return allowed;
}
function static_error_page(options2, status, message) {
  let page2 = options2.templates.error({ status, message });
  return text2(page2, {
    headers: { "content-type": "text/html; charset=utf-8" },
    status
  });
}
async function handle_fatal_error(event, options2, error22) {
  error22 = error22 instanceof HttpError ? error22 : coalesce_to_error(error22);
  const status = error22 instanceof HttpError ? error22.status : 500;
  const body = await handle_error_and_jsonify(event, options2, error22);
  const type = negotiate(event.request.headers.get("accept") || "text/html", [
    "application/json",
    "text/html"
  ]);
  if (event.isDataRequest || type === "application/json") {
    return json(body, {
      status
    });
  }
  return static_error_page(options2, status, body.message);
}
async function handle_error_and_jsonify(event, options2, error22) {
  if (error22 instanceof HttpError) {
    return error22.body;
  } else {
    return await options2.hooks.handleError({ error: error22, event }) ?? {
      message: event.route.id != null ? "Internal Error" : "Not Found"
    };
  }
}
function redirect_response(status, location) {
  const response = new Response(void 0, {
    status,
    headers: { location }
  });
  return response;
}
function clarify_devalue_error(event, error22) {
  if (error22.path) {
    return `Data returned from \`load\` while rendering ${event.route.id} is not serializable: ${error22.message} (data${error22.path})`;
  }
  if (error22.path === "") {
    return `Data returned from \`load\` while rendering ${event.route.id} is not a plain object`;
  }
  return error22.message;
}
function stringify_uses(node) {
  const uses = [];
  if (node.uses && node.uses.dependencies.size > 0) {
    uses.push(`"dependencies":${JSON.stringify(Array.from(node.uses.dependencies))}`);
  }
  if (node.uses && node.uses.params.size > 0) {
    uses.push(`"params":${JSON.stringify(Array.from(node.uses.params))}`);
  }
  if (node.uses?.parent)
    uses.push('"parent":1');
  if (node.uses?.route)
    uses.push('"route":1');
  if (node.uses?.url)
    uses.push('"url":1');
  return `"uses":{${uses.join(",")}}`;
}
async function render_endpoint(event, mod, state) {
  const method = (
    /** @type {import('types').HttpMethod} */
    event.request.method
  );
  let handler = mod[method] || mod.fallback;
  if (method === "HEAD" && mod.GET && !mod.HEAD) {
    handler = mod.GET;
  }
  if (!handler) {
    return method_not_allowed(mod, method);
  }
  const prerender = mod.prerender ?? state.prerender_default;
  if (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {
    throw new Error("Cannot prerender endpoints that have mutative methods");
  }
  if (state.prerendering && !prerender) {
    if (state.depth > 0) {
      throw new Error(`${event.route.id} is not prerenderable`);
    } else {
      return new Response(void 0, { status: 204 });
    }
  }
  try {
    let response = await handler(
      /** @type {import('@sveltejs/kit').RequestEvent<Record<string, any>>} */
      event
    );
    if (!(response instanceof Response)) {
      throw new Error(
        `Invalid response from route ${event.url.pathname}: handler should return a Response object`
      );
    }
    if (state.prerendering) {
      response = new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers(response.headers)
      });
      response.headers.set("x-sveltekit-prerender", String(prerender));
    }
    return response;
  } catch (e) {
    if (e instanceof Redirect) {
      return new Response(void 0, {
        status: e.status,
        headers: { location: e.location }
      });
    }
    throw e;
  }
}
function is_endpoint_request(event) {
  const { method, headers } = event.request;
  if (ENDPOINT_METHODS.has(method) && !PAGE_METHODS.has(method)) {
    return true;
  }
  if (method === "POST" && headers.get("x-sveltekit-action") === "true")
    return false;
  const accept = event.request.headers.get("accept") ?? "*/*";
  return negotiate(accept, ["*", "text/html"]) !== "text/html";
}
function compact(arr) {
  return arr.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore")
    return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && !path.endsWith("/")) {
    return path + "/";
  }
  return path;
}
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
function decode_params(params) {
  for (const key22 in params) {
    params[key22] = decodeURIComponent(params[key22]);
  }
  return params;
}
var tracked_url_properties = (
  /** @type {const} */
  [
    "href",
    "pathname",
    "search",
    "searchParams",
    "toString",
    "toJSON"
  ]
);
function make_trackable(url, callback) {
  const tracked = new URL(url);
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return url[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  {
    tracked[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url, opts);
    };
  }
  disable_hash(tracked);
  return tracked;
}
function disable_hash(url) {
  allow_nodejs_console_log(url);
  Object.defineProperty(url, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `$page.url.hash` inside a component instead"
      );
    }
  });
}
function disable_search(url) {
  allow_nodejs_console_log(url);
  for (const property of ["search", "searchParams"]) {
    Object.defineProperty(url, property, {
      get() {
        throw new Error(`Cannot access url.${property} on a page with prerendering enabled`);
      }
    });
  }
}
function allow_nodejs_console_log(url) {
  {
    url[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(new URL(url), opts);
    };
  }
}
var DATA_SUFFIX = "/__data.json";
function has_data_suffix(pathname) {
  return pathname.endsWith(DATA_SUFFIX);
}
function add_data_suffix(pathname) {
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
function strip_data_suffix(pathname) {
  return pathname.slice(0, -DATA_SUFFIX.length);
}
var escaped = {
  "<": "\\u003C",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var DevalueError = class extends Error {
  /**
   * @param {string} message
   * @param {string[]} keys
   */
  constructor(message, keys2) {
    super(message);
    this.name = "DevalueError";
    this.path = keys2.join("");
  }
};
function is_primitive(thing) {
  return Object(thing) !== thing;
}
var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i2 = 0; i2 < len; i2 += 1) {
    const char = str[i2];
    const replacement2 = get_escaped_char(char);
    if (replacement2) {
      result += str.slice(last_pos, i2) + replacement2;
      last_pos = i2 + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
var chars$1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys2 = [];
  const custom2 = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys2);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing);
        if (typeof str2 === "string") {
          custom2.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach((value2, i2) => {
            keys2.push(`[${i2}]`);
            walk(value2);
            keys2.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key22, value2] of thing) {
            keys2.push(
              `.get(${is_primitive(key22) ? stringify_primitive$1(key22) : "..."})`
            );
            walk(value2);
            keys2.pop();
          }
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys2
            );
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys2
            );
          }
          for (const key22 in thing) {
            keys2.push(`.${key22}`);
            walk(thing[key22]);
            keys2.pop();
          }
      }
    }
  }
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a2, b) => b[1] - a2[1]).forEach((entry, i2) => {
    names.set(entry[0], get_name(i2));
  });
  function stringify2(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive$1(thing);
    }
    if (custom2.has(thing)) {
      return custom2.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify2(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v, i2) => i2 in thing ? stringify2(v) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify2).join(",")}])`;
      default:
        const obj = `{${Object.keys(thing).map((key22) => `${safe_key(key22)}:${stringify2(thing[key22])}`).join(",")}}`;
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? `Object.assign(Object.create(null),${obj})` : `Object.create(null)`;
        }
        return obj;
    }
  }
  const str = stringify2(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values = [];
    names.forEach((name3, thing) => {
      params.push(name3);
      if (custom2.has(thing)) {
        values.push(
          /** @type {string} */
          custom2.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive$1(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify2(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v, i2) => {
            statements.push(`${name3}[${i2}]=${stringify2(v)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name3}.${Array.from(thing).map((v) => `add(${stringify2(v)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name3}.${Array.from(thing).map(([k, v]) => `set(${stringify2(k)}, ${stringify2(v)})`).join(".")}`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key22) => {
            statements.push(
              `${name3}${safe_prop(key22)}=${stringify2(thing[key22])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
function get_name(num) {
  let name3 = "";
  do {
    name3 = chars$1[num % chars$1.length] + name3;
    num = ~~(num / chars$1.length) - 1;
  } while (num >= 0);
  return reserved.test(name3) ? `${name3}0` : name3;
}
function escape_unsafe_char(c) {
  return escaped[c] || c;
}
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
function safe_key(key22) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key22) ? key22 : escape_unsafe_chars(JSON.stringify(key22));
}
function safe_prop(key22) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key22) ? `.${key22}` : `[${escape_unsafe_chars(JSON.stringify(key22))}]`;
}
function stringify_primitive$1(thing) {
  if (typeof thing === "string")
    return stringify_string(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  const str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint")
    return thing + "n";
  return str;
}
var UNDEFINED = -1;
var HOLE = -2;
var NAN = -3;
var POSITIVE_INFINITY = -4;
var NEGATIVE_INFINITY = -5;
var NEGATIVE_ZERO = -6;
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  for (const key22 in reducers) {
    custom2.push({ key: key22, fn: reducers[key22] });
  }
  const keys2 = [];
  let p2 = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys2);
    }
    if (indexes.has(thing))
      return indexes.get(thing);
    if (thing === void 0)
      return UNDEFINED;
    if (Number.isNaN(thing))
      return NAN;
    if (thing === Infinity)
      return POSITIVE_INFINITY;
    if (thing === -Infinity)
      return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0)
      return NEGATIVE_ZERO;
    const index22 = p2++;
    indexes.set(thing, index22);
    for (const { key: key22, fn } of custom2) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index22] = `["${key22}",${flatten(value2)}]`;
        return index22;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          str = `["Date","${thing.toISOString()}"]`;
          break;
        case "RegExp":
          const { source: source2, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source2)},"${flags}"]` : `["RegExp",${stringify_string(source2)}]`;
          break;
        case "Array":
          str = "[";
          for (let i2 = 0; i2 < thing.length; i2 += 1) {
            if (i2 > 0)
              str += ",";
            if (i2 in thing) {
              keys2.push(`[${i2}]`);
              str += flatten(thing[i2]);
              keys2.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key22, value2] of thing) {
            keys2.push(
              `.get(${is_primitive(key22) ? stringify_primitive(key22) : "..."})`
            );
            str += `,${flatten(key22)},${flatten(value2)}`;
          }
          str += "]";
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys2
            );
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys2
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key22 in thing) {
              keys2.push(`.${key22}`);
              str += `,${stringify_string(key22)},${flatten(thing[key22])}`;
              keys2.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key22 in thing) {
              if (started)
                str += ",";
              started = true;
              keys2.push(`.${key22}`);
              str += `${stringify_string(key22)}:${flatten(thing[key22])}`;
              keys2.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index22] = str;
    return index22;
  }
  const index8 = flatten(value);
  if (index8 < 0)
    return `${index8}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive(thing) {
  const type = typeof thing;
  if (type === "string")
    return stringify_string(thing);
  if (thing instanceof String)
    return stringify_string(thing.toString());
  if (thing === void 0)
    return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0)
    return NEGATIVE_ZERO.toString();
  if (type === "bigint")
    return `["BigInt","${thing}"]`;
  return String(thing);
}
function is_action_json_request(event) {
  const accept = negotiate(event.request.headers.get("accept") ?? "*/*", [
    "application/json",
    "text/html"
  ]);
  return accept === "application/json" && event.request.method === "POST";
}
async function handle_action_json_request(event, options2, server2) {
  const actions4 = server2?.actions;
  if (!actions4) {
    const no_actions_error = error(405, "POST method not allowed. No actions exist for this page");
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, no_actions_error)
      },
      {
        status: no_actions_error.status,
        headers: {
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
          // "The server must generate an Allow header field in a 405 status code response"
          allow: "GET"
        }
      }
    );
  }
  check_named_default_separate(actions4);
  try {
    const data = await call_action(event, actions4);
    if (false)
      ;
    if (data instanceof ActionFailure) {
      return action_json({
        type: "failure",
        status: data.status,
        // @ts-expect-error we assign a string to what is supposed to be an object. That's ok
        // because we don't use the object outside, and this way we have better code navigation
        // through knowing where the related interface is used.
        data: stringify_action_response(
          data.data,
          /** @type {string} */
          event.route.id
        )
      });
    } else {
      return action_json({
        type: "success",
        status: data ? 200 : 204,
        // @ts-expect-error see comment above
        data: stringify_action_response(
          data,
          /** @type {string} */
          event.route.id
        )
      });
    }
  } catch (e) {
    const err = normalize_error(e);
    if (err instanceof Redirect) {
      return action_json_redirect(err);
    }
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, check_incorrect_fail_use(err))
      },
      {
        status: err instanceof HttpError ? err.status : 500
      }
    );
  }
}
function check_incorrect_fail_use(error22) {
  return error22 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : error22;
}
function action_json_redirect(redirect2) {
  return action_json({
    type: "redirect",
    status: redirect2.status,
    location: redirect2.location
  });
}
function action_json(data, init22) {
  return json(data, init22);
}
function is_action_request(event) {
  return event.request.method === "POST";
}
async function handle_action_request(event, server2) {
  const actions4 = server2?.actions;
  if (!actions4) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: error(405, "POST method not allowed. No actions exist for this page")
    };
  }
  check_named_default_separate(actions4);
  try {
    const data = await call_action(event, actions4);
    if (false)
      ;
    if (data instanceof ActionFailure) {
      return {
        type: "failure",
        status: data.status,
        data: data.data
      };
    } else {
      return {
        type: "success",
        status: 200,
        // @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission
        data
      };
    }
  } catch (e) {
    const err = normalize_error(e);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
function check_named_default_separate(actions4) {
  if (actions4.default && Object.keys(actions4).length > 1) {
    throw new Error(
      "When using named actions, the default action cannot be used. See the docs for more info: https://kit.svelte.dev/docs/form-actions#named-actions"
    );
  }
}
async function call_action(event, actions4) {
  const url = new URL(event.request.url);
  let name3 = "default";
  for (const param2 of url.searchParams) {
    if (param2[0].startsWith("/")) {
      name3 = param2[0].slice(1);
      if (name3 === "default") {
        throw new Error('Cannot use reserved action name "default"');
      }
      break;
    }
  }
  const action = actions4[name3];
  if (!action) {
    throw new Error(`No action with name '${name3}' found`);
  }
  if (!is_form_content_type(event.request)) {
    throw new Error(
      `Actions expect form-encoded data (received ${event.request.headers.get("content-type")})`
    );
  }
  return action(event);
}
function uneval_action_response(data, route_id) {
  return try_deserialize(data, uneval, route_id);
}
function stringify_action_response(data, route_id) {
  return try_deserialize(data, stringify, route_id);
}
function try_deserialize(data, fn, route_id) {
  try {
    return fn(data);
  } catch (e) {
    const error22 = (
      /** @type {any} */
      e
    );
    if ("path" in error22) {
      let message = `Data returned from action inside ${route_id} is not serializable: ${error22.message}`;
      if (error22.path !== "")
        message += ` (data.${error22.path})`;
      throw new Error(message);
    }
    throw error22;
  }
}
async function unwrap_promises(object) {
  for (const key22 in object) {
    if (typeof object[key22]?.then === "function") {
      return Object.fromEntries(
        await Promise.all(Object.entries(object).map(async ([key3, value]) => [key3, await value]))
      );
    }
  }
  return object;
}
var INVALIDATED_PARAM = "x-sveltekit-invalidated";
var TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
async function load_server_data({
  event,
  state,
  node,
  parent,
  // TODO 2.0: Remove this
  track_server_fetches
}) {
  if (!node?.server)
    return null;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false
  };
  const url = make_trackable(event.url, () => {
    uses.url = true;
  });
  if (state.prerendering) {
    disable_search(url);
  }
  const result = await node.server.load?.call(null, {
    ...event,
    fetch: (info, init22) => {
      const url2 = new URL(info instanceof Request ? info.url : info, event.url);
      if (track_server_fetches) {
        uses.dependencies.add(url2.href);
      }
      return event.fetch(info, init22);
    },
    /** @param {string[]} deps */
    depends: (...deps) => {
      for (const dep of deps) {
        const { href } = new URL(dep, event.url);
        uses.dependencies.add(href);
      }
    },
    params: new Proxy(event.params, {
      get: (target, key22) => {
        uses.params.add(key22);
        return target[
          /** @type {string} */
          key22
        ];
      }
    }),
    parent: async () => {
      uses.parent = true;
      return parent();
    },
    route: new Proxy(event.route, {
      get: (target, key22) => {
        uses.route = true;
        return target[
          /** @type {'id'} */
          key22
        ];
      }
    }),
    url
  });
  const data = result ? await unwrap_promises(result) : null;
  return {
    type: "data",
    data,
    uses,
    slash: node.server.trailingSlash
  };
}
async function load_data({
  event,
  fetched,
  node,
  parent,
  server_data_promise,
  state,
  resolve_opts,
  csr
}) {
  const server_data_node = await server_data_promise;
  if (!node?.universal?.load) {
    return server_data_node?.data ?? null;
  }
  const result = await node.universal.load.call(null, {
    url: event.url,
    params: event.params,
    data: server_data_node?.data ?? null,
    route: event.route,
    fetch: create_universal_fetch(event, state, fetched, csr, resolve_opts),
    setHeaders: event.setHeaders,
    depends: () => {
    },
    parent
  });
  const data = result ? await unwrap_promises(result) : null;
  return data;
}
function create_universal_fetch(event, state, fetched, csr, resolve_opts) {
  return async (input, init22) => {
    const cloned_body = input instanceof Request && input.body ? input.clone().body : null;
    const cloned_headers = input instanceof Request && [...input.headers].length ? new Headers(input.headers) : init22?.headers;
    let response = await event.fetch(input, init22);
    const url = new URL(input instanceof Request ? input.url : input, event.url);
    const same_origin = url.origin === event.url.origin;
    let dependency;
    if (same_origin) {
      if (state.prerendering) {
        dependency = { response, body: null };
        state.prerendering.dependencies.set(url.pathname, dependency);
      }
    } else {
      const mode = input instanceof Request ? input.mode : init22?.mode ?? "cors";
      if (mode === "no-cors") {
        response = new Response("", {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } else {
        const acao = response.headers.get("access-control-allow-origin");
        if (!acao || acao !== event.url.origin && acao !== "*") {
          throw new Error(
            `CORS error: ${acao ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`
          );
        }
      }
    }
    const proxy = new Proxy(response, {
      get(response2, key22, _receiver) {
        async function text22() {
          const body = await response2.text();
          if (!body || typeof body === "string") {
            const status_number = Number(response2.status);
            if (isNaN(status_number)) {
              throw new Error(
                `response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`
              );
            }
            fetched.push({
              url: same_origin ? url.href.slice(event.url.origin.length) : url.href,
              method: event.request.method,
              request_body: (
                /** @type {string | ArrayBufferView | undefined} */
                input instanceof Request && cloned_body ? await stream_to_string(cloned_body) : init22?.body
              ),
              request_headers: cloned_headers,
              response_body: body,
              response: response2
            });
          }
          if (dependency) {
            dependency.body = body;
          }
          return body;
        }
        if (key22 === "arrayBuffer") {
          return async () => {
            const buffer = await response2.arrayBuffer();
            if (dependency) {
              dependency.body = new Uint8Array(buffer);
            }
            return buffer;
          };
        }
        if (key22 === "text") {
          return text22;
        }
        if (key22 === "json") {
          return async () => {
            return JSON.parse(await text22());
          };
        }
        return Reflect.get(response2, key22, response2);
      }
    });
    if (csr) {
      const get4 = response.headers.get;
      response.headers.get = (key22) => {
        const lower = key22.toLowerCase();
        const value = get4.call(response.headers, lower);
        if (value && !lower.startsWith("x-sveltekit-")) {
          const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
          if (!included) {
            throw new Error(
              `Failed to get response header "${lower}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://kit.svelte.dev/docs/hooks#server-hooks-handle (at ${event.route.id})`
            );
          }
        }
        return value;
      };
    }
    return proxy;
  };
}
async function stream_to_string(stream) {
  let result = "";
  const reader = stream.getReader();
  const decoder2 = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += decoder2.decode(value);
  }
  return result;
}
function hash(...values) {
  let hash2 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i2 = value.length;
      while (i2)
        hash2 = hash2 * 33 ^ value.charCodeAt(--i2);
    } else if (ArrayBuffer.isView(value)) {
      const buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i2 = buffer.length;
      while (i2)
        hash2 = hash2 * 33 ^ buffer[--i2];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash2 >>> 0).toString(36);
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(
  // special characters
  `[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`,
  "g"
);
function escape_html_attr(str) {
  const escaped_str = str.replace(escape_html_attr_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
var replacements = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var pattern = new RegExp(`[${Object.keys(replacements).join("")}]`, "g");
function serialize_data(fetched, filter, prerendering = false) {
  const headers = {};
  let cache_control = null;
  let age = null;
  let varyAny = false;
  for (const [key22, value] of fetched.response.headers) {
    if (filter(key22, value)) {
      headers[key22] = value;
    }
    if (key22 === "cache-control")
      cache_control = value;
    else if (key22 === "age")
      age = value;
    else if (key22 === "vary" && value.trim() === "*")
      varyAny = true;
  }
  const payload = {
    status: fetched.response.status,
    statusText: fetched.response.statusText,
    headers,
    body: fetched.response_body
  };
  const safe_payload = JSON.stringify(payload).replace(pattern, (match) => replacements[match]);
  const attrs = [
    'type="application/json"',
    "data-sveltekit-fetched",
    `data-url=${escape_html_attr(fetched.url)}`
  ];
  if (fetched.request_headers || fetched.request_body) {
    const values = [];
    if (fetched.request_headers) {
      values.push([...new Headers(fetched.request_headers)].join(","));
    }
    if (fetched.request_body) {
      values.push(fetched.request_body);
    }
    attrs.push(`data-hash="${hash(...values)}"`);
  }
  if (!prerendering && fetched.method === "GET" && cache_control && !varyAny) {
    const match = /s-maxage=(\d+)/g.exec(cache_control) ?? /max-age=(\d+)/g.exec(cache_control);
    if (match) {
      const ttl = +match[1] - +(age ?? "0");
      attrs.push(`data-ttl="${ttl}"`);
    }
  }
  return `<script ${attrs.join(" ")}>${safe_payload}<\/script>`;
}
var s = JSON.stringify;
var encoder$2 = new TextEncoder();
function sha256(data) {
  if (!key2[0])
    precompute();
  const out = init.slice(0);
  const array2 = encode$1(data);
  for (let i2 = 0; i2 < array2.length; i2 += 16) {
    const w = array2.subarray(i2, i2 + 16);
    let tmp;
    let a2;
    let b;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w[i22];
      } else {
        a2 = w[i22 + 1 & 15];
        b = w[i22 + 14 & 15];
        tmp = w[i22 & 15] = (a2 >>> 7 ^ a2 >>> 18 ^ a2 >>> 3 ^ a2 << 25 ^ a2 << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i22 & 15] + w[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key2[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes2 = new Uint8Array(out.buffer);
  reverse_endianness(bytes2);
  return base64(bytes2);
}
var init = new Uint32Array(8);
var key2 = new Uint32Array(64);
function precompute() {
  function frac(x2) {
    return (x2 - Math.floor(x2)) * 4294967296;
  }
  let prime = 2;
  for (let i2 = 0; i2 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i2 < 8) {
        init[i2] = frac(prime ** (1 / 2));
      }
      key2[i2] = frac(prime ** (1 / 3));
      i2++;
    }
  }
}
function reverse_endianness(bytes2) {
  for (let i2 = 0; i2 < bytes2.length; i2 += 4) {
    const a2 = bytes2[i2 + 0];
    const b = bytes2[i2 + 1];
    const c = bytes2[i2 + 2];
    const d = bytes2[i2 + 3];
    bytes2[i2 + 0] = d;
    bytes2[i2 + 1] = c;
    bytes2[i2 + 2] = b;
    bytes2[i2 + 3] = a2;
  }
}
function encode$1(str) {
  const encoded = encoder$2.encode(str);
  const length = encoded.length * 8;
  const size2 = 512 * Math.ceil((length + 65) / 512);
  const bytes2 = new Uint8Array(size2 / 8);
  bytes2.set(encoded);
  bytes2[encoded.length] = 128;
  reverse_endianness(bytes2);
  const words = new Uint32Array(bytes2.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base64(bytes2) {
  const l2 = bytes2.length;
  let result = "";
  let i2;
  for (i2 = 2; i2 < l2; i2 += 3) {
    result += chars[bytes2[i2 - 2] >> 2];
    result += chars[(bytes2[i2 - 2] & 3) << 4 | bytes2[i2 - 1] >> 4];
    result += chars[(bytes2[i2 - 1] & 15) << 2 | bytes2[i2] >> 6];
    result += chars[bytes2[i2] & 63];
  }
  if (i2 === l2 + 1) {
    result += chars[bytes2[i2 - 2] >> 2];
    result += chars[(bytes2[i2 - 2] & 3) << 4];
    result += "==";
  }
  if (i2 === l2) {
    result += chars[bytes2[i2 - 2] >> 2];
    result += chars[(bytes2[i2 - 2] & 3) << 4 | bytes2[i2 - 1] >> 4];
    result += chars[(bytes2[i2 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
var array = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array);
  return base64(array);
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample",
  "wasm-unsafe-eval",
  "script"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var _use_hashes, _script_needs_csp, _style_needs_csp, _directives, _script_src, _style_src, _nonce;
var BaseProvider = class {
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    /** @type {boolean} */
    __privateAdd(this, _use_hashes, void 0);
    /** @type {boolean} */
    __privateAdd(this, _script_needs_csp, void 0);
    /** @type {boolean} */
    __privateAdd(this, _style_needs_csp, void 0);
    /** @type {import('types').CspDirectives} */
    __privateAdd(this, _directives, void 0);
    /** @type {import('types').Csp.Source[]} */
    __privateAdd(this, _script_src, void 0);
    /** @type {import('types').Csp.Source[]} */
    __privateAdd(this, _style_src, void 0);
    /** @type {string} */
    __privateAdd(this, _nonce, void 0);
    __privateSet(this, _use_hashes, use_hashes);
    __privateSet(this, _directives, directives);
    const d = __privateGet(this, _directives);
    __privateSet(this, _script_src, []);
    __privateSet(this, _style_src, []);
    const effective_script_src = d["script-src"] || d["default-src"];
    const effective_style_src = d["style-src"] || d["default-src"];
    __privateSet(this, _script_needs_csp, !!effective_script_src && effective_script_src.filter((value) => value !== "unsafe-inline").length > 0);
    __privateSet(this, _style_needs_csp, !!effective_style_src && effective_style_src.filter((value) => value !== "unsafe-inline").length > 0);
    this.script_needs_nonce = __privateGet(this, _script_needs_csp) && !__privateGet(this, _use_hashes);
    this.style_needs_nonce = __privateGet(this, _style_needs_csp) && !__privateGet(this, _use_hashes);
    __privateSet(this, _nonce, nonce);
  }
  /** @param {string} content */
  add_script(content) {
    if (__privateGet(this, _script_needs_csp)) {
      if (__privateGet(this, _use_hashes)) {
        __privateGet(this, _script_src).push(`sha256-${sha256(content)}`);
      } else if (__privateGet(this, _script_src).length === 0) {
        __privateGet(this, _script_src).push(`nonce-${__privateGet(this, _nonce)}`);
      }
    }
  }
  /** @param {string} content */
  add_style(content) {
    if (__privateGet(this, _style_needs_csp)) {
      if (__privateGet(this, _use_hashes)) {
        __privateGet(this, _style_src).push(`sha256-${sha256(content)}`);
      } else if (__privateGet(this, _style_src).length === 0) {
        __privateGet(this, _style_src).push(`nonce-${__privateGet(this, _nonce)}`);
      }
    }
  }
  /**
   * @param {boolean} [is_meta]
   */
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...__privateGet(this, _directives) };
    if (__privateGet(this, _style_src).length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...__privateGet(this, _style_src)
      ];
    }
    if (__privateGet(this, _script_src).length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...__privateGet(this, _script_src)
      ];
    }
    for (const key22 in directives) {
      if (is_meta && (key22 === "frame-ancestors" || key22 === "report-uri" || key22 === "sandbox")) {
        continue;
      }
      const value = (
        /** @type {string[] | true} */
        directives[key22]
      );
      if (!value)
        continue;
      const directive = [key22];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
};
_use_hashes = new WeakMap();
_script_needs_csp = new WeakMap();
_style_needs_csp = new WeakMap();
_directives = new WeakMap();
_script_src = new WeakMap();
_style_src = new WeakMap();
_nonce = new WeakMap();
var CspProvider = class extends BaseProvider {
  get_meta() {
    const content = this.get_header(true);
    if (!content) {
      return;
    }
    return `<meta http-equiv="content-security-policy" content=${escape_html_attr(content)}>`;
  }
};
var CspReportOnlyProvider = class extends BaseProvider {
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    super(use_hashes, directives, nonce);
    if (Object.values(directives).filter((v) => !!v).length > 0) {
      const has_report_to = directives["report-to"]?.length ?? 0 > 0;
      const has_report_uri = directives["report-uri"]?.length ?? 0 > 0;
      if (!has_report_to && !has_report_uri) {
        throw Error(
          "`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both"
        );
      }
    }
  }
};
var Csp = class {
  /**
   * @param {import('./types').CspConfig} config
   * @param {import('./types').CspOpts} opts
   */
  constructor({ mode, directives, reportOnly }, { prerender }) {
    /** @readonly */
    __publicField(this, "nonce", generate_nonce());
    /** @type {CspProvider} */
    __publicField(this, "csp_provider");
    /** @type {CspReportOnlyProvider} */
    __publicField(this, "report_only_provider");
    const use_hashes = mode === "hash" || mode === "auto" && prerender;
    this.csp_provider = new CspProvider(use_hashes, directives, this.nonce);
    this.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  /** @param {string} content */
  add_script(content) {
    this.csp_provider.add_script(content);
    this.report_only_provider.add_script(content);
  }
  /** @param {string} content */
  add_style(content) {
    this.csp_provider.add_style(content);
    this.report_only_provider.add_style(content);
  }
};
function defer() {
  let fulfil;
  let reject;
  const promise = new Promise((f, r2) => {
    fulfil = f;
    reject = r2;
  });
  return { promise, fulfil, reject };
}
function create_async_iterator() {
  const deferred = [defer()];
  return {
    iterator: {
      [Symbol.asyncIterator]() {
        return {
          next: async () => {
            const next = await deferred[0].promise;
            if (!next.done)
              deferred.shift();
            return next;
          }
        };
      }
    },
    push: (value) => {
      deferred[deferred.length - 1].fulfil({
        value,
        done: false
      });
      deferred.push(defer());
    },
    done: () => {
      deferred[deferred.length - 1].fulfil({ done: true });
    }
  };
}
var updated = {
  ...readable(false),
  check: () => false
};
var encoder$1 = new TextEncoder();
async function render_response({
  branch,
  fetched,
  options: options2,
  manifest: manifest2,
  state,
  page_config,
  status,
  error: error22 = null,
  event,
  resolve_opts,
  action_result
}) {
  if (state.prerendering) {
    if (options2.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options2.app_template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const { client } = manifest2._;
  const modulepreloads = new Set(client.imports);
  const stylesheets8 = new Set(client.stylesheets);
  const fonts8 = new Set(client.fonts);
  const link_header_preloads = /* @__PURE__ */ new Set();
  const inline_styles = /* @__PURE__ */ new Map();
  let rendered;
  const form_value = action_result?.type === "success" || action_result?.type === "failure" ? action_result.data ?? null : null;
  let base$1 = base;
  let assets$1 = assets;
  let base_expression = s(base);
  if (!state.prerendering?.fallback) {
    const segments = event.url.pathname.slice(base.length).split("/").slice(2);
    base$1 = segments.map(() => "..").join("/") || ".";
    base_expression = `new URL(${s(base$1)}, location).pathname.slice(0, -1)`;
    if (!assets || assets[0] === "/" && assets !== SVELTE_KIT_ASSETS) {
      assets$1 = base$1;
    }
  }
  if (page_config.ssr) {
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        updated
      },
      constructors: await Promise.all(branch.map(({ node }) => node.component())),
      form: form_value
    };
    let data2 = {};
    for (let i2 = 0; i2 < branch.length; i2 += 1) {
      data2 = { ...data2, ...branch[i2].data };
      props[`data_${i2}`] = data2;
    }
    props.page = {
      error: error22,
      params: (
        /** @type {Record<string, any>} */
        event.params
      ),
      route: event.route,
      status,
      url: event.url,
      data: data2,
      form: form_value
    };
    {
      try {
        rendered = options2.root.render(props);
      } finally {
        reset();
      }
    }
    for (const { node } of branch) {
      for (const url of node.imports)
        modulepreloads.add(url);
      for (const url of node.stylesheets)
        stylesheets8.add(url);
      for (const url of node.fonts)
        fonts8.add(url);
      if (node.inline_styles) {
        Object.entries(await node.inline_styles()).forEach(([k, v]) => inline_styles.set(k, v));
      }
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let head = "";
  let body = rendered.html;
  const csp = new Csp(options2.csp, {
    prerender: !!state.prerendering
  });
  const prefixed = (path) => {
    if (path.startsWith("/")) {
      return base + path;
    }
    return `${assets$1}/${path}`;
  };
  if (inline_styles.size > 0) {
    const content = Array.from(inline_styles.values()).join("\n");
    const attributes = [];
    if (csp.style_needs_nonce)
      attributes.push(` nonce="${csp.nonce}"`);
    csp.add_style(content);
    head += `
	<style${attributes.join("")}>${content}</style>`;
  }
  for (const dep of stylesheets8) {
    const path = prefixed(dep);
    const attributes = ['rel="stylesheet"'];
    if (inline_styles.has(dep)) {
      attributes.push("disabled", 'media="(max-width: 0)"');
    } else {
      if (resolve_opts.preload({ type: "css", path })) {
        const preload_atts = ['rel="preload"', 'as="style"'];
        link_header_preloads.add(`<${encodeURI(path)}>; ${preload_atts.join(";")}; nopush`);
      }
    }
    head += `
		<link href="${path}" ${attributes.join(" ")}>`;
  }
  for (const dep of fonts8) {
    const path = prefixed(dep);
    if (resolve_opts.preload({ type: "font", path })) {
      const ext = dep.slice(dep.lastIndexOf(".") + 1);
      const attributes = [
        'rel="preload"',
        'as="font"',
        `type="font/${ext}"`,
        `href="${path}"`,
        "crossorigin"
      ];
      head += `
		<link ${attributes.join(" ")}>`;
    }
  }
  const global2 = `__sveltekit_${options2.version_hash}`;
  const { data, chunks } = get_data(
    event,
    options2,
    branch.map((b) => b.server_data),
    global2
  );
  if (page_config.ssr && page_config.csr) {
    body += `
			${fetched.map(
      (item) => serialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state.prerendering)
    ).join("\n			")}`;
  }
  if (page_config.csr) {
    const included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(
      (path) => resolve_opts.preload({ type: "js", path })
    );
    for (const path of included_modulepreloads) {
      link_header_preloads.add(`<${encodeURI(path)}>; rel="modulepreload"; nopush`);
      if (options2.preload_strategy !== "modulepreload") {
        head += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${path}">`;
      } else if (state.prerendering) {
        head += `
		<link rel="modulepreload" href="${path}">`;
      }
    }
    const blocks = [];
    const properties = [
      assets && `assets: ${s(assets)}`,
      `base: ${base_expression}`,
      `env: ${s(public_env)}`
    ].filter(Boolean);
    if (chunks) {
      blocks.push("const deferred = new Map();");
      properties.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      properties.push(`resolve: ({ id, data, error }) => {
							const { fulfil, reject } = deferred.get(id);
							deferred.delete(id);

							if (error) reject(error);
							else fulfil(data);
						}`);
    }
    blocks.push(`${global2} = {
						${properties.join(",\n						")}
					};`);
    const args = ["app", "element"];
    blocks.push("const element = document.currentScript.parentElement;");
    if (page_config.ssr) {
      const serialized = { form: "null", error: "null" };
      blocks.push(`const data = ${data};`);
      if (form_value) {
        serialized.form = uneval_action_response(
          form_value,
          /** @type {string} */
          event.route.id
        );
      }
      if (error22) {
        serialized.error = uneval(error22);
      }
      const hydrate = [
        `node_ids: [${branch.map(({ node }) => node.index).join(", ")}]`,
        "data",
        `form: ${serialized.form}`,
        `error: ${serialized.error}`
      ];
      if (status !== 200) {
        hydrate.push(`status: ${status}`);
      }
      if (options2.embedded) {
        hydrate.push(`params: ${uneval(event.params)}`, `route: ${s(event.route)}`);
      }
      args.push(`{
							${hydrate.join(",\n							")}
						}`);
    }
    blocks.push(`Promise.all([
						import(${s(prefixed(client.start))}),
						import(${s(prefixed(client.app))})
					]).then(([kit, app]) => {
						kit.start(${args.join(", ")});
					});`);
    if (options2.service_worker) {
      const opts = "";
      blocks.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${prefixed("service-worker.js")}'${opts});
						});
					}`);
    }
    const init_app = `
				{
					${blocks.join("\n\n					")}
				}
			`;
    csp.add_script(init_app);
    body += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_app}<\/script>
		`;
  }
  const headers = new Headers({
    "x-sveltekit-page": "true",
    "content-type": "text/html"
  });
  if (state.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.csp_provider.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (state.prerendering.cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="${state.prerendering.cache}">`);
    }
    if (http_equiv.length > 0) {
      head = http_equiv.join("\n") + head;
    }
  } else {
    const csp_header = csp.csp_provider.get_header();
    if (csp_header) {
      headers.set("content-security-policy", csp_header);
    }
    const report_only_header = csp.report_only_provider.get_header();
    if (report_only_header) {
      headers.set("content-security-policy-report-only", report_only_header);
    }
    if (link_header_preloads.size) {
      headers.set("link", Array.from(link_header_preloads).join(", "));
    }
  }
  head += rendered.head;
  const html = options2.templates.app({
    head,
    body,
    assets: assets$1,
    nonce: (
      /** @type {string} */
      csp.nonce
    ),
    env: public_env
  });
  const transformed = await resolve_opts.transformPageChunk({
    html,
    done: true
  }) || "";
  if (!chunks) {
    headers.set("etag", `"${hash(transformed)}"`);
  }
  return !chunks ? text2(transformed, {
    status,
    headers
  }) : new Response(
    new ReadableStream({
      async start(controller) {
        controller.enqueue(encoder$1.encode(transformed + "\n"));
        for await (const chunk of chunks) {
          controller.enqueue(encoder$1.encode(chunk));
        }
        controller.close();
      },
      type: "bytes"
    }),
    {
      headers: {
        "content-type": "text/html"
      }
    }
  );
}
function get_data(event, options2, nodes, global2) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push, done } = create_async_iterator();
  function replacer(thing) {
    if (typeof thing?.then === "function") {
      const id = promise_id++;
      count += 1;
      thing.then(
        /** @param {any} data */
        (data) => ({ data })
      ).catch(
        /** @param {any} error */
        async (error22) => ({
          error: await handle_error_and_jsonify(event, options2, error22)
        })
      ).then(
        /**
         * @param {{data: any; error: any}} result
         */
        async ({ data, error: error22 }) => {
          count -= 1;
          let str;
          try {
            str = uneval({ id, data, error: error22 }, replacer);
          } catch (e) {
            error22 = await handle_error_and_jsonify(
              event,
              options2,
              new Error(`Failed to serialize promise while rendering ${event.route.id}`)
            );
            data = void 0;
            str = uneval({ id, data, error: error22 }, replacer);
          }
          push(`<script>${global2}.resolve(${str})<\/script>
`);
          if (count === 0)
            done();
        }
      );
      return `${global2}.defer(${id})`;
    }
  }
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      return `{"type":"data","data":${uneval(node.data, replacer)},${stringify_uses(node)}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `[${strings.join(",")}]`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e
    ));
  }
}
function get_option(nodes, option) {
  return nodes.reduce(
    (value, node) => {
      return (
        /** @type {Value} TypeScript's too dumb to understand this */
        node?.universal?.[option] ?? node?.server?.[option] ?? value
      );
    },
    /** @type {Value | undefined} */
    void 0
  );
}
async function respond_with_error({
  event,
  options: options2,
  manifest: manifest2,
  state,
  status,
  error: error22,
  resolve_opts
}) {
  const fetched = [];
  try {
    const branch = [];
    const default_layout = await manifest2._.nodes[0]();
    const ssr = get_option([default_layout], "ssr") ?? true;
    const csr = get_option([default_layout], "csr") ?? true;
    if (ssr) {
      state.error = true;
      const server_data_promise = load_server_data({
        event,
        state,
        node: default_layout,
        parent: async () => ({}),
        track_server_fetches: options2.track_server_fetches
      });
      const server_data = await server_data_promise;
      const data = await load_data({
        event,
        fetched,
        node: default_layout,
        parent: async () => ({}),
        resolve_opts,
        server_data_promise,
        state,
        csr
      });
      branch.push(
        {
          node: default_layout,
          server_data,
          data
        },
        {
          node: await manifest2._.nodes[1](),
          // 1 is always the root error
          data: null,
          server_data: null
        }
      );
    }
    return await render_response({
      options: options2,
      manifest: manifest2,
      state,
      page_config: {
        ssr,
        csr: get_option([default_layout], "csr") ?? true
      },
      status,
      error: await handle_error_and_jsonify(event, options2, error22),
      branch,
      fetched,
      event,
      resolve_opts
    });
  } catch (e) {
    if (e instanceof Redirect) {
      return redirect_response(e.status, e.location);
    }
    return static_error_page(
      options2,
      e instanceof HttpError ? e.status : 500,
      (await handle_error_and_jsonify(event, options2, e)).message
    );
  }
}
function once(fn) {
  let done = false;
  let result;
  return () => {
    if (done)
      return result;
    done = true;
    return result = fn();
  };
}
var encoder2 = new TextEncoder();
async function render_data(event, route, options2, manifest2, state, invalidated_data_nodes, trailing_slash) {
  if (!route.page) {
    return new Response(void 0, {
      status: 404
    });
  }
  try {
    const node_ids = [...route.page.layouts, route.page.leaf];
    const invalidated = invalidated_data_nodes ?? node_ids.map(() => true);
    let aborted = false;
    const url = new URL(event.url);
    url.pathname = normalize_path(url.pathname, trailing_slash);
    const new_event = { ...event, url };
    const functions = node_ids.map((n, i2) => {
      return once(async () => {
        try {
          if (aborted) {
            return (
              /** @type {import('types').ServerDataSkippedNode} */
              {
                type: "skip"
              }
            );
          }
          const node = n == void 0 ? n : await manifest2._.nodes[n]();
          return load_server_data({
            event: new_event,
            state,
            node,
            parent: async () => {
              const data2 = {};
              for (let j2 = 0; j2 < i2; j2 += 1) {
                const parent = (
                  /** @type {import('types').ServerDataNode | null} */
                  await functions[j2]()
                );
                if (parent) {
                  Object.assign(data2, parent.data);
                }
              }
              return data2;
            },
            track_server_fetches: options2.track_server_fetches
          });
        } catch (e) {
          aborted = true;
          throw e;
        }
      });
    });
    const promises = functions.map(async (fn, i2) => {
      if (!invalidated[i2]) {
        return (
          /** @type {import('types').ServerDataSkippedNode} */
          {
            type: "skip"
          }
        );
      }
      return fn();
    });
    let length = promises.length;
    const nodes = await Promise.all(
      promises.map(
        (p2, i2) => p2.catch(async (error22) => {
          if (error22 instanceof Redirect) {
            throw error22;
          }
          length = Math.min(length, i2 + 1);
          return (
            /** @type {import('types').ServerErrorNode} */
            {
              type: "error",
              error: await handle_error_and_jsonify(event, options2, error22),
              status: error22 instanceof HttpError ? error22.status : void 0
            }
          );
        })
      )
    );
    const { data, chunks } = get_data_json(event, options2, nodes);
    if (!chunks) {
      return json_response(data);
    }
    return new Response(
      new ReadableStream({
        async start(controller) {
          controller.enqueue(encoder2.encode(data));
          for await (const chunk of chunks) {
            controller.enqueue(encoder2.encode(chunk));
          }
          controller.close();
        },
        type: "bytes"
      }),
      {
        headers: {
          // we use a proprietary content type to prevent buffering.
          // the `text` prefix makes it inspectable
          "content-type": "text/sveltekit-data",
          "cache-control": "private, no-store"
        }
      }
    );
  } catch (e) {
    const error22 = normalize_error(e);
    if (error22 instanceof Redirect) {
      return redirect_json_response(error22);
    } else {
      return json_response(await handle_error_and_jsonify(event, options2, error22), 500);
    }
  }
}
function json_response(json2, status = 200) {
  return text2(typeof json2 === "string" ? json2 : JSON.stringify(json2), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "private, no-store"
    }
  });
}
function redirect_json_response(redirect2) {
  return json_response({
    type: "redirect",
    location: redirect2.location
  });
}
function get_data_json(event, options2, nodes) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push, done } = create_async_iterator();
  const reducers = {
    /** @param {any} thing */
    Promise: (thing) => {
      if (typeof thing?.then === "function") {
        const id = promise_id++;
        count += 1;
        let key22 = "data";
        thing.catch(
          /** @param {any} e */
          async (e) => {
            key22 = "error";
            return handle_error_and_jsonify(
              event,
              options2,
              /** @type {any} */
              e
            );
          }
        ).then(
          /** @param {any} value */
          async (value) => {
            let str;
            try {
              str = stringify(value, reducers);
            } catch (e) {
              const error22 = await handle_error_and_jsonify(
                event,
                options2,
                new Error(`Failed to serialize promise while rendering ${event.route.id}`)
              );
              key22 = "error";
              str = stringify(error22, reducers);
            }
            count -= 1;
            push(`{"type":"chunk","id":${id},"${key22}":${str}}
`);
            if (count === 0)
              done();
          }
        );
        return id;
      }
    }
  };
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      if (node.type === "error" || node.type === "skip") {
        return JSON.stringify(node);
      }
      return `{"type":"data","data":${stringify(node.data, reducers)},${stringify_uses(
        node
      )}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `{"type":"data","nodes":[${strings.join(",")}]}
`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e
    ));
  }
}
var MAX_DEPTH = 10;
async function render_page(event, page2, options2, manifest2, state, resolve_opts) {
  if (state.depth > MAX_DEPTH) {
    return text2(`Not found: ${event.url.pathname}`, {
      status: 404
      // TODO in some cases this should be 500. not sure how to differentiate
    });
  }
  if (is_action_json_request(event)) {
    const node = await manifest2._.nodes[page2.leaf]();
    return handle_action_json_request(event, options2, node?.server);
  }
  try {
    const nodes = await Promise.all([
      // we use == here rather than === because [undefined] serializes as "[null]"
      ...page2.layouts.map((n) => n == void 0 ? n : manifest2._.nodes[n]()),
      manifest2._.nodes[page2.leaf]()
    ]);
    const leaf_node = (
      /** @type {import('types').SSRNode} */
      nodes.at(-1)
    );
    let status = 200;
    let action_result = void 0;
    if (is_action_request(event)) {
      action_result = await handle_action_request(event, leaf_node.server);
      if (action_result?.type === "redirect") {
        return redirect_response(action_result.status, action_result.location);
      }
      if (action_result?.type === "error") {
        const error22 = action_result.error;
        status = error22 instanceof HttpError ? error22.status : 500;
      }
      if (action_result?.type === "failure") {
        status = action_result.status;
      }
    }
    const should_prerender_data = nodes.some((node) => node?.server);
    const data_pathname = add_data_suffix(event.url.pathname);
    const should_prerender = get_option(nodes, "prerender") ?? false;
    if (should_prerender) {
      const mod = leaf_node.server;
      if (mod?.actions) {
        throw new Error("Cannot prerender pages with actions");
      }
    } else if (state.prerendering) {
      return new Response(void 0, {
        status: 204
      });
    }
    state.prerender_default = should_prerender;
    const fetched = [];
    if (get_option(nodes, "ssr") === false) {
      return await render_response({
        branch: [],
        fetched,
        page_config: {
          ssr: false,
          csr: get_option(nodes, "csr") ?? true
        },
        status,
        error: null,
        event,
        options: options2,
        manifest: manifest2,
        state,
        resolve_opts
      });
    }
    const branch = [];
    let load_error = null;
    const server_promises = nodes.map((node, i2) => {
      if (load_error) {
        throw load_error;
      }
      return Promise.resolve().then(async () => {
        try {
          if (node === leaf_node && action_result?.type === "error") {
            throw action_result.error;
          }
          return await load_server_data({
            event,
            state,
            node,
            parent: async () => {
              const data = {};
              for (let j2 = 0; j2 < i2; j2 += 1) {
                const parent = await server_promises[j2];
                if (parent)
                  Object.assign(data, await parent.data);
              }
              return data;
            },
            track_server_fetches: options2.track_server_fetches
          });
        } catch (e) {
          load_error = /** @type {Error} */
          e;
          throw load_error;
        }
      });
    });
    const csr = get_option(nodes, "csr") ?? true;
    const load_promises = nodes.map((node, i2) => {
      if (load_error)
        throw load_error;
      return Promise.resolve().then(async () => {
        try {
          return await load_data({
            event,
            fetched,
            node,
            parent: async () => {
              const data = {};
              for (let j2 = 0; j2 < i2; j2 += 1) {
                Object.assign(data, await load_promises[j2]);
              }
              return data;
            },
            resolve_opts,
            server_data_promise: server_promises[i2],
            state,
            csr
          });
        } catch (e) {
          load_error = /** @type {Error} */
          e;
          throw load_error;
        }
      });
    });
    for (const p2 of server_promises)
      p2.catch(() => {
      });
    for (const p2 of load_promises)
      p2.catch(() => {
      });
    for (let i2 = 0; i2 < nodes.length; i2 += 1) {
      const node = nodes[i2];
      if (node) {
        try {
          const server_data = await server_promises[i2];
          const data = await load_promises[i2];
          branch.push({ node, server_data, data });
        } catch (e) {
          const err = normalize_error(e);
          if (err instanceof Redirect) {
            if (state.prerendering && should_prerender_data) {
              const body = JSON.stringify({
                type: "redirect",
                location: err.location
              });
              state.prerendering.dependencies.set(data_pathname, {
                response: text2(body),
                body
              });
            }
            return redirect_response(err.status, err.location);
          }
          const status2 = err instanceof HttpError ? err.status : 500;
          const error22 = await handle_error_and_jsonify(event, options2, err);
          while (i2--) {
            if (page2.errors[i2]) {
              const index8 = (
                /** @type {number} */
                page2.errors[i2]
              );
              const node2 = await manifest2._.nodes[index8]();
              let j2 = i2;
              while (!branch[j2])
                j2 -= 1;
              return await render_response({
                event,
                options: options2,
                manifest: manifest2,
                state,
                resolve_opts,
                page_config: { ssr: true, csr: true },
                status: status2,
                error: error22,
                branch: compact(branch.slice(0, j2 + 1)).concat({
                  node: node2,
                  data: null,
                  server_data: null
                }),
                fetched
              });
            }
          }
          return static_error_page(options2, status2, error22.message);
        }
      } else {
        branch.push(null);
      }
    }
    if (state.prerendering && should_prerender_data) {
      let { data, chunks } = get_data_json(
        event,
        options2,
        branch.map((node) => node?.server_data)
      );
      if (chunks) {
        for await (const chunk of chunks) {
          data += chunk;
        }
      }
      state.prerendering.dependencies.set(data_pathname, {
        response: text2(data),
        body: data
      });
    }
    return await render_response({
      event,
      options: options2,
      manifest: manifest2,
      state,
      resolve_opts,
      page_config: {
        csr: get_option(nodes, "csr") ?? true,
        ssr: true
      },
      status,
      error: null,
      branch: compact(branch),
      action_result,
      fetched
    });
  } catch (e) {
    return await respond_with_error({
      event,
      options: options2,
      manifest: manifest2,
      state,
      status: 500,
      error: e,
      resolve_opts
    });
  }
}
var parse_1 = parse$1;
var serialize_1 = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$1(str, options2) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options2 || {};
  var dec = opt.decode || decode2;
  var index8 = 0;
  while (index8 < str.length) {
    var eqIdx = str.indexOf("=", index8);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index8);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index8 = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key22 = str.slice(index8, eqIdx).trim();
    if (void 0 === obj[key22]) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key22] = tryDecode2(val, dec);
    }
    index8 = endIdx + 1;
  }
  return obj;
}
function serialize(name3, val, options2) {
  var opt = options2 || {};
  var enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name3)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name3 + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function decode2(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
function encode(val) {
  return encodeURIComponent(val);
}
function isDate(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
function tryDecode2(str, decode22) {
  try {
    return decode22(str);
  } catch (e) {
    return str;
  }
}
function get_cookies(request, url, trailing_slash) {
  const header = request.headers.get("cookie") ?? "";
  const initial_cookies = parse_1(header, { decode: (value) => value });
  const normalized_url = normalize_path(url.pathname, trailing_slash);
  const default_path = normalized_url.split("/").slice(0, -1).join("/") || "/";
  const new_cookies = {};
  const defaults3 = {
    httpOnly: true,
    sameSite: "lax",
    secure: url.hostname === "localhost" && url.protocol === "http:" ? false : true
  };
  const cookies = {
    // The JSDoc param annotations appearing below for get, set and delete
    // are necessary to expose the `cookie` library types to
    // typescript users. `@type {import('@sveltejs/kit').Cookies}` above is not
    // sufficient to do so.
    /**
     * @param {string} name
     * @param {import('cookie').CookieParseOptions} opts
     */
    get(name3, opts) {
      const c = new_cookies[name3];
      if (c && domain_matches(url.hostname, c.options.domain) && path_matches(url.pathname, c.options.path)) {
        return c.value;
      }
      const decoder2 = opts?.decode || decodeURIComponent;
      const req_cookies = parse_1(header, { decode: decoder2 });
      const cookie = req_cookies[name3];
      return cookie;
    },
    /**
     * @param {import('cookie').CookieParseOptions} opts
     */
    getAll(opts) {
      const decoder2 = opts?.decode || decodeURIComponent;
      const cookies2 = parse_1(header, { decode: decoder2 });
      for (const c of Object.values(new_cookies)) {
        if (domain_matches(url.hostname, c.options.domain) && path_matches(url.pathname, c.options.path)) {
          cookies2[c.name] = c.value;
        }
      }
      return Object.entries(cookies2).map(([name3, value]) => ({ name: name3, value }));
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('cookie').CookieSerializeOptions} opts
     */
    set(name3, value, opts = {}) {
      set_internal(name3, value, { ...defaults3, ...opts });
    },
    /**
     * @param {string} name
     * @param {import('cookie').CookieSerializeOptions} opts
     */
    delete(name3, opts = {}) {
      cookies.set(name3, "", {
        ...opts,
        maxAge: 0
      });
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('cookie').CookieSerializeOptions} opts
     */
    serialize(name3, value, opts) {
      return serialize_1(name3, value, {
        ...defaults3,
        ...opts
      });
    }
  };
  function get_cookie_header(destination, header2) {
    const combined_cookies = {
      // cookies sent by the user agent have lowest precedence
      ...initial_cookies
    };
    for (const key22 in new_cookies) {
      const cookie = new_cookies[key22];
      if (!domain_matches(destination.hostname, cookie.options.domain))
        continue;
      if (!path_matches(destination.pathname, cookie.options.path))
        continue;
      const encoder22 = cookie.options.encode || encodeURIComponent;
      combined_cookies[cookie.name] = encoder22(cookie.value);
    }
    if (header2) {
      const parsed = parse_1(header2, { decode: (value) => value });
      for (const name3 in parsed) {
        combined_cookies[name3] = parsed[name3];
      }
    }
    return Object.entries(combined_cookies).map(([name3, value]) => `${name3}=${value}`).join("; ");
  }
  function set_internal(name3, value, opts) {
    const path = opts.path ?? default_path;
    new_cookies[name3] = {
      name: name3,
      value,
      options: {
        ...opts,
        path
      }
    };
  }
  return { cookies, new_cookies, get_cookie_header, set_internal };
}
function domain_matches(hostname, constraint) {
  if (!constraint)
    return true;
  const normalized = constraint[0] === "." ? constraint.slice(1) : constraint;
  if (hostname === normalized)
    return true;
  return hostname.endsWith("." + normalized);
}
function path_matches(path, constraint) {
  if (!constraint)
    return true;
  const normalized = constraint.endsWith("/") ? constraint.slice(0, -1) : constraint;
  if (path === normalized)
    return true;
  return path.startsWith(normalized + "/");
}
function add_cookies_to_headers(headers, cookies) {
  for (const new_cookie of cookies) {
    const { name: name3, value, options: options2 } = new_cookie;
    headers.append("set-cookie", serialize_1(name3, value, options2));
  }
}
var setCookie = { exports: {} };
var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false
};
function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}
function parseString(setCookieValue, options2) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);
  var nameValuePairStr = parts.shift();
  var parsed = parseNameValuePair(nameValuePairStr);
  var name3 = parsed.name;
  var value = parsed.value;
  options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
  try {
    value = options2.decodeValues ? decodeURIComponent(value) : value;
  } catch (e) {
    console.error(
      "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
      e
    );
  }
  var cookie = {
    name: name3,
    value
  };
  parts.forEach(function(part) {
    var sides = part.split("=");
    var key22 = sides.shift().trimLeft().toLowerCase();
    var value2 = sides.join("=");
    if (key22 === "expires") {
      cookie.expires = new Date(value2);
    } else if (key22 === "max-age") {
      cookie.maxAge = parseInt(value2, 10);
    } else if (key22 === "secure") {
      cookie.secure = true;
    } else if (key22 === "httponly") {
      cookie.httpOnly = true;
    } else if (key22 === "samesite") {
      cookie.sameSite = value2;
    } else {
      cookie[key22] = value2;
    }
  });
  return cookie;
}
function parseNameValuePair(nameValuePairStr) {
  var name3 = "";
  var value = "";
  var nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name3 = nameValueArr.shift();
    value = nameValueArr.join("=");
  } else {
    value = nameValuePairStr;
  }
  return { name: name3, value };
}
function parse2(input, options2) {
  options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
  if (!input) {
    if (!options2.map) {
      return [];
    } else {
      return {};
    }
  }
  if (input.headers) {
    if (typeof input.headers.getSetCookie === "function") {
      input = input.headers.getSetCookie();
    } else if (input.headers["set-cookie"]) {
      input = input.headers["set-cookie"];
    } else {
      var sch = input.headers[Object.keys(input.headers).find(function(key22) {
        return key22.toLowerCase() === "set-cookie";
      })];
      if (!sch && input.headers.cookie && !options2.silent) {
        console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        );
      }
      input = sch;
    }
  }
  if (!Array.isArray(input)) {
    input = [input];
  }
  options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
  if (!options2.map) {
    return input.filter(isNonEmptyString).map(function(str) {
      return parseString(str, options2);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
      var cookie = parseString(str, options2);
      cookies2[cookie.name] = cookie;
      return cookies2;
    }, cookies);
  }
}
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;
  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }
  function notSpecialChar() {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  }
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }
  return cookiesStrings;
}
setCookie.exports = parse2;
setCookie.exports.parse = parse2;
var parseString_1 = setCookie.exports.parseString = parseString;
var splitCookiesString_1 = setCookie.exports.splitCookiesString = splitCookiesString;
function create_fetch({ event, options: options2, manifest: manifest2, state, get_cookie_header, set_internal }) {
  return async (info, init22) => {
    const original_request = normalize_fetch_input(info, init22, event.url);
    let mode = (info instanceof Request ? info.mode : init22?.mode) ?? "cors";
    let credentials = (info instanceof Request ? info.credentials : init22?.credentials) ?? "same-origin";
    return await options2.hooks.handleFetch({
      event,
      request: original_request,
      fetch: async (info2, init3) => {
        const request = normalize_fetch_input(info2, init3, event.url);
        const url = new URL(request.url);
        if (!request.headers.has("origin")) {
          request.headers.set("origin", event.url.origin);
        }
        if (info2 !== original_request) {
          mode = (info2 instanceof Request ? info2.mode : init3?.mode) ?? "cors";
          credentials = (info2 instanceof Request ? info2.credentials : init3?.credentials) ?? "same-origin";
        }
        if ((request.method === "GET" || request.method === "HEAD") && (mode === "no-cors" && url.origin !== event.url.origin || url.origin === event.url.origin)) {
          request.headers.delete("origin");
        }
        if (url.origin !== event.url.origin) {
          if (`.${url.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== "omit") {
            const cookie = get_cookie_header(url, request.headers.get("cookie"));
            if (cookie)
              request.headers.set("cookie", cookie);
          }
          return fetch(request);
        }
        const prefix = assets || base;
        const decoded = decodeURIComponent(url.pathname);
        const filename = (decoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = manifest2.assets.has(filename);
        const is_asset_html = manifest2.assets.has(filename_html);
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (state.read) {
            const type = is_asset ? manifest2.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            return new Response(state.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          }
          return await fetch(request);
        }
        if (credentials !== "omit") {
          const cookie = get_cookie_header(url, request.headers.get("cookie"));
          if (cookie) {
            request.headers.set("cookie", cookie);
          }
          const authorization = event.request.headers.get("authorization");
          if (authorization && !request.headers.has("authorization")) {
            request.headers.set("authorization", authorization);
          }
        }
        if (!request.headers.has("accept")) {
          request.headers.set("accept", "*/*");
        }
        if (!request.headers.has("accept-language")) {
          request.headers.set(
            "accept-language",
            /** @type {string} */
            event.request.headers.get("accept-language")
          );
        }
        const response = await respond(request, options2, manifest2, {
          ...state,
          depth: state.depth + 1
        });
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          for (const str of splitCookiesString_1(set_cookie)) {
            const { name: name3, value, ...options3 } = parseString_1(str);
            set_internal(
              name3,
              value,
              /** @type {import('cookie').CookieSerializeOptions} */
              options3
            );
          }
        }
        return response;
      }
    });
  };
}
function normalize_fetch_input(info, init22, url) {
  if (info instanceof Request) {
    return info;
  }
  return new Request(typeof info === "string" ? new URL(info, url) : info, init22);
}
function validator(expected) {
  function validate(module, file) {
    if (!module)
      return;
    for (const key22 in module) {
      if (key22[0] === "_" || expected.has(key22))
        continue;
      const values = [...expected.values()];
      const hint = hint_for_supported_files(key22, file?.slice(file.lastIndexOf("."))) ?? `valid exports are ${values.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${key22}'${file ? ` in ${file}` : ""} (${hint})`);
    }
  }
  return validate;
}
function hint_for_supported_files(key22, ext = ".js") {
  const supported_files = [];
  if (valid_layout_exports.has(key22)) {
    supported_files.push(`+layout${ext}`);
  }
  if (valid_page_exports.has(key22)) {
    supported_files.push(`+page${ext}`);
  }
  if (valid_layout_server_exports.has(key22)) {
    supported_files.push(`+layout.server${ext}`);
  }
  if (valid_page_server_exports.has(key22)) {
    supported_files.push(`+page.server${ext}`);
  }
  if (valid_server_exports.has(key22)) {
    supported_files.push(`+server${ext}`);
  }
  if (supported_files.length > 0) {
    return `'${key22}' is a valid export in ${supported_files.slice(0, -1).join(", ")}${supported_files.length > 1 ? " or " : ""}${supported_files.at(-1)}`;
  }
}
var valid_layout_exports = /* @__PURE__ */ new Set([
  "load",
  "prerender",
  "csr",
  "ssr",
  "trailingSlash",
  "config"
]);
var valid_page_exports = /* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
var valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
var valid_page_server_exports = /* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
var valid_server_exports = /* @__PURE__ */ new Set([
  "GET",
  "POST",
  "PATCH",
  "PUT",
  "DELETE",
  "OPTIONS",
  "HEAD",
  "fallback",
  "prerender",
  "trailingSlash",
  "config",
  "entries"
]);
var validate_layout_exports = validator(valid_layout_exports);
var validate_page_exports = validator(valid_page_exports);
var validate_layout_server_exports = validator(valid_layout_server_exports);
var validate_page_server_exports = validator(valid_page_server_exports);
var validate_server_exports = validator(valid_server_exports);
var default_transform = ({ html }) => html;
var default_filter = () => false;
var default_preload = ({ type }) => type === "js" || type === "css";
var page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var allowed_page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
async function respond(request, options2, manifest2, state) {
  const url = new URL(request.url);
  if (options2.csrf_check_origin) {
    const forbidden = is_form_content_type(request) && (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request.headers.get("origin") !== url.origin;
    if (forbidden) {
      const csrf_error = error(403, `Cross-site ${request.method} form submissions are forbidden`);
      if (request.headers.get("accept") === "application/json") {
        return json(csrf_error.body, { status: csrf_error.status });
      }
      return text2(csrf_error.body.message, { status: csrf_error.status });
    }
  }
  let decoded;
  try {
    decoded = decode_pathname(url.pathname);
  } catch {
    return text2("Malformed URI", { status: 400 });
  }
  let route = null;
  let params = {};
  if (base && !state.prerendering?.fallback) {
    if (!decoded.startsWith(base)) {
      return text2("Not found", { status: 404 });
    }
    decoded = decoded.slice(base.length) || "/";
  }
  const is_data_request = has_data_suffix(decoded);
  let invalidated_data_nodes;
  if (is_data_request) {
    decoded = strip_data_suffix(decoded) || "/";
    url.pathname = strip_data_suffix(url.pathname) + (url.searchParams.get(TRAILING_SLASH_PARAM) === "1" ? "/" : "") || "/";
    url.searchParams.delete(TRAILING_SLASH_PARAM);
    invalidated_data_nodes = url.searchParams.get(INVALIDATED_PARAM)?.split("").map((node) => node === "1");
    url.searchParams.delete(INVALIDATED_PARAM);
  }
  if (!state.prerendering?.fallback) {
    const matchers = await manifest2._.matchers();
    for (const candidate of manifest2._.routes) {
      const match = candidate.pattern.exec(decoded);
      if (!match)
        continue;
      const matched = exec(match, candidate.params, matchers);
      if (matched) {
        route = candidate;
        params = decode_params(matched);
        break;
      }
    }
  }
  let trailing_slash = void 0;
  const headers = {};
  let cookies_to_add = {};
  const event = {
    // @ts-expect-error `cookies` and `fetch` need to be created after the `event` itself
    cookies: null,
    // @ts-expect-error
    fetch: null,
    getClientAddress: state.getClientAddress || (() => {
      throw new Error(
        `${"@sveltejs/adapter-vercel"} does not specify getClientAddress. Please raise an issue`
      );
    }),
    locals: {},
    params,
    platform: state.platform,
    request,
    route: { id: route?.id ?? null },
    setHeaders: (new_headers) => {
      for (const key22 in new_headers) {
        const lower = key22.toLowerCase();
        const value = new_headers[key22];
        if (lower === "set-cookie") {
          throw new Error(
            "Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"
          );
        } else if (lower in headers) {
          throw new Error(`"${key22}" header is already set`);
        } else {
          headers[lower] = value;
          if (state.prerendering && lower === "cache-control") {
            state.prerendering.cache = /** @type {string} */
            value;
          }
        }
      }
    },
    url,
    isDataRequest: is_data_request,
    isSubRequest: state.depth > 0
  };
  let resolve_opts = {
    transformPageChunk: default_transform,
    filterSerializedResponseHeaders: default_filter,
    preload: default_preload
  };
  try {
    if (route) {
      if (url.pathname === base || url.pathname === base + "/") {
        trailing_slash = "always";
      } else if (route.page) {
        const nodes = await Promise.all([
          // we use == here rather than === because [undefined] serializes as "[null]"
          ...route.page.layouts.map((n) => n == void 0 ? n : manifest2._.nodes[n]()),
          manifest2._.nodes[route.page.leaf]()
        ]);
        if (DEV)
          ;
        trailing_slash = get_option(nodes, "trailingSlash");
      } else if (route.endpoint) {
        const node = await route.endpoint();
        trailing_slash = node.trailingSlash;
        if (DEV)
          ;
      }
      if (!is_data_request) {
        const normalized = normalize_path(url.pathname, trailing_slash ?? "never");
        if (normalized !== url.pathname && !state.prerendering?.fallback) {
          return new Response(void 0, {
            status: 308,
            headers: {
              "x-sveltekit-normalize": "1",
              location: (
                // ensure paths starting with '//' are not treated as protocol-relative
                (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
              )
            }
          });
        }
      }
    }
    const { cookies, new_cookies, get_cookie_header, set_internal } = get_cookies(
      request,
      url,
      trailing_slash ?? "never"
    );
    cookies_to_add = new_cookies;
    event.cookies = cookies;
    event.fetch = create_fetch({
      event,
      options: options2,
      manifest: manifest2,
      state,
      get_cookie_header,
      set_internal
    });
    if (state.prerendering && !state.prerendering.fallback)
      disable_search(url);
    const response = await options2.hooks.handle({
      event,
      resolve: (event2, opts) => resolve(event2, opts).then((response2) => {
        for (const key22 in headers) {
          const value = headers[key22];
          response2.headers.set(
            key22,
            /** @type {string} */
            value
          );
        }
        add_cookies_to_headers(response2.headers, Object.values(cookies_to_add));
        if (state.prerendering && event2.route.id !== null) {
          response2.headers.set("x-sveltekit-routeid", encodeURI(event2.route.id));
        }
        return response2;
      })
    });
    if (response.status === 200 && response.headers.has("etag")) {
      let if_none_match_value = request.headers.get("if-none-match");
      if (if_none_match_value?.startsWith('W/"')) {
        if_none_match_value = if_none_match_value.substring(2);
      }
      const etag = (
        /** @type {string} */
        response.headers.get("etag")
      );
      if (if_none_match_value === etag) {
        const headers2 = new Headers({ etag });
        for (const key22 of [
          "cache-control",
          "content-location",
          "date",
          "expires",
          "vary",
          "set-cookie"
        ]) {
          const value = response.headers.get(key22);
          if (value)
            headers2.set(key22, value);
        }
        return new Response(void 0, {
          status: 304,
          headers: headers2
        });
      }
    }
    if (is_data_request && response.status >= 300 && response.status <= 308) {
      const location = response.headers.get("location");
      if (location) {
        return redirect_json_response(new Redirect(
          /** @type {any} */
          response.status,
          location
        ));
      }
    }
    return response;
  } catch (e) {
    if (e instanceof Redirect) {
      const response = is_data_request ? redirect_json_response(e) : route?.page && is_action_json_request(event) ? action_json_redirect(e) : redirect_response(e.status, e.location);
      add_cookies_to_headers(response.headers, Object.values(cookies_to_add));
      return response;
    }
    return await handle_fatal_error(event, options2, e);
  }
  async function resolve(event2, opts) {
    try {
      if (opts) {
        if ("ssr" in opts) {
          throw new Error(
            "ssr has been removed, set it in the appropriate +layout.js instead. See the PR for more information: https://github.com/sveltejs/kit/pull/6197"
          );
        }
        resolve_opts = {
          transformPageChunk: opts.transformPageChunk || default_transform,
          filterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,
          preload: opts.preload || default_preload
        };
      }
      if (state.prerendering?.fallback) {
        return await render_response({
          event: event2,
          options: options2,
          manifest: manifest2,
          state,
          page_config: { ssr: false, csr: true },
          status: 200,
          error: null,
          branch: [],
          fetched: [],
          resolve_opts
        });
      }
      if (route) {
        const method = (
          /** @type {import('types').HttpMethod} */
          event2.request.method
        );
        let response;
        if (is_data_request) {
          response = await render_data(
            event2,
            route,
            options2,
            manifest2,
            state,
            invalidated_data_nodes,
            trailing_slash ?? "never"
          );
        } else if (route.endpoint && (!route.page || is_endpoint_request(event2))) {
          response = await render_endpoint(event2, await route.endpoint(), state);
        } else if (route.page) {
          if (page_methods.has(method)) {
            response = await render_page(event2, route.page, options2, manifest2, state, resolve_opts);
          } else {
            const allowed_methods2 = new Set(allowed_page_methods);
            const node = await manifest2._.nodes[route.page.leaf]();
            if (node?.server?.actions) {
              allowed_methods2.add("POST");
            }
            if (method === "OPTIONS") {
              response = new Response(null, {
                status: 204,
                headers: {
                  allow: Array.from(allowed_methods2.values()).join(", ")
                }
              });
            } else {
              const mod = [...allowed_methods2].reduce(
                (acc, curr) => {
                  acc[curr] = true;
                  return acc;
                },
                /** @type {Record<string, any>} */
                {}
              );
              response = method_not_allowed(mod, method);
            }
          }
        } else {
          throw new Error("This should never happen");
        }
        if (request.method === "GET" && route.page && route.endpoint) {
          const vary = response.headers.get("vary")?.split(",")?.map((v) => v.trim().toLowerCase());
          if (!(vary?.includes("accept") || vary?.includes("*"))) {
            response = new Response(response.body, {
              status: response.status,
              statusText: response.statusText,
              headers: new Headers(response.headers)
            });
            response.headers.append("Vary", "Accept");
          }
        }
        return response;
      }
      if (state.error) {
        return text2("Internal Server Error", {
          status: 500
        });
      }
      if (state.depth === 0) {
        return await respond_with_error({
          event: event2,
          options: options2,
          manifest: manifest2,
          state,
          status: 404,
          error: new Error(`Not found: ${event2.url.pathname}`),
          resolve_opts
        });
      }
      if (state.prerendering) {
        return text2("not found", { status: 404 });
      }
      return await fetch(request);
    } catch (e) {
      return await handle_fatal_error(event2, options2, e);
    } finally {
      event2.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      };
      event2.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
}
function filter_private_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k]) => k.startsWith(private_prefix) && (public_prefix === "" || !k.startsWith(public_prefix))
    )
  );
}
function filter_public_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k]) => k.startsWith(public_prefix) && (private_prefix === "" || !k.startsWith(private_prefix))
    )
  );
}
var _options, _manifest;
var Server = class {
  /** @param {import('@sveltejs/kit').SSRManifest} manifest */
  constructor(manifest2) {
    /** @type {import('types').SSROptions} */
    __privateAdd(this, _options, void 0);
    /** @type {import('@sveltejs/kit').SSRManifest} */
    __privateAdd(this, _manifest, void 0);
    __privateSet(this, _options, options);
    __privateSet(this, _manifest, manifest2);
  }
  /**
   * @param {{
   *   env: Record<string, string>
   * }} opts
   */
  async init({ env }) {
    set_private_env(
      filter_private_env(env, {
        public_prefix: __privateGet(this, _options).env_public_prefix,
        private_prefix: __privateGet(this, _options).env_private_prefix
      })
    );
    set_public_env(
      filter_public_env(env, {
        public_prefix: __privateGet(this, _options).env_public_prefix,
        private_prefix: __privateGet(this, _options).env_private_prefix
      })
    );
    if (!__privateGet(this, _options).hooks) {
      try {
        const module = await get_hooks();
        __privateGet(this, _options).hooks = {
          handle: module.handle || (({ event, resolve }) => resolve(event)),
          handleError: module.handleError || (({ error: error22 }) => console.error(error22)),
          handleFetch: module.handleFetch || (({ request, fetch: fetch2 }) => fetch2(request))
        };
      } catch (error22) {
        {
          throw error22;
        }
      }
    }
  }
  /**
   * @param {Request} request
   * @param {import('types').RequestOptions} options
   */
  async respond(request, options2) {
    if (!(request instanceof Request)) {
      throw new Error(
        "The first argument to server.respond must be a Request object. See https://github.com/sveltejs/kit/pull/3384 for details"
      );
    }
    return respond(request, __privateGet(this, _options), __privateGet(this, _manifest), {
      ...options2,
      error: false,
      depth: 0
    });
  }
};
_options = new WeakMap();
_manifest = new WeakMap();

// .svelte-kit/vercel-tmp/fn/manifest.js
var manifest = (() => {
  function __memo(fn) {
    let value;
    return () => value ?? (value = value = fn());
  }
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set(["favicon.png"]),
    mimeTypes: { ".png": "image/png" },
    _: {
      client: { "start": "_app/immutable/entry/start.16367a98.js", "app": "_app/immutable/entry/app.6a660089.js", "imports": ["_app/immutable/entry/start.16367a98.js", "_app/immutable/chunks/scheduler.e51e3a72.js", "_app/immutable/chunks/singletons.844f0d64.js", "_app/immutable/chunks/index.6cb2aa35.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/entry/app.6a660089.js", "_app/immutable/chunks/scheduler.e51e3a72.js", "_app/immutable/chunks/index.70313ae9.js"], "stylesheets": [], "fonts": [] },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4))),
        __memo(() => Promise.resolve().then(() => (init__5(), __exports5))),
        __memo(() => Promise.resolve().then(() => (init__6(), __exports6))),
        __memo(() => Promise.resolve().then(() => (init__7(), __exports7)))
      ],
      routes: [
        {
          id: "/(authed)",
          pattern: /^\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 3 },
          endpoint: null
        },
        {
          id: "/api/file",
          pattern: /^\/api\/file\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts(), server_ts_exports)))
        },
        {
          id: "/api/item",
          pattern: /^\/api\/item\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts2(), server_ts_exports2)))
        },
        {
          id: "/api/seed",
          pattern: /^\/api\/seed\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts3(), server_ts_exports3)))
        },
        {
          id: "/(unauthed)/signin",
          pattern: /^\/signin\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 5 },
          endpoint: null
        },
        {
          id: "/(unauthed)/signup",
          pattern: /^\/signup\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 6 },
          endpoint: null
        },
        {
          id: "/(authed)/[itemId]",
          pattern: /^\/([^/]+?)\/?$/,
          params: [{ "name": "itemId", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 4 },
          endpoint: null
        }
      ],
      matchers: async () => {
        return {};
      }
    }
  };
})();

// .svelte-kit/vercel-tmp/fn/edge.js
var server = new Server(manifest);
var initialized = server.init({
  env: (
    /** @type {Record<string, string>} */
    process.env
  )
});
var edge_default = async (request, context) => {
  await initialized;
  return server.respond(request, {
    getClientAddress() {
      return (
        /** @type {string} */
        request.headers.get("x-forwarded-for")
      );
    },
    platform: {
      context
    }
  });
};
export {
  edge_default as default
};
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
/*!
* focus-trap 7.5.2
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.js.map
